<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ThreadPoolExecutor源码解析]]></title>
    <url>%2F2018%2F06%2F24%2FThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一. 线程池概述在介绍线程池之前，先说一下为什么在开发中要使用线程池，个人认为主要有一下的原因： 开发中使用线程的时候，大部分线程执行的时间很短，频繁的创建、启动、销毁线程带来不必要的资源消耗。 线程的创建、挂起、唤醒等操作都需要依靠CPU调度，大量的线程会频繁进行上下文切换，特别是任务执行时间短、任务数量多的情况，大量时间将花在上下文切换上，又耗时，又耗资源。 无法对任务做统一的管理、分配、和监控等。 线程池主要通过ThreadPoolExecutor来实现，在ThreadPoolExecutor类注释上有下面一段话（下面是翻译过来的）： 线程池解决了两个不同的问题：由于减少了每个任务的调用开销，改进了执行大量异步任务的性能；并且它还提供了一种任务执行时限制和管理资源（包括线程）的方法。 同时每个ThreadPoolExecutor还维护一些基本统计信息，例如已完成任务的数量。 二. 线程池的构造方法参数解析构造方法中各个参数的含义先上一张图，有个大概的印象。 这里任务加入可以看做是放入了两个地方，一是线程池中，另一个是任务队列中。 放入线程池的又分为两个部分，一是corePoolSize，暂且叫做核心线程（下图红色部分），另一部分是非核心线程（下图橙色部分），核心线程+非核心线程 &lt;= maximumPoolSize。 参 数 含 义 corePoolSize 核心线程数，当向线程池中添加新任务的时候，如果此时线程数量小于corePoolSize，哪怕线程池中有空闲的线程，此时也会重新新建一个线程来处理这个任务请求。同时corePoolSize也是线程池中维持的线程数量，就算都是空闲线程的也会存在，除非设置了allowCoreThreadTimeOut。 maximumPoolSize 线程池中最大的线程数量，当向线程池中添加新任务的时候如果此时线程数量大于corePoolSize，小于maximumPoolSize，并且队列已经满了，将会新建线程来处理这个任务请求。 keepAliveTime 非核心线程在空闲后存活的是时间。 unit keepAliveTime的单位 workQueue 任务队列，常用的有三种：SynchronousQueue（默认使用的队列）、LinkedBlockingQueue、ArrayBlockingQueue threadFactory 创建线程的工厂，默认使用DefaultThreadFactory handler 被拒绝后的处理，拒绝处理策略。 a. CallerRunsPolicy，由调用execute方法提交任务的线程来执行这个任务b. AbortPolicy，抛出异常RejectedExecutionException拒绝提交任务c. DiscardPolicy，直接抛弃任务，不做任何处理 d. DiscardOldestPolicy，去除任务队列中的第一个任务，重新提交 构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//使用默认的ThreadFactory和拒绝处理策略public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125; //使用默认的拒绝处理策略 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125;//使用默认的ThreadFactory public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler); &#125;//传入所有参数，并且对参数进行校验 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; 三. 工作原理其原理如下图所示： 当一个新加一个任务的时候执行如下步骤： 首先尝试新建核心线程启动任务 核心线程已经满了，尝试加入到队列中 队列已经满了，尝试新建非核心线程启动任务 非核心线程已满，执行拒绝策略 同时，当线程池中的工作线程执行完一个Task后会从队列中take任务执行。 四. UML类图 AbstractExecutorService，提供了ExecutorService的默认实现。 ExecutorService，定义了管理终止任务的一些方法以及让任务返回Future的方法。 Executor，只定义了一个execute()方法，任务的提交执行。 AbortPolicy、DiscardOldestPolicy、DiscardPolicy、CallerRunsPolicy，ThreadPoolExecutor内部定义的拒绝策略类。 Worker，是实现线程池重要的内部类，其UML类图如下： Worker类主要是运行任务的以及维护线程的中断控制状态，以及其他状态的记录。Worker类继承AbstractQueuedSynchronizer以简化每个任务执行时候的锁的获取和释放。 五. 源码分析 注意区分Worker和Taks，Worker是指工作线程，也就是用来执行任务的线程，Task是线程执行的任务（添加到队列中的就是任务）。 ThreadPoolExecutor关键变量ThreadPoolExecutor使用一个原子integer(AtomicInteger)变量ctl（32位），来表示线程池的控制状态，这个状态值实际上由两部分组成： workerCount：有效的线程数，最大(2^29)-1，为ctl的低29位 runState：线程池运行状态，保存在ctl高位3位。 123456789101112131415161718192021//ctl初始化的时候状态为RUNNING，workerCount为0 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); //workerCount位数 private static final int COUNT_BITS = Integer.SIZE - 3; //workerCount容量，(2^29)-1 private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // runState 的状态 private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; private static final int STOP = 1 &lt;&lt; COUNT_BITS; private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 获取runState private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125; //获取workerCount private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 说一下上面线程池的几种状态： RUNNING：可以接受新的任务，并且处理在队列中的任务。 SHUTDOWN：不再接受新的任务，但是会把队列中的任务处理完成。 STOP：不再接受新的任务，也不处理队列中的任务，并且正在处理的任务会被中断。 TIDYING：所有任务都终止了，线程要转换到TIDYING状态，需要运行terminated()钩子方法。 TERMINATED：terminated()执行完成，到达这个状态时候awaitTermination()方法返回。 在ThreadPoolExecutor类注释中提到状态之间的转换情况： RUNNING -&gt; SHUTDOWN：调用shutdown()，或者隐式调用finalize()。 (RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()。 SHUTDOWN -&gt; TIDYING：当线程池和队列都为空的时候。 STOP -&gt; TIDYING：线程池为空的时候。 TIDYING -&gt; TERMINATED：钩子方法terminated()执行完成。 execute(Runnable command)execute(Runnable command)，提交任务。 12345678910111213141516171819202122232425public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; //如果线程池状态为Running（其他状态拒绝添加新任务到队列）将任务添加到队列中。 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //添加成功后进行recheck int recheck = ctl.get(); //如果当前状态不是Running,从队列中移除任务。 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //刚刚在队列中加入了任务，保证线程池中至少有一个工作线程可以处理任务。 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // else if (!addWorker(command, false)) reject(command); &#125; 分为3步来执行： 如果workerCount小于corePoolSize，将任务作为first Task新建线程来执行任务。 将任务添加到队列中，如果添加成功依然需要检查，在进入任务之前，如果线程池被关闭，那么将任务从队列中移除；如果当前线程池中没有工作线程，而刚刚在队列中加入了任务，要保证线程池中至少有一个工作线程可以处理任务。 如果不能将任务加入队列中，尝试新加一个线程来执行任务，但是并不定会成功，可能是线程池被shut down或者线程池达到了饱和（maximumPoolSize），如果失败了执行拒绝策略。 关于Worker的构造函数在介绍addWorker(Runnable firstTask, boolean core)之前我们来看看Worker的构造函数。 12345Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; Worker实现了Runnable，这里将其构造为Thread赋值给thread。第一步中的setState(-1)，这一步很有意思，将AQS中的同步状态设置为-1，到后面我们会看到，线程池使用AQS中的同步状态来判断该工作线程是否可以被中断。-1：初始化值，此时工作线程还没有启动，也没有中断的必要；0：表示接受中断，此时工作线程为空闲状态；1：表示此时工作线程正在执行任务。 addWorker(Runnable firstTask, boolean core)检查根据当前线程池的工作状态和给定的界限限制（corePoolSize 和maximumPoolSize）是否可以添加新的工作线程。 如果添加了新的工作线程，workerCount会相应调整，并且如果可能的话将firstTask作为其第一个任务运行。 如果线程池停止（Stop）或关闭(ShutDown)，此方法返回false。如果线程工厂未能创建线程，它也会返回false。如果线程创建失败，无论是由于线程工厂返回null还是由于异常（通常是Thread.start（）中的OutOfMemoryError），都会进行回滚。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** *@Param core：如果为true把corePoolSize作为解析，否则把maximumPoolSize作为界限。 * */private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //将下面的判断拆开来看。 //rs &gt;= SHUTDOWN，在这个前提下，需要满足： //! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty()) //上面的可以这样理解，只有在同时满足三个条件的情况下才会返回false，所以话句话说，只要有一个不满足，就会返回true //将上面的判断修改为 (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty()) //rs != SHUTDOWN：基于rs &gt;= SHUTDOWN的前提下，当rs != SHUTDOWN，不再创建新的线程。 //firstTask != null：基于rs &gt;= SHUTDOWN的前提下，不再接受新的任务。 //workQueue.isEmpty()：任务队列为空，不用再创建新的工作线程来处理任务。 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); //检查工作线程数是否超过了界限，超过了返回false if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //使用CAS修改workerCount,加1，成功跳出循环 if (compareAndIncrementWorkerCount(c)) break retry; //+1操作失败，其他任务添加修改了workerCount值，继续循环。 c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; &#125; &#125; //工作线程是否启动 boolean workerStarted = false; //工作线程是否添加成功 boolean workerAdded = false; Worker w = null; try &#123; //新加一个工作线程，Worker本身也实现了Runabble w = new Worker(firstTask); //这路获取到的其实是使用Worker生成的Thread final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //在获取到锁之后再次检查状态 int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //添加到工作线程组中 workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) //记录当前工作线程总数 largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; //添加工作线程成功。 if (workerAdded) &#123; //启动工作线程，其实执行的是Worker中的run() t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; Worker中的run()Worker的run()方法实际调用的是runWorker(this)，启动工作线程（注意这里不是直接启动的任务），在工作线程中执行任务。 工作线程在这循环，反复的从队列中获取任务并执行它们。 启动了初始的任务，也就是最开始创建工作线程的时候的firstTask。否则，只要线程池还在运行中，使用getTask()从队列中获取任务来执行。如果改变了线程池的工作状态，或者工作参数，getTask()返回null，此时工作线程将退出。或者工作线程因为异常而退出，此时异常退出标记completedAbruptly为true，之后会通过processWorkerExit新建一个工作线程来替换它。 在运行所有任务之前，需要获取锁，来保证当任务在运行的时候不会被中断，除非线程池正在停止（Stop） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void run() &#123; runWorker(this); &#125; final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); //获取任务 Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // 将AQS同步状态设置为0（初始值为-1），表示当前工作线程为闲置状态，可以被中断了。 //异常退出标记。 boolean completedAbruptly = true; try &#123; //getTask()从队列中获取任务 while (task != null || (task = getTask()) != null) &#123; w.lock(); //再次检查工作线程状态 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; //执行前的钩子方法 beforeExecute(wt, task); Throwable thrown = null; try &#123; //注意区分和start(),调用run()并不会另启线程，而是在当前线程中执行，所以任务其实是在工作线程中执行的。 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; //执行后的钩子方法 afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; //工作线程退出后的操作。 processWorkerExit(w, completedAbruptly); &#125; &#125; getTask()从队列中获取Task，大概分为以下几个步骤。 判断线程池以及队列的状态，如果线程池状态在STOP以上，此时线程池不处理队列中的任务；或者线程池处于SHUTDOWN但是队列为空（SHUTDOWN不再接受新的任务），workerCount减1，返回null,注意此时只是将变量减1，其实工作线程并没有终止真正的终止在 processWorkerExit(w, completedAbruptly);中。 如果通过了状态检查，判断是否要进行线程回收，如果需要workerCount数量减1，成功后返回null。 根据timed（timed表示需要进行超时闲置线程回收），选择是限时等待还是阻塞的方式从队列中获取任务。 12345678910111213141516171819202122232425262728293031323334353637383940414243private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // 如果线程池已经关闭（STOP状态不再处理队列中的任务），或者队列为空，workerCount减1，返回空。 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // allowCoreThreadTimeOut，是否允许回收核心线程。 // timed表示需要进行超时闲置线程回收。 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //1. (wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)：如果工作线程数量大于maximumPoolSize，或者闲置线程超时。 //2. (wc &gt; 1 || workQueue.isEmpty())：队列不为空时，至少需要保留一个工作线程来处理队列中的任务 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; //workerCount数量减1，CAS操作，失败了会不断循环。 if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; //根据timed，选择是限时等待还是阻塞的方式从队列中获取任务。 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; //workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 一段时间拿不到返回null,表示超时。 timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125; &#125; 说到getTask()顺便介绍几种队列： SynchronousQueue：Executors.newCachedThreadPool()中使用的队列。与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue，每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。所以使用这个队列，任务会直接提交给线程处理，所以一般会把maximumPoolSize指定成Integer.MAX_VALUE。 ArrayBlockingQueue：有界队列，队列可以限定长度，当添加新任务的时候，如果当前工作线程数量小于corePoolSize，则新建线程执行任务，否则如队列，以为队列是有限的，如果队列已经满了就会新建非核心线程执行任务，如果非核心线程也饱和了就会被拒绝，执行拒绝策略。 LinkedBlockingQueue（不设置预定值）：无界队列，因为是无界队列，所以maximumPoolSize这个属性的设定失效，线程池中的工作线程数用于不会大于corePoolSize。 processWorkerExit(Worker w, boolean completedAbruptly)工作线程退出后的操作，在这里进行线程池的终止以及工作线程的回收。 12345678910111213141516171819202122232425262728293031323334private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; //如果是异常退出，workerCount数量减1 if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; completedTaskCount += w.completedTasks; //从工作线程组中移除工作线程 workers.remove(w); &#125; finally &#123; mainLock.unlock(); &#125; //尝试终止线程池 tryTerminate(); int c = ctl.get(); if (runStateLessThan(c, STOP)) &#123; //如果是异常退出,直接新加一个工作线程。 if (!completedAbruptly) &#123; //如何设置了allowCoreThreadTimeOut，最小工作线程数为0，否则为corePoolSize int min = allowCoreThreadTimeOut ? 0 : corePoolSize; //如果最小工作线程数为0，而队列又不为空，说明至少要保留一个工作线程 if (min == 0 &amp;&amp; ! workQueue.isEmpty()) min = 1; //如果当前工作线程数还大于最小工作线程数，直接返回，不添加新的工作线程 if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; addWorker(null, false); &#125; &#125; tryTerminate()尝试终止线程池。 1234567891011121314151617181920212223242526272829303132333435363738394041final void tryTerminate() &#123; for (;;) &#123; int c = ctl.get(); //以下三种情况表示不需要终止线程池。 //1. isRunning(c)：处于Running状态。 //2. runStateAtLeast(c, TIDYING)：TIDYING或者TERMINATED，已经在关闭了，不用重复关闭。 //3. (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())：线程池处于SHUTDOWN状态，但是队列中还有任务没处理完。 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return; //如果还有工作线程，终止一个空闲的工作线程后退回，这个时候表示并不想终止线程池。 if (workerCountOf(c) != 0) &#123; // Eligible to terminate //只终止一个工作线程 interruptIdleWorkers(ONLY_ONE); return; &#125; //下面的操作是在终止线程池，修改线程池状态。 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //设置为TIDYING状态，调用terminated()钩子方法 if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; terminated(); &#125; finally &#123; //终止操作完成，设置状态为TERMINATED ctl.set(ctlOf(TERMINATED, 0)); // 释放在termination条件上等待的所有线程 termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // CAS操作失败后不断的循环。 &#125; &#125; interruptIdleWorkers(boolean onlyOne)中断闲置工作线程。重点是如何判断哪些是闲置的工作线程，并且可以被中断。满足 !t.isInterrupted() &amp;&amp; w.tryLock() : !t.isInterrupted()表示没有被中断。 w.tryLock()表示能获取到锁，获取到锁AQS的同步状态为0，表示工作线程闲置。 12345678910111213141516171819202122232425//tru表示只中断一个线程private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; for (Worker w : workers) &#123; Thread t = w.thread; //如果没有被中断，并且能成功获取到锁（获取到锁AQS的同步状态为0，表示工作线程闲置），那么就进行中断，不能获取到锁表示队列中有任务正在执行。 if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; //进行中断操作。 t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; w.unlock(); &#125; &#125; //如果只中断一个，中断一个跳出。 if (onlyOne) break; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125; shutdown()调用shutdown()，拒绝接受新的任务加入，会将正在执行的任务以及等待执行的任务执行完成，终止所有的闲置工作线程。 123456789101112131415161718public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //检查是否有Shutdown权限 checkShutdownAccess(); //设置线程池状态为SHUTDOWN advanceRunState(SHUTDOWN); //关闭闲置的工作线程，最后调用的是interruptIdleWorkers(false) interruptIdleWorkers(); //钩子方法 onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; //终止 tryTerminate(); &#125; shutdownNow()调用shutdownNow()会尝试停止所有执行的任务，也不会对队列中的等待任务进行处理，并返回等待执行的任务列表，它会终止所有的工作线程，与shutdown()不同，shutdown()只会终止所有的空闲工作线程。1234567891011121314151617181920public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //检查是否有Shutdown权限 checkShutdownAccess(); //设置线程池状态为STOP advanceRunState(STOP); //终止所有工作线程 interruptWorkers(); //获取等待执行的任务列表 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; //尝试终止线程池。 tryTerminate(); return tasks; &#125; interruptWorkers() 以及 interruptIfStarted()终止所有的工作线程。主要看看interruptIfStarted()中是如何判断哪些工作线程是可以被终止的，满足 getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted() : getState() &gt;= 0 获取CAS同步状态，上面说到同步状态初始化为-1，-1表示不可以被中断（可以看做当前工作线程没有启动），0表示闲置工作线程，1表示正在执行任务的工作线程。 (t = thread) != null 这个不用说了，为空还终止个啥。 !t.isInterrupted()，没有终止，避免重复调用。 12345678910111213141516171819202122private void interruptWorkers() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; for (Worker w : workers) w.interruptIfStarted(); &#125; finally &#123; mainLock.unlock(); &#125; &#125; void interruptIfStarted() &#123; Thread t; //getState()用于判断线程是否启动，具体看上面的解释。 if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java同步器——AQS学习]]></title>
    <url>%2F2018%2F06%2F21%2FJava%E5%90%8C%E6%AD%A5%E5%99%A8%E2%80%94%E2%80%94AQS%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一. 概述AQS（AbstractQueuedSynchronizer），队列同步器，Java中很多同步类都是基于AQS实现的，比如：ReentrantLock、Semaphore、CountDownLatch等。 AQS提供了一个实现阻塞锁和相关同步组件的框架，这个框架实现依赖于FIFO（first-in-first-out，先进先出）的等待队列来完成获取资源线程的排队工作。AQS是绝大多数同步器的基础，它的内部使用一个 int 型的变量表示同步状态(资源状态)，AQS并不维护这个状态的值，只是提供了一系列的原子更新方法，getState、setState、compareAndSetState，而由继承AQS的子类去重写特定定的方法实现对共享资源的获取和释放，而其他的比如线程排队、线程挂起、线程唤醒出队等已经在AQS中实现好了（典型的设计模式中模板方法模式的使用）。 AQS定义了两种资源共享的方式： Exclusive：独占式，只有一个线程能获取资源并执行，比如ReentrantLock。 Share：共享式，多个线程获取资源，多个线程可以同时执行，比如CountDownLatch。 上面提到过AQS需要继承它的子类去重新特定的方法，而不同方式（共享和独占）需要重写的方法也不一样，下面来看看AQS中定义的可以重写的方法： protected boolean tryAcquire(int arg) : 独占式获取同步状态，tru表示获取成功，false表示获取失败，获取成功后其他线程需要等待该线程释放同步状态后才能获取同步状态。 protected boolean tryRelease(int arg) ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态。 protected int tryAcquireShared(int arg) ：共享式获取同步状态，返回值大于等于0表示获取成功；否则获取失败。 protected boolean tryReleaseShared(int arg) ：共享式释放同步状态，成功为true，失败为false。 protected boolean isHeldExclusively() ： 当前同步器是是否在独占模式下被线程占用，使用conditions的时候才需要覆盖该方法。 看看tryAcquire(int arg)，发现AQS中并没有把其定义为抽象方法，而是抛出UnsupportedOperationException异常，像上面所说的，不同的共享方式覆盖特定的方法，而不用实现其所不需要的方法，提供了灵活性。123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException(); &#125; 二. FIFO等待队列的实现在具体分析之前，先看看AQS是如何实现FIFO的等待队列的，AQS的等待队列是”CLH” (Craig, Landin, and Hagersten) 队列的一种变体，关于”CLH”锁可以参照——自旋锁&amp;CLH锁&amp;MCS锁学习记录。在每个节点中保存了前后节点的引用，节点中的“waitStatus”字段用于表示线程的状态。节点的前驱节点在释放资源的时候发出信号，通知节点可以竞争资源。如果线程是队列中的第一个线程，则可能尝试获取资源，但是并不保证一定成功，队列中的第一个线程只是具有了竞争资源的权利。 AQS注释中给出的CLH队列结构如下： 123 +------+ prev +-----+ +-----+head | | &lt;---- | | &lt;---- | | tail +------+ +-----+ +-----+ head：head最开始是一个空节点，之后可以认为是当前获取到资源的线程所在的节点。 prev：节点持有的前驱节点的引用（其实AQS代码中还有一个next，持有对下一个节点的引用，所以AQS中的等待队列是一个双向的队列）。 tial：资源竞争失败会插入到队列，而tail始终指向最后插入队列的节点。 下面是AQS中等待队列实现的部分代码： 12345678910111213141516171819202122232425262728293031323334static final class Node &#123; //用于共享模式的节点声明 static final Node SHARED = new Node(); //用于独占模式的节点声明 static final Node EXCLUSIVE = null; /**一下是waitStatus的值的状态*/ //表示线程被取消 static final int CANCELLED = 1; //等待触发 static final int SIGNAL = -1; //线程等待条件 static final int CONDITION = -2; //状态需要向后传播 static final int PROPAGATE = -3; //线程状态，具有上面4个状态 volatile int waitStatus; //前驱节点 volatile Node prev; //后继节点 volatile Node next; //当前线程 volatile Thread thread; Node nextWaiter; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125; &#125; 使用volatile修饰变量，保证变量在多线程之间的可见性 waitStatus表示线程的状态： CANCELLED：线程被取消。（非负值） SIGNAL：等待触发，只有当前节点的前驱节点状态为SIGNAL，当前节点的线程才可以被挂起。 CONDITION：等待条件状态。 PROPAGATE：状态需要向后传播。 0：普通的同步器初始化为0。 前驱节点prev和后继节点next 三. 独占式在AQS类注释中，有一段独占锁代码的实现，以下面的例子来分析AQS的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package io.github.brightloong.concurrent.aqs;import java.io.IOException;import java.io.ObjectInputStream;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;/** * Created by BrightLoong on 2018/6/19. */public class Mutex implements Lock, java.io.Serializable &#123; // Our internal helper class private static class Sync extends AbstractQueuedSynchronizer &#123; // Reports whether in locked state protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; // Acquires the lock if state is zero public boolean tryAcquire(int acquires) &#123; assert acquires == 1; // Otherwise unused if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; // Releases the lock by setting state to zero protected boolean tryRelease(int releases) &#123; assert releases == 1; // Otherwise unused if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; &#125; // Provides a Condition Condition newCondition() &#123; return new ConditionObject(); &#125; // Deserializes properly private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125; &#125; // The sync object does all the hard work. We just forward to it. private final Sync sync = new Sync(); public void lock() &#123; sync.acquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unlock() &#123; sync.release(1); &#125; public Condition newCondition() &#123; return sync.newCondition(); &#125; public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125;&#125; lock——加锁看上面的代码，加锁lock()函数，调用的是sync.acquire(1)，从acquire(int arg)函数入手，依次分析加锁过程中涉及到的函数代码。 acquire(int arg)12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; tryAcquire(arg)获取资源，获取失败执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg))进行等待 addWaiter(Node.EXCLUSIVE)将独占模式节点添加到等待队列中，添加成功后返回节点 acquireQueued(addWaiter(Node.EXCLUSIVE), arg))节点在队列中获取资源，获取不成功，阻塞节点，直到被唤醒，返回中断状态 如果发生了中断，进行中断补偿 addWaiter(Node mode)用于将当前线程加入到等待队列中,并返回当前节点。12345678910111213141516171819private Node addWaiter(Node mode) &#123; //按照给定的方式构造队列，上面提到的EXCLUSIVE（独占模式）和Share（共享模式） Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure //快速入队，尝试将节点放到队尾，获取前驱节点，如果获取到了表示有线程占用了资源。 Node pred = tail; if (pred != null) &#123; //将新建节点的前驱节点设置为获取到的前驱节点 node.prev = pred; //原子更新tail，将tail更新为当前节点，可能更新失败，因为在执行step1前可能有其他线程更新了tail if (compareAndSetTail(pred, node)) &#123;//step1 pred.next = node; return node; &#125; &#125; //如果上面的操作执行失败，执行enq(node) enq(node); return node; &#125; 按照给定的方式构造节点，上面提到的EXCLUSIVE（独占模式）和Share（共享模式）。 快速入队，如果失败通过 enq(node) 入队（full enq）。 enq(final Node node)将当前线程对应的节点添加到等待队列中，不断循环直到添加成功。1234567891011121314151617181920212223private Node enq(final Node node) &#123; //不断循环，直到节点成功添加到队列中。 for (;;) &#123; Node t = tail; //tail等于null，表示当前资源没有被占用 if (t == null) &#123; //原子操作，初始化head节点，操作可能失败，因为可能有其他线程在这个时候已经初始化成功了。 if (compareAndSetHead(new Node())) //成功后将tail指向head tail = head; &#125; else &#123; //如果tail不等于null,将当前节点的前驱节点设置为tail。 node.prev = t; //将tail原子更新成当前节点，可能失败，因为tail可能被其他线程更新。 if (compareAndSetTail(t, node)) &#123; //构建为双向队列 t.next = node; //添加成功，放回当前节点。 return t; &#125; &#125; &#125; &#125; 判断tail节点是否为空，如果为空执行1，不为空执行2。 如果tail节点为空，初始化head节点，并将tail节点指向head节点，执行1。 如果tail节点不为空，尝试将当前节点添加到队尾，添加成功返回当前节点，否则执行1，直到添加成功。 acquireQueued(final Node node, int arg)在队列中尝试获取资源，获取失败后判断是否真正需要进入阻塞状态，如果是将阻塞线程，直到被唤醒，并返回中断状态。不断循环，直到获取到资源或者进入阻塞状态等待被唤醒。 12345678910111213141516171819202122232425final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取前驱节点 final Node p = node.predecessor(); //如果前驱节点为head节点，表示具有竞争资源的机会，使用tryAcquire(arg)获取同步状态 //如果成功，表示获取到资源，将head设置成当前节点（所以可以认为head其实是当前获取到资源的线程节点,最后始终要执行到这里），返回中断状态为false。 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; //如果获取资源过程中执行失败，停止获取资源 if (failed) cancelAcquire(node); &#125; &#125; shouldParkAfterFailedAcquire(Node pred, Node node)获取资源失败后判断线程是否需要真正进入阻塞，只有在前驱节点waitStatus值为SIGNAL，当前节点的线程才需要进入阻塞。 1234567891011121314151617181920212223private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; //获取前驱节点的waitStatus值 int ws = pred.waitStatus; //如果状态为SIGNAL，表示当前节点可以进入等待的状态，返回true。 if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; //4个状态中大于0的状态是CANCELLED，如果线程已经放弃了，那就是所谓的占着厕所不拉屎（话糙理不糙，哈哈） //这个时候就往前找，一直找到，直到找到状态正常的那个节点，并让自己排在它的后面。 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //如果状态不是CANCELLED，也就是说状态正常，将前驱节点的状态设置为SIGNAL，有可能失败， //前驱状态有可能发生了改变 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false; &#125; parkAndCheckInterrupt()终于，在这里线程进入了阻塞，调用 LockSupport.park(this)阻塞线程 123456private final boolean parkAndCheckInterrupt() &#123; //调用LockSupport.park()使线程进入waiting状态。 LockSupport.park(this); //当线程被唤醒，返回中断状态（） return Thread.interrupted(); &#125; 流程图获取资源的流程如下所示，可以看到流程中有两个循环。 releaseLock——释放锁从release(int arg)函数开始，一步步分析独占方式锁的释放。 release(int arg)1234567891011public final boolean release(int arg) &#123; //调用使用者重写的tryRelease方法，若成功，唤醒其后继结点，失败则返回false if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) //唤醒后继节点 unparkSuccessor(h); return true; &#125; return false; &#125; unparkSuccessor(Node node)唤醒后继节点 123456789101112131415161718192021private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; //修改当前节点的状态为0，允许失败 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); //一般来说需要唤醒的就是下一个节点，但是下一个节点可能是null //或者其状态是取消状态，所以从tail开始先前查找，一直找到状态正常的节点。 Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) //唤醒线程 LockSupport.unpark(s.thread); &#125; 四. 共享式AQS类注释中同样提供了一个简单的实现： 1234567891011121314151617181920212223242526272829303132package io.github.brightloong.lab.concurrent.cas;import java.util.concurrent.locks.AbstractQueuedSynchronizer;/** * BooleanLatch class * * @author BrightLoong * @date 2018/6/21 */public class BooleanLatch &#123; private static class Sync extends AbstractQueuedSynchronizer &#123; boolean isSignalled() &#123; return getState() != 0; &#125; protected int tryAcquireShared(int ignore) &#123; return isSignalled() ? 1 : -1; &#125; protected boolean tryReleaseShared(int ignore) &#123; setState(1); return true; &#125; &#125; private final Sync sync = new Sync(); public boolean isSignalled() &#123; return sync.isSignalled(); &#125; public void signal() &#123; sync.releaseShared(1); &#125; public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125;&#125; 和CountDownLatch很类似可以多个线程await()，但是只需要调用一次signal() 就可以启动阻塞的线程。 共享模式从 acquireShared(int arg)入手来进行分析，与独占模式不同的是，共享模式下同一时刻可以有多个线程获取到资源执行。 acquireShared(int arg)获取同步状态。 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125; 使用tryAcquireShared(arg) 获取资源状态 返回值大于0，获取同步状态成功，同时还有剩余同步状态可供其他线程获取； 返回值等于0时，获取同步状态成功，但没有可用同步状态了； 返回值小于0时，表示获取同步状态失败。 获取失败执行doAcquireShared(arg) doAcquireShared(int arg)1234567891011121314151617181920212223242526272829303132333435private void doAcquireShared(int arg) &#123; //添加共享模式的节点到等待队列中，添加成功后返回当前节点 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取前驱节点 final Node p = node.predecessor(); //如果前驱节点是head，表示可能具有竞争资源的机会,可能head释放资源后来唤醒自己 if (p == head) &#123; //尝试获取资源，获取同步状态。 int r = tryAcquireShared(arg); //大于等于0表示资源获取成功 if (r &gt;= 0) &#123; //更新头节点，如果还有资源可用，向后传播，唤醒后继节点。 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) //中断补偿 selfInterrupt(); failed = false; return; &#125; &#125; //获取资源失败后判断线程是否真正需要挂起，和独占方式相同 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 使用addWaiter(Node.SHARED)，添加到等待队列中。 在队列中获取资源，获取成功后因为是共享式，如果还有资源可用，向后传播，唤醒后继节点。 获取失败，和独占式一样，检查是否真正需要进入阻塞等待被唤醒或者中断，如果是进入阻塞，如果不是继续循环。 setHeadAndPropagate(Node node, int propagate)123456789101112private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below //将当前节点设置为head setHead(node); //同步状态大于0，表示资源还可以被获取，唤醒后继节点 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125; &#125; 因为获取资源成功，将当前节点设置为head，并唤醒后继节点 doReleaseShared()相对的分析一下 acquireShared(int arg) 12345678910111213141516171819202122232425private void doReleaseShared() &#123; //因为在共享模式下，获取同步状态和释放同步状态可能同时进行，用CAS保证原子性 for (;;) &#123; //获取head Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; //节点状态为SIGNAL，可以唤醒下一个节点 if (ws == Node.SIGNAL) &#123; //设置waitStatus为初始状态0 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases //唤醒后继节点 unparkSuccessor(h); &#125; //设置为PROPAGATE，表示可以向后传播 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; //head变化了继续循环，共享模式下每唤醒一个后继节点，head//就会指向他，这样就可以保证唤醒所有的能获取到资源的后继节点 if (h == head) // loop if head changed break; &#125; &#125; compareAndSetWaitStatus(h, Node.SIGNAL, 0)执行失败后继续循环，因为这个函数本身就会被多个线程调用（release和Acquire也是同时），所以状态很有可能被其他线程更改。 compareAndSetWaitStatus(h, 0, Node.PROPAGATE)和上面同理 releaseShared(int arg)12345678public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; //唤醒后继节点，并且检查是否可以向后传播 doReleaseShared(); return true; &#125; return false; &#125; 调用tryReleaseShared(arg)释放资源，成功返回true 调用doReleaseShared()唤醒后继节点并进行传播 其他关于AQS中的ConditionObject，之后再分析 参考 https://www.jianshu.com/p/d8eeb31bee5c https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自旋锁&CLH锁&MCS锁学习记录]]></title>
    <url>%2F2018%2F06%2F17%2F%E8%87%AA%E6%97%8B%E9%94%81%26CLH%E9%94%81%26MCS%E9%94%81%2F</url>
    <content type="text"><![CDATA[本篇文章主要记录自旋锁、CLH锁、MCS锁的学习所得。关于自旋锁和CLH锁、MCS锁，网上已经有很多内容，而且很类似；学习就是学习前人经验，理解、总结，化为己用，因此，虽然网上有很多相关的内容，我也是参考了这些内容，我依然选择记录下了自己的理解，方便自己查阅。 一. 自旋锁自旋锁（SpinLock）：多个线程，当一个线程尝试获取锁的时候，如果锁被占用，就在当前线程循环检查锁是否被释放，这个时候线程并没有进入休眠或者挂起。 代码实现下面是自旋锁的简单实现： 12345678910111213141516171819202122232425262728package io.github.brightloong.concurrent.lock;import java.util.concurrent.atomic.AtomicReference;/** * Created by BrightLoong on 2018/6/13. * 自旋锁 */public class SpinLock &#123; //AtomicReference，CAS，compareAndSet保证了操作的原子性 private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;(); public void lock() &#123; Thread currentThread = Thread.currentThread(); // 如果锁未被占用，则设置当前线程为锁的拥有者，设置成功返回true，否则返回false // null为期望值，currentThread为要设置的值，如果当前内存值和期望值null相等，替换为currentThread while (!owner.compareAndSet(null, currentThread)) &#123; &#125; &#125; public void unlock() &#123; Thread currentThread = Thread.currentThread(); // 只有锁的拥有者才能释放锁，只有上锁的线程获取到的currentThread，才能和内存中的currentThread相等 owner.compareAndSet(currentThread, null); &#125;&#125; 使用AtomicReference保存当前获取到锁的线程，保证了compareAndSet操作的原子性，关于CAS请参考——Java中CAS学习记录 缺点 非公平锁，并不能保证线程获取锁的顺序。 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重。 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。 二. CLH锁CLH锁:Craig, Landin, and Hagersten (好吧，这是三个人的名字)，它是基于链表实现的自旋锁，它不断的轮询前驱的状态，如果前驱释放锁，它就结束自旋转。 实现CLH锁实现如下： 线程持有自己的node变量，node中有一个locked属性，true代表需要锁，false代表不需要锁。 线程持有前驱的node引用，轮询前驱node的locked属性，true的时候自旋，false的时候代表前驱释放了锁，结束自旋。 tail始终指向最后加入的线程。 运行原理其运行用下图做一个说明： 初始化的时候tail指向一个类似head的节点，此时node的locked属性为false，preNode为空。 当线程A进来的时候，线程A持有的node节点，node的locked属性为true，preNode指向之前的head节点。 当线程B进来的时候，线程B持有的node节点，node的locked属性为true，preNode指向线程A的node节点，线程B的node节点locked属性为true，线程A轮询线程B的node节点的locked状态，为true自旋。 线程A执行完后释放锁（修改locked属性为false），线程B轮询到线程A的node节点locked属性为false，结束自旋。 代码实现CLH自旋锁代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package io.github.brightloong.concurrent.lock;import java.util.concurrent.atomic.AtomicReference;/** * Created by BrightLoong on 2018/6/13. * CLH自旋锁，前驱自旋 */public class CLHLock &#123; //指向最后加入的线程 AtomicReference&lt;Node&gt; tail = new AtomicReference&lt;Node&gt;(); //当前线程持有的节点,使用ThreadLocal实现了变量的线程隔离 ThreadLocal&lt;Node&gt; node; //前驱节点，使用ThreadLocal实现了变量的线程隔离 ThreadLocal&lt;Node&gt; preNode = new ThreadLocal&lt;Node&gt;(); public CLHLock() &#123; //初始化node node = new ThreadLocal&lt;Node&gt;() &#123; //线程默认变量的值,如果不Override这个函数，默认值为null @Override protected Node initialValue() &#123; return new Node(); &#125; &#125;; //初始化tail，指向一个node，类似一个head节点，并且该节点locked属性为false tail.set(new Node()); &#125; public void lock() &#123; //因为上面提到的构造函数中initialValue()方法，所以每个线程会有一个默认的值 //并且node的locked属性为false. Node myNode = node.get(); //修改为true，表示需要获取锁 myNode.locked = true; //获取这之前最后加入的线程，并把当前加入的线程设置为tail， // AtomicReference的getAndSet操作是原子性的 Node preNode = tail.getAndSet(myNode); //设置当前节点的前驱节点 this.preNode.set(preNode); //轮询前驱节点的locked属性，尝试获取锁 while (preNode.locked) &#123; &#125; &#125; public void unlock() &#123; //解锁很简单，将节点locked属性设置为false， //这样轮询该节点的另一个线程可以获取到释放的锁 node.get().locked = false; //当前节点设置为前驱节点，也就是上面初始化提到的head节点 node.set(preNode.get()); &#125; private class Node&#123; //默认不需要锁 private boolean locked = false; &#125;&#125; Node中只有一个locked属性，默认false ThreadLocal node,当前线程的节点，ThreadLocal实现了变量的线程隔离，关于ThreadLocal可以参考——ThreadLocal源码分析 ThreadLocal preNode,前驱节点 优点 是公平锁，FIFO CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n） 缺点介绍缺点前先说一下NUMA和SMP两种处理器结构SMP(Symmetric Multi-Processor)，即对称多处理器结构，指服务器中多个CPU对称工作，每个CPU访问内存地址所需时间相同。其主要特征是共享，包含对CPU，内存，I/O等进行共享。SMP的优点是能够保证内存一致性，缺点是这些共享的资源很可能成为性能瓶颈，随着CPU数量的增加，每个CPU都要访问相同的内存资源，可能导致内存访问冲突，可能会导致CPU资源的浪费。常用的PC机就属于这种。 NUMA(Non-Uniform Memory Access)非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存(系统内其它节点的内存)的速度，这也是非一致存储访问NUMA的由来。NUMA优点是可以较好地解决原来SMP系统的扩展问题，缺点是由于访问远地内存的延时远远超过本地内存，因此当CPU数量增加时，系统性能无法线性增加。 现在说CLH锁的缺点是在NUMA系统结构下性能很差，在这种系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣。 另一种实现CLH自旋锁在网上还有一种使用AtomicReferenceFieldUpdater实现的版本，这里也把代码贴出来，个人认为这种版本相比较上面的那种实现更难理解，在代码中添加了一些注释帮助理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package io.github.brightloong.concurrent.lock;import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;/** * Created by BrightLoong on 2018/6/17. */public class CLHLock2 &#123; public static class CLHNode &#123; // 默认是在等待锁 private boolean isLocked = true; &#125; //tail指向最后加入的线程node private volatile CLHNode tail ; //AtomicReferenceFieldUpdater基于反射的实用工具，可以对指定类的指定 volatile 字段进行原子更新。 //对CLHLock2类的tail字段进行原子更新。 private static final AtomicReferenceFieldUpdater&lt;CLHLock2, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater . newUpdater(CLHLock2.class, CLHNode .class , "tail" ); /** * 将node通过参数传入，其实和threadLocal类似，每个线程依然持有了自己的node变量 * @param currentThread */ public void lock(CLHNode currentThread) &#123; //将tail更新成当前线程node，并且返回前一个节点（也就是前驱节点） CLHNode preNode = UPDATER.getAndSet( this, currentThread); //如果preNode为空，表示当前没有线程获取锁，直接执行。 if(preNode != null) &#123; //轮询前驱状态 while(preNode.isLocked ) &#123; &#125; &#125; &#125; public void unlock(CLHNode currentThread) &#123; //compareAndSet,如果当前tail里面和currentThread相等，设置成功返回true， // 表示之后没有线程等待锁，因为tail就是指向当前线程的node。 // 如果返回false，表示还有其他线程等待锁，则更新isLocked属性为false if (!UPDATER .compareAndSet(this, currentThread, null)) &#123; currentThread. isLocked = false ;// 改变状态，让后续线程结束自旋 &#125; &#125;&#125; MCS锁MCS锁可以解决上面的CLH锁的缺点，MCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。 MCS Spinlock 是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，直接前驱负责通知其结束自旋（与CLH自旋锁不同的地方，不在轮询前驱的状态，而是由前驱主动通知），从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。 原理 每个线程持有一个自己的node，node有一个locked属性,true表示等待获取锁，false表示可以获取到锁，并且持有下一个node（后继者）的引用（可能存在） 线程在轮询自己node的locked状态，true表示锁被其他线程暂用，等待获取锁，自旋。 线程释放锁的时候，修改后继者（nextNode）的locked属性，通知后继者结束自旋。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package io.github.brightloong.concurrent.lock;import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;/** * Created by BrightLoong on 2018/6/17. */public class MCSLock &#123; public static class MCSNode &#123; //持有后继者的引用 MCSNode next; // 默认是在等待锁 boolean locked = true; &#125; volatile MCSNode tail;// 指向最后一个申请锁的MCSNode private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater .newUpdater(MCSLock.class, MCSNode.class, "tail"); public void lock(MCSNode currentThreadMcsNode) &#123; //更新tial为最新加入的线程节点，并取出之前的节点（也就是前驱） MCSNode predecessor = UPDATER.getAndSet(this, currentThreadMcsNode);//step4 //前驱为空表示没有线程占用锁 if (predecessor != null) &#123; //将当前节点设置为前驱节点的后继者 predecessor.next = currentThreadMcsNode;//step5 //轮询自己的isLocked属性 while (currentThreadMcsNode.locked) &#123; &#125; &#125; &#125; public void unlock(MCSNode currentThreadMcsNode) &#123; //UPDATER.get(this) 获取最后加入的线程的node //如果获取到的最后加入的node和当前node（currentThreadMcsNode）不相同，表示还有其他线程等待锁，直接修改后继者的isLocked属性。 //相同代表当前没其他有线程等待锁，进入下面的处理 if (UPDATER.get(this) == currentThreadMcsNode) &#123;//step1 //这个时候可能会有其他线程又加入了进来，检查时候有人排在自己后面，currentThreadMcsNode.next 表示依然没有染排在自己后面 if (currentThreadMcsNode.next == null) &#123; //step2 //将tail设置为空，如果返回true设置成功，如果返回false，表示设置失败（其他线程加入了进来，使得当前tail持有的节点不等于currentThreadMcsNode） if (UPDATER.compareAndSet(this, currentThreadMcsNode, null)) &#123;// //step3 // 设置成功返回，没有其他线程等待锁 return; &#125; else &#123; // 突然有其他线程加入，需要检测后继者是否有值，因为：step4执行完后，step5可能还没执行完 while (currentThreadMcsNode.next == null) &#123; &#125; &#125; &#125; //修改后继者的isLocked,通知后继者结束自旋 currentThreadMcsNode.next.locked = false; currentThreadMcsNode.next = null;// for GC &#125; &#125;&#125; 和CLH锁类似的，我自己用ThreadLocal保存node，而不通过函数传参的方式实现了一个MCS锁，代码如下(大概测试了下没问题，如果有问题希望指出，感谢)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package io.github.brightloong.concurrent.lock;import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;/** * Created by BrightLoong on 2018/6/17. */public class MCSLock2 &#123; private class MCSNode &#123; boolean locked = true; //后继节点 MCSNode next; &#125; volatile MCSNode tail; //AtomicReferenceFieldUpdater来保证tail原子更新 private static final AtomicReferenceFieldUpdater&lt;MCSLock2, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater .newUpdater(MCSLock2.class, MCSNode.class, "tail"); //当前线程持有的节点,使用ThreadLocal实现了变量的线程隔离 ThreadLocal&lt;MCSNode&gt; node = new ThreadLocal&lt;MCSNode&gt;()&#123; @Override protected MCSNode initialValue() &#123; return new MCSNode(); &#125; &#125;; public void lock() &#123; MCSNode myNode = node.get(); MCSNode preNode = UPDATER.getAndSet(this, myNode); //类似的，preNode == null从tail中没获取到值标志没有线程占用锁 if (preNode != null) &#123; preNode.next = myNode; //step1 //在自己node的locked变量自旋 while (myNode.locked) &#123; &#125; &#125; &#125; public void unlock() &#123; MCSNode myNode = node.get(); MCSNode next = myNode.next; //如果有后继者，直接设置next.locked = false通知后继者结束自旋. //如果有执行下面操作 if (next == null) &#123; //设置成功表示设置期间也没有后继者加入，设置失败表示有后继者加入 if (UPDATER.compareAndSet(this, myNode, null)) &#123; return; &#125; else &#123; //同样的需要等待lock()中step1完成 while (next == null) &#123; &#125; &#125; &#125; next.locked = false; next = null; //for CG &#125;&#125; 参考 https://www.cnblogs.com/tonylovett/p/5254765.html http://www.360doc.com/content/14/0811/22/1073512_401149458.shtml]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——享元模式]]></title>
    <url>%2F2018%2F06%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一.概述享元模式（Flyweight Pattern） ,运用共享技术有效的支持大量的细粒度对象。换句话说，使用享元模式对相同或者类似的对象进行复用，以此来减少少相同或者类似的对象的创建数量，从而减少内存占用，提高性能。 享元模式属于结构型模式。 在具体了解前先介绍两个名词： 内部状态：对象内部共享的内容，不随环境的改变而改变。 外部状态：相对内部状态，不可以被共享，而且会随环境改变而变化的状态就是外部状态。 有些时候又把享元模式分成单纯的享元模式和复合享元模式，下面分别介绍。 二.单纯享元模式单纯享元模式，也就是说所有的具体享元类都是可以被共享的，不存在不可以共享的具体享元类。 1. UML类图解析单纯享元模式的UML类图如下： FlyWeight:享元类的接口，接口中operation方法中的extrinsicState为外部状态。 ConcreteFlyWeight:具体的享元类，实现接口FlyWeight,存储内部状态intrinsicState。 FlyWeightFactory:享元工厂，用来创建和管理享元对象，其主要思想就是用一个Map来保存已经创建的对象实例。它主要是用来确保合理的共享FlyWeight对象，当用户请求一个FlyWeight对象时（getFlyWeight()方法），工厂提供一个已经存在的FlyWeight实例，如果不存在则创建一个返回。 享元工厂最好使用单例模式实现。 2. 代码实现享元类接口——FlyWeight123456789101112131415package io.github.brightloong.lab.design.flyweight;/** * FlyWeight class * 定义享元类接口 * @author BrightLoong * @date 2018/6/11 */public interface FlyWeight &#123; /** * 操作方法. * @param extrinsicState 外部状态 */ public void operation(String extrinsicState);&#125; 具体享元实现——ConcreteFlyWeight123456789101112131415161718192021222324252627package io.github.brightloong.lab.design.flyweight;/** * ConcreteFlyWeight class * * @author BrightLoong * @date 2018/6/11 */public class ConcreteFlyWeight implements FlyWeight &#123; /**内部状态*/ private String intrinsicState; /** * 构造方法，并设置内部状态. * @param intrinsicState */ public ConcreteFlyWeight(String intrinsicState) &#123; this.intrinsicState = intrinsicState; &#125; @Override public void operation(String extrinsicState) &#123; System.out.println("内部状态：" + intrinsicState); System.out.println("外部状态：" + extrinsicState); &#125;&#125; 享元工厂——FlyWeightFactory12345678910111213141516171819202122232425262728293031323334353637383940414243444546package io.github.brightloong.lab.design.flyweight;import java.util.HashMap;import java.util.Map;/** * FlyWeightFactory class * 用于创建和管理享元对象，本身是单例的。 * @author BrightLoong * @date 2018/6/11 */public class FlyWeightFactory &#123; /**唯一的factory实例*/ private static FlyWeightFactory factory = new FlyWeightFactory(); /**用于保存享元对象的map*/ private Map&lt;String, FlyWeight&gt; flyWeights = new HashMap&lt;&gt;(); /** * 私有的构造函数 */ private FlyWeightFactory() &#123;&#125; /** * 返回FlyWeightFactory唯一实例. * @return */ public static FlyWeightFactory getInstance() &#123; return factory; &#125; /** * 单纯享元模式工厂方法. * @param state key * @return */ public FlyWeight getFlyWeight(String state) &#123; FlyWeight flyWeight = flyWeights.get(state); if (flyWeight == null) &#123; flyWeight = new ConcreteFlyWeight(state); flyWeights.put(state, flyWeight); &#125; return flyWeight; &#125;&#125; 客户端调用和输出123456789101112131415161718192021222324package io.github.brightloong.lab.design.flyweight;/** * Client class * * @author BrightLoong * @date 2018/6/11 */public class Client &#123; public static void main(String[] args) &#123; FlyWeightFactory factory = FlyWeightFactory.getInstance(); FlyWeight flyWeight1 = factory.getFlyWeight("a"); FlyWeight flyWeight2 = factory.getFlyWeight("b"); FlyWeight flyWeight3 = factory.getFlyWeight("a"); FlyWeight flyWeight4 = factory.getFlyWeight("c"); //flyWeight1和flyWeight3具有相同的内部状态a,使用同一个实例，下面结果输出true System.out.println(flyWeight1 == flyWeight3); //不同的外部状态从方法传入 flyWeight2.operation("hello"); flyWeight2.operation("hi"); &#125;&#125; 输出结果如下：12345true内部状态：b外部状态：hello内部状态：b外部状态：hi 三. 复合享元模式复合享元模式，将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。 复合享元模式中，组成复合享元对象的每个单纯享元对象拥有自己的内部状态，而每个单纯享元对象的外部状态都和复合享元对象的外部状态相同。所以复合享元模式可以对多个单纯享元对象设置相同的外部状态， 这也是复合享元模式的应用场景。 1. UML类图解析复合享元模式的UML类图如下： FlyWeight:享元类的接口，接口中operation方法中的extrinsicState为外部状态,是单纯享元类和复合享元类的共同接口。 ConcreteFlyWeight:具体的享元类，实现接口FlyWeight,存储内部状态intrinsicState。 CompositeConcreteFlyweight：复合享元类，实现FlyWeight接口，同时使用Map来保存单纯享元对象，并提供add()和remove()方法来增加或者删除单纯享元对象。 FlyWeightFactory:享元工厂，用来创建和管理享元对象，其主要思想就是用一个Map来保存已经创建的对象实例。它主要是用来确保合理的共享FlyWeight对象。 getFlyWeight(state:String):单纯享元工厂方法，当用户请求一个FlyWeight对象时，工厂提供一个已经存在的FlyWeight实例，如果不存在则创建一个返回(直接返回单纯享元对象)。 getFlyWeight(states:List):复合享元工厂方法，根据提供的states:List，使用add()方法，将每个state对应的单纯享元对象添加到复合享元对象（CompositeConcreteFlyweight）的flyWeights中，并且这些单纯享元对象是从FlyWeightFactory的flyWeights中获取的（如果不存在则添加并返回），因此这些单纯享元对象是可以共享的。 2. 代码实现接口和单纯享元类的代码在上面已经列出了，下面是其他相关代码。 复合享元类——CompositeConcreteFlyweight12345678910111213141516171819202122232425262728293031323334353637383940414243package io.github.brightloong.lab.design.flyweight;import java.util.HashMap;import java.util.Map;/** * CompositeConcreteFlyweight class * * @author BrightLoong * @date 2018/6/11 */public class CompositeConcreteFlyweight implements FlyWeight &#123; Map&lt;String, FlyWeight&gt; flyWeights = new HashMap&lt;&gt;(); /** * flyWeights是单纯享元对象的集合，它们具有相同的外部状态extrinsicState， * 调用的时候使用循环调用单纯享元对象的operation方法 * @param extrinsicState 外部状态 */ @Override public void operation(String extrinsicState) &#123; for (Map.Entry&lt;String, FlyWeight&gt; entry : flyWeights.entrySet()) &#123; entry.getValue().operation(extrinsicState); &#125; &#125; /** * 添加单纯享元对象. * @param state * @param flyWeight */ public void add(String state, FlyWeight flyWeight) &#123; flyWeights.put(state, flyWeight); &#125; /** * 移除单纯享元对象. * @param state */ private void remove(String state) &#123; flyWeights.remove(state); &#125;&#125; 修改后的享元工厂——FlyWeightFactory1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package io.github.brightloong.lab.design.flyweight;import java.util.HashMap;import java.util.List;import java.util.Map;/** * FlyWeightFactory class * 用于创建和管理享元对象，本身是单例的。 * @author BrightLoong * @date 2018/6/11 */public class FlyWeightFactory &#123; /**唯一的factory实例*/ private static FlyWeightFactory factory = new FlyWeightFactory(); /**用于保存享元对象的map*/ private Map&lt;String, FlyWeight&gt; flyWeights = new HashMap&lt;&gt;(); /** * 私有的构造函数 */ private FlyWeightFactory() &#123;&#125; /** * 返回FlyWeightFactory唯一实例. * @return */ public static FlyWeightFactory getInstance() &#123; return factory; &#125; /** * 单纯享元模式工厂方法. * @param state key * @return */ public FlyWeight getFlyWeight(String state) &#123; FlyWeight flyWeight = flyWeights.get(state); if (flyWeight == null) &#123; flyWeight = new ConcreteFlyWeight(state); flyWeights.put(state, flyWeight); &#125; return flyWeight; &#125; /** * 复合享元模式工厂方法. * @param states * @return */ public FlyWeight getFlyWeight(List&lt;String&gt; states) &#123; CompositeConcreteFlyweight flyWeight = new CompositeConcreteFlyweight(); for (String state : states) &#123; //调用了单纯享元模式工厂方法,所以使用flyWeight.add加入的单纯享元对象是可以共享的 flyWeight.add(state, this.getFlyWeight(state)); &#125; return flyWeight; &#125;&#125; 客户端调用和输出123456789101112131415161718192021222324252627package io.github.brightloong.lab.design.flyweight;import java.util.ArrayList;import java.util.List;/** * Client2 class * * @author BrightLoong * @date 2018/6/11 */public class Client2 &#123; public static void main(String[] args) &#123; FlyWeightFactory factory = FlyWeightFactory.getInstance(); List&lt;String&gt; states = new ArrayList&lt;&gt;(); states.add("a"); states.add("b"); states.add("c"); FlyWeight flyWeight = factory.getFlyWeight(states); FlyWeight flyWeight2 = factory.getFlyWeight(states); //并不相等，输出false，复合享元对象不可共享 System.out.println(flyWeight == flyWeight2); //多个单纯享元对象具有相同的外部状态hello flyWeight.operation("hello"); &#125;&#125; 输出结果如下：1234567false内部状态：a外部状态：hello内部状态：b外部状态：hello内部状态：c外部状态：hello 四. 总结使用场景 系统中有大量相同或者相似的对象，因此而造成了系统存储开销。 对象的大多数状态是外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。也就是说可以将外部状态使用传入对象的方式来处理。 优点 实现了对象的共享 使用享元模式减少对象的创建，减少了对内存的使用。 缺点 使用享元模式，需要分离出内部状态和外部状态，使得系统更加复杂。 多说一句Java中String就是对享元模式的应用，如下代码会输出true。 123String a = "Hello Word";String b = "Hello Word";System.out.println(a == b);]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中CAS学习记录]]></title>
    <url>%2F2018%2F06%2F10%2FJava%E4%B8%ADCAS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[CAS在网上已经有数不清的文章，这里只是自己在学习过程中的一个记录，方便以后查阅。 一. 概述Java中CAS全称Compare and Swap，也就是比较交换。在Java同步工具中，经常可以看到CAS的身影。在Doug Lea大神提供的J.U.C并发包中，可以说CAS是实现整个J.U.C包的基石。 在CAS方法中，有三个操作数，当前的内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相等时，将内存值V修改为B，否则什么都不做。 因为CAS会在进行修改的时候对当前内存值进行检测，所以当有其他线程修改了变量值的时候，这个时候当前线程的修改就会失败，以此来保证了“读-修改-写”操作的原子性。 三. CAS使用先来看下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package io.github.brightloong.lab.concurrent.cas;import java.util.concurrent.TimeUnit;/** * NoUseCAS class * * @author BrightLoong * @date 2018/6/10 */public class NoUseCAS &#123; private volatile int value = 0; public void add() &#123; value++; &#125; public int getValue() &#123; return value; &#125; public static void main(String[] args) &#123; NoUseCAS noUseCAS = new NoUseCAS(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; TimeUnit.MILLISECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; noUseCAS.add(); &#125; &#125;).start(); &#125; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("最后结果：" + noUseCAS.getValue()); &#125;&#125; 输出结果每次都可能不一样，而不是每次都输出10。通过volatile虽然保证了变量线程之间的可见性，但是并不能保证“++”操作的原子性，因为“++”操作是先获取到值，然后再执行“+”操作，找到NoUseCAS.class文件，执行javap -c NoUseCAS.class 得到字节码，找到“add()”方法的字节码如下： 123456789public void add(); Code: 0: aload_0 1: dup 2: getfield #2 // Field value:I 5: iconst_1 6: iadd 7: putfield #2 // Field value:I 10: return 可以看到getfield获取当前的值，iadd执行加操作，putfield赋值，如果这个时候线程A在执行完getfield后，拿到值为2，同时有另一个线程B将值修改为3，这个时候线程A继续执行操作的话最后会返回结果3，这就和期望的值不一样了。 如何解决可以使用AtomicInteger来解决上面的问题，它提供了getAndIncrement()方法来替代“++”操作，并且保证了该操作的原子性， 代码片段： 12345678910111213141516171819202122232425public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; //变量内存偏移地址 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; //使用volatile修饰保证线程间的可见性。 private volatile int value; //原子++操作，并调用unsafe.getAndAddInt public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125;&#125; Unsafe.java中相关代码片段如下： 1234567891011//使用了compareAndSwapInt()public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125;//调用本地方法（native）public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 下面具体分析本地方法 三. CAS原理在openjdk9中找到unsafe.cpp，其路径为：jdk9u/hotspot/src/share/vm/prims/unsafe.cpp12345678910//定义compareAndSetInt为Unsafe_CompareAndSetInt&#123;CC &quot;compareAndSetInt&quot;, CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;, FN_PTR(Unsafe_CompareAndSetInt)&#125;,UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) &#123; oop p = JNIHandles::resolve(obj); //获取内存地址 jint* addr = (jint *)index_oop_from_field_offset_long(p, offset); return (jint)(Atomic::cmpxchg(x, addr, e)) == e;&#125; UNSAFE_END Atomic::cmpxchg在atomic.hpp中，文件路径为：jdk9u/hotspot/src/share/vm/runtime/atomic.hpp1234567inline unsigned Atomic::cmpxchg(unsigned int exchange_value, volatile unsigned int* dest, unsigned int compare_value, cmpxchg_memory_order order) &#123; assert(sizeof(unsigned int) == sizeof(jint), &quot;more work to do&quot;); return (unsigned int)Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest, (jint)compare_value, order);&#125; 使用的是内联函数（inline）,会根据当前处理器的类型调用对应的内联函数，以下是windows_x86的实现。文件路径为：jdk9u/hotspot/src/os_cpu/windows_x86/vm/atomic_windows_x86.hpp1234567891011inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value, cmpxchg_memory_order order) &#123; // alternative for InterlockedCompareExchange int mp = os::is_MP(); __asm &#123; mov edx, dest mov ecx, exchange_value mov eax, compare_value LOCK_IF_MP(mp) cmpxchg dword ptr [edx], ecx &#125;&#125; LOCK_IF_MP(MP):判断前系统是否为多核处理器如果是则为cmpxchg指令添加lock前缀。 cmpxchg：使用cmpxchg指令 intel手册对lock前缀的说明如下(参考：https://www.jianshu.com/p/fb6e91b013cc)： 确保后续指令执行的原子性。 在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存，很显然，这个开销很大。在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销。 禁止该指令与前面和后面的读写指令重排序。 把写缓冲区的所有数据刷新到内存中。 CAS的ABA问题CAS存在ABA的问题，如下图所示，线程A最开始获取的值A，到赋值前检查的时候依然是A，然后进行了赋值；但是线程A并不知道这期间有线程B将值更改为B，然后又有线程C将值改回A。我们可以使用版本号来解决以上的问题，也就是上面的修改就会变成1A-1B-2A,就可以发现最开始是1A，但是比较的时候是2A，代表这期间被改动过。可以使用AtomicStampedReference解决ABA的问题，它就是使用版本号来标记变量来保证CAS的正确性。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——适配器模式]]></title>
    <url>%2F2018%2F06%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 概述适配器模式（Adapter） ，将一个类的接口转换为客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那个类可以一起工作。 关于适配器，现实生活中也有很多例子，比如电源适配器，中国家庭供电为220V，而手机一般需求是在5V，这里220V就是不兼容的那个类，但我们又需要其供电，我们用电源适配器将其转为5V，使手机能正常充电。还有各种转接头（HDMI转接头，type-c转接头等），顺便说一下，Java中的IO中可以看到适配器模式的使用。 适配器模式属于结构型模式 二. UML类图解析在GoF的设计模式中，适配器模式讲了两种类型——类适配器模式和对象适配器模式。由于类适配器模式需要继承被适配的类，同时有可能需要继承目标类，而Java又不支持多重继承，所以平时常用的是对象适配器模式。下面也会对类适配器模式进行简单的介绍。 对象适配器模式 Client：客户端。 Target：目标接口，客户端所期待的目标接口（可以是具体的或抽象的类，也可以是接口）。 Adapter：适配器，实现目标接口，通过在内部持有一个Adaptee引用，把源接口（Adaptee）转成目标接口（Target）。 Adaptee：需要适配的类。 类适配器模式 基本和对象适配器模式相同，唯一不同的是适配器（Adapter）不在持有Adaptee的引用，而采用继承Adaptee的方式，实现把源接口（Adaptee）转成目标接口（Target）。 三. 代码实现就基于上面的电源适配器场景来进行代码实现。目标接口——MobileCharge（需要5V电流），需要被适配的22V电源——Power220V，电源适配器——PowerAdapter 目标接口——MobileCharge123456789package io.github.brightloong.design.adapter;/** * 充电接口 * Created by BrightLoong on 2018/6/6. */public interface MobileCharge &#123; public void outPut5V();&#125; 需要被适配的22V电源——Power220V1234567891011package io.github.brightloong.design.adapter;/** * 需要被适配的类 * Created by BrightLoong on 2018/6/6. */public class Power220V &#123; public void outPut220V() &#123; System.out.println("输出220V电流"); &#125;&#125; 电源适配器——PowerAdapter(对象适配器模式)123456789101112131415161718192021package io.github.brightloong.design.adapter;/** * 对象适配器 * Created by BrightLoong on 2018/6/6. */public class PowerAdapter implements MobileCharge &#123; //需要适配的220V电源 private Power220V power220V; public PowerAdapter(Power220V power220V) &#123; this.power220V = power220V; &#125; public void outPut5V() &#123; power220V.outPut220V(); System.out.println("电源适配器转换"); System.out.println("输出5V电流"); &#125;&#125; 使用类适配模式的电源适配器——PowerAdapter212345678910111213package io.github.brightloong.design.adapter;/** * 类适配器，使用继承的方式 * Created by BrightLoong on 2018/6/6. */public class PowerAdapter2 extends Power220V implements MobileCharge &#123; public void outPut5V() &#123; super.outPut220V(); System.out.println("电源适配器转换"); System.out.println("输出5V电流"); &#125;&#125; 客户端调用和输出12345678910111213141516package io.github.brightloong.design.adapter;/** * Created by BrightLoong on 2018/6/6. */public class Client &#123; public static void main(String[] args) &#123; MobileCharge mobileCharge = new PowerAdapter(new Power220V()); System.out.println("手机充电"); mobileCharge.outPut5V(); System.out.println("-------------------"); //类适配器模式 MobileCharge mobileCharge2 = new PowerAdapter2(); mobileCharge2.outPut5V(); &#125;&#125; 输出结果： 12345678手机充电输出220V电流电源适配器转换输出5V电流-------------------输出220V电流电源适配器转换输出5V电流 四. 总结使用场景 注意：适配器模式是更多的为了解决已有的在运行的项目中的问题，而不是解决开发阶段的项目，开发阶段的项目应该进行良好的设计。 系统的数据和行为都正确，但接口不符时。 希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。 想使用一个已经存在的类，但是它的接口，也就是它的方法和你的要求不同时。 优点 因为适配器模式可以让不满足要求的类满足要求，所以提高了类的复用。 使目标类和适配者类解耦，增加了类的透明性，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。 具有较强的灵活性和扩展性，可以很方便的增加适配器。 缺点 一次最多只能适配一个适配者类，不能同时适配多个适配者。 （类适配器存在的问题，因为不能多重继承，考虑使用对象适配器，持有多个适配者） 目标抽象类只能为接口，不能为类，其使用有一定的局限性。(类适配器存在的问题，因为不能多重继承，如果是类，考虑继承而不是实现) 对象适配器]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal源码解析]]></title>
    <url>%2F2018%2F05%2F28%2FThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一. 简介提醒篇幅较大需耐心。 简介来自ThreadLocal类注释 ThreadLocal类提供了线程局部 (thread-local) 变量。这些变量与普通变量不同，每个线程都可以通过其 get 或 set方法来访问自己的独立初始化的变量副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。 下面是类注释中给出的一个列子： 以下类生成对每个线程唯一的局部标识符。 线程 ID 是在第一次调用 UniqueThreadIdGenerator.getCurrentThreadId() 时分配的，在后续调用中不会更改。 1234567891011121314151617181920212223242526272829import java.util.concurrent.atomic.AtomicInteger; public class ThreadId &#123; // Atomic integer containing the next thread ID to be assigned private static final AtomicInteger nextId = new AtomicInteger(0); // Thread local variable containing each thread's ID private static final ThreadLocal&lt;Integer&gt; threadId = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return nextId.getAndIncrement(); &#125; &#125;; // Returns the current thread's unique ID, assigning it if necessary public static int get() &#123; return threadId.get(); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.print(threadId.get()); &#125; &#125;).start(); &#125; &#125;&#125; 输出结果 ：01234 只要线程是活动的并且 ThreadLocal 实例是可访问的，每个线程都会保持对其线程局部变量副本的隐式引用；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）。 二. 整体认识UML类图 ThreadLocal中的嵌套内部类ThreadLocalMap，这个类本质上是一个map，和HashMap之类的实现相似，依然是key-value的形式，其中有一个内部类Entry，其中key可以看做是ThreadLocal实例，但是其本质是持有ThreadLocal实例的弱引用（之后会详细说到）。 还是说ThreadLocalMap（下面是很大篇幅的阅读其源码，毕竟了解清楚了ThreadLocalMap的来龙去脉，ThreadLocal基本也就差不多了），在ThreadLocal中并没有对于ThreadLocalMap的引用，是的，ThreadLocalMap的引用在Thread类中，代码如下。每个线程在向ThreadLocal里塞值的时候，其实都是向自己所持有的ThreadLocalMap里塞入数据；读的时候同理，首先从自己线程中取出自己持有的ThreadLocalMap，然后再根据ThreadLocal引用作为key取出value，基于以上描述，ThreadLocal实现了变量的线程隔离（当然，毕竟变量其实都是从自己当前线程实例中取出来的）。 123456789publicclass Thread implements Runnable &#123; ...... /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; ...... 原理图根据理解，画出ThreadLocal原理图如下： 首先，主线程定义的两个ThreadLocal变量，和两个子线程——线程A和线程B。 线程A和线程B分别持有一个ThreadLocalMap用于保存自己独立的副本，主线程的ThreadLocal中封装了get()和set()之类的方法。 在线程A和线程B中调用ThreadLocal的set方法，会首先通过getMap(Thread.currentThread)获得线程A或者是线程B持有的ThreadLocalMap,在调用map.put()方法，并将ThreadLocal作为key。 get()方法和set()方法原理类似，也是先获取当前调用线程的ThreadLocalMap,再从map中获取value，并将ThreadLocal作为key。 三. ThreadLocalMap源码分析下面一步一步介绍ThreadLocalMap源码分析的相关源码，在分析ThreadLocalMap的同时，也会介绍与ThreadLocalMap关联的ThreadLocal中的方法（这样分析完ThreadLocalMap，ThreadLocal基本就搞定了），可能有些需要前后结合才能真正理解。 成员变量123456789101112131415161718192021222324252627/** * 初始容量 —— 必须是2的冥 */private static final int INITIAL_CAPACITY = 16;/** * 存放数据的table，Entry类的定义在下面分析 * 同样，数组长度必须是2的冥。 */private Entry[] table;/** * 数组里面entrys的个数，可以用于判断table当前使用量是否超过负因子。 */private int size = 0;/** * 进行扩容的阈值，表使用量大于它的时候进行扩容。 */private int threshold; // Default to 0/** * 定义为长度的2/3 */private void setThreshold(int len) &#123; threshold = len * 2 / 3;&#125; 各个值的含义已经在注释里面说了，就不再一一解释。 存储结构——Entry1234567891011121314/** * Entry继承WeakReference，并且用ThreadLocal作为key.如果key为null * (entry.get() == null)表示key不再被引用，表示ThreadLocal对象被回收 * 因此这时候entry也可以从table从清除。 */static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; Entry继承WeakReference,使用弱引用，可以将ThreadLocal对象的生命周期和线程生命周期解绑，持有对ThreadLocal的弱引用，可以使得ThreadLocal在没有其他强引用的时候被回收掉，这样可以避免因为线程得不到销毁导致ThreadLocal对象无法被回收。 关于WeakReference可以参考我之前的博客，关于Java中的WeakReferencea。 ThreadLocalMap的set()方法和Hash映射要了解ThreadLocalMap中Hash映射的方式，首先从ThreadLocal的set()方法入手，逐层深入。 ThreadLocal中的set()先看看ThreadLocal中set()源码。 12345678910111213141516public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocal.ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocal.ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocal.ThreadLocalMap(this, firstValue);&#125; 代码很简单，获取当前线程，并获取当前线程的ThreadLocalMap实例（从getMap(Thread t)中很容易看出来）。 如果获取到的map实例不为空，调用map.set()方法，否则调用构造函数 ThreadLocal.ThreadLocalMap(this, firstValue)实例化map。 可以看出来线程中的ThreadLocalMap使用的是延迟初始化，在第一次调用get()或者set()方法的时候才会进行初始化。下面来看看构造函数ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) 。 1234567891011ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; //初始化table table = new ThreadLocal.ThreadLocalMap.Entry[INITIAL_CAPACITY]; //计算索引 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); //设置值 table[i] = new ThreadLocal.ThreadLocalMap.Entry(firstKey, firstValue); size = 1; //设置阈值 setThreshold(INITIAL_CAPACITY);&#125; 主要说一下计算索引，firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)。 关于&amp; (INITIAL_CAPACITY - 1),这是取模的一种方式，对于2的幂作为模数取模，用此代替%(2^n)。至于为什么可以这样这里不过多解释，原理很简单。 关于firstKey.threadLocalHashCode： 123456789private final int threadLocalHashCode = nextHashCode();private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125;private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; 定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，HASH_INCREMENT = 0x61c88647,关于这个值和斐波那契散列有关，其原理这里不再深究，感兴趣可自行搜索，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中。 在了解了上面的源码后，终于能进入正题了，下面开始进入ThreadLocalMap中的set()。 ThreadLocalMap中的set()ThreadLocalMap使用线性探测法来解决哈希冲突，线性探测法的地址增量di = 1, 2, … , m-1，其中，i为探测次数。该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。假设当前table长度为16，也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15，取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0],以此类推，直到可以插入。 按照上面的描述，可以把table看成一个环形数组。 先看一下线性探测相关的代码，从中也可以看出来table实际是一个环： 1234567891011121314/**java /** * 获取环形数组的下一个索引 */ private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; /** * 获取环形数组的上一个索引 */ private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1); &#125; ThreadLocalMap的set()及其set()相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; //计算索引，上面已经有说过。 int i = key.threadLocalHashCode &amp; (len-1); /** * 根据获取到的索引进行循环，如果当前索引上的table[i]不为空，在没有return的情况下， * 就使用nextIndex()获取下一个（上面提到到线性探测法）。 */ for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); //table[i]上key不为空，并且和当前key相同，更新value if (k == key) &#123; e.value = value; return; &#125; /** * table[i]上的key为空，说明被回收了（上面的弱引用中提到过）。 * 这个时候说明改table[i]可以重新使用，用新的key-value将其替换,并删除其他无效的entry */ if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; //找到为空的插入位置，插入值，在为空的位置插入需要对size进行加1操作 tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value); int sz = ++size; /** * cleanSomeSlots用于清除那些e.get()==null，也就是table[index] != null &amp;&amp; table[index].get()==null * 之前提到过，这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。 * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行rehash() */ if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125;/** * 替换无效entry */private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; ThreadLocal.ThreadLocalMap.Entry e; /** * 根据传入的无效entry的位置（staleSlot）,向前扫描 * 一段连续的entry(这里的连续是指一段相邻的entry并且table[i] != null), * 直到找到一个无效entry，或者扫描完也没找到 */ int slotToExpunge = staleSlot;//之后用于清理的起点 for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; /** * 向后扫描一段连续的entry */ for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); /** * 如果找到了key，将其与传入的无效entry替换，也就是与table[staleSlot]进行替换 */ if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; //如果向前查找没有找到无效entry，则更新slotToExpunge为当前值i if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; /** * 如果向前查找没有找到无效entry，并且当前向后扫描的entry无效，则更新slotToExpunge为当前值i */ if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; /** * 如果没有找到key,也就是说key之前不存在table中 * 就直接最开始的无效entry——tab[staleSlot]上直接新增即可 */ tab[staleSlot].value = null; tab[staleSlot] = new ThreadLocal.ThreadLocalMap.Entry(key, value); /** * slotToExpunge != staleSlot,说明存在其他的无效entry需要进行清理。 */ if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125;/** * 连续段清除 * 根据传入的staleSlot,清理对应的无效entry——table[staleSlot], * 并且根据当前传入的staleSlot,向后扫描一段连续的entry(这里的连续是指一段相邻的entry并且table[i] != null), * 对可能存在hash冲突的entry进行rehash，并且清理遇到的无效entry. * * @param staleSlot key为null,需要无效entry所在的table中的索引 * @return 返回下一个为空的solt的索引。 */private int expungeStaleEntry(int staleSlot) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; // 清理无效entry，置空 tab[staleSlot].value = null; tab[staleSlot] = null; //size减1，置空后table的被使用量减1 size--; ThreadLocal.ThreadLocalMap.Entry e; int i; /** * 从staleSlot开始向后扫描一段连续的entry */ for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); //如果遇到key为null,表示无效entry，进行清理. if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; //如果key不为null,计算索引 int h = k.threadLocalHashCode &amp; (len - 1); /** * 计算出来的索引——h，与其现在所在位置的索引——i不一致，置空当前的table[i] * 从h开始向后线性探测到第一个空的slot，把当前的entry挪过去。 */ if (h != i) &#123; tab[i] = null; while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; //下一个为空的solt的索引。 return i;&#125;/** * 启发式的扫描清除，扫描次数由传入的参数n决定 * * @param i 从i向后开始扫描（不包括i，因为索引为i的Slot肯定为null） * * @param n 控制扫描次数，正常情况下为 log2(n) ， * 如果找到了无效entry，会将n重置为table的长度len,进行段清除。 * * map.set()点用的时候传入的是元素个数，replaceStaleEntry()调用的时候传入的是table的长度len * * @return true if any stale entries have been removed. */private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); ThreadLocal.ThreadLocalMap.Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; //重置n为len n = len; removed = true; //依然调用expungeStaleEntry来进行无效entry的清除 i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0);//无符号的右移动，可以用于控制扫描次数在log2(n) return removed;&#125;private void rehash() &#123; //全清理 expungeStaleEntries(); /** * threshold = 2/3 * len * 所以threshold - threshold / 4 = 1en/2 * 这里主要是因为上面做了一次全清理所以size减小，需要进行判断。 * 判断的时候把阈值调低了。 */ if (size &gt;= threshold - threshold / 4) resize();&#125;/** * 扩容，扩大为原来的2倍（这样保证了长度为2的冥） */private void resize() &#123; ThreadLocal.ThreadLocalMap.Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; ThreadLocal.ThreadLocalMap.Entry[] newTab = new ThreadLocal.ThreadLocalMap.Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; ThreadLocal.ThreadLocalMap.Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); //虽然做过一次清理，但在扩容的时候可能会又存在key==null的情况。 if (k == null) &#123; //这里试试将e.value设置为null e.value = null; // Help the GC &#125; else &#123; //同样适用线性探测来设置值。 int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; //设置新的阈值 setThreshold(newLen); size = count; table = newTab;&#125;/** * 全清理，清理所有无效entry */private void expungeStaleEntries() &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; ThreadLocal.ThreadLocalMap.Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) //使用连续段清理 expungeStaleEntry(j); &#125;&#125; ThreadLocalMap中的getEntry()及其相关同样的对于ThreadLocalMap中的getEntry()也从ThreadLocal的get()方法入手。 ThreadLocal中的get()1234567891011121314151617181920212223242526272829303132333435public T get() &#123; //同set方法类似获取对应线程中的ThreadLocalMap实例 Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; //为空返回初始化值 return setInitialValue();&#125;/** * 初始化设值的方法，可以被子类覆盖。 */protected T initialValue() &#123; return null;&#125;private T setInitialValue() &#123; //获取初始化值，默认为null(如果没有子类进行覆盖) T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //不为空不用再初始化，直接调用set操作设值 if (map != null) map.set(this, value); else //第一次初始化，createMap在上面介绍set()的时候有介绍过。 createMap(t, value); return value;&#125; ThreadLocalMap中的getEntry()12345678910111213141516171819202122232425262728293031private ThreadLocal.ThreadLocalMap.Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; //根据key计算索引，获取entry int i = key.threadLocalHashCode &amp; (table.length - 1); ThreadLocal.ThreadLocalMap.Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125;/** * 通过直接计算出来的key找不到对于的value的时候适用这个方法. */private ThreadLocal.ThreadLocalMap.Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, ThreadLocal.ThreadLocalMap.Entry e) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) //清除无效的entry expungeStaleEntry(i); else //基于线性探测法向后扫描 i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; ThreadLocalMap中的remove()123456789101112131415161718private void remove(ThreadLocal&lt;?&gt; key) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; //计算索引 int i = key.threadLocalHashCode &amp; (len-1); //进行线性探测，查找正确的key for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; //调用weakrefrence的clear()清除引用 e.clear(); //连续段清除 expungeStaleEntry(i); return; &#125; &#125;&#125; remove()在有上面了解后可以说极为简单了，就是找到对应的table[],调用weakrefrence的clear()清除引用，然后再调用expungeStaleEntry()进行清除。 四. 总结分析完ThreadLocalMap，ThreadLocal的神秘面纱也就揭开了，所以不再赘述。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ThreadLocal</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——观察者者模式]]></title>
    <url>%2F2018%2F05%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 概述观察者模式（Observer） ，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 观察者模式，不论实现方式如何，需要具备最基本的Subject(被观察的主题)、Observer(观察者)，最后就是试用它们的Client(客户端)。 观察者模式属于行为型模式。 二. UML类图解析 Subject：被观察的主题，可以是一个抽象类或者接口，它把所有对观察者对象的引用保存在一个集合里，每个主题都可以有任何数量的观察者。抽象主题提供增加和移除观察者对象的方法。 Observer：抽象观察者，可以是一个抽象类或者接口，定义了一个update方法，在得到主题的通知时进行更新。 ConcreteObserverA、ConcreteObserverB：具体的观察者，实现观察者接口。 ConcreteSubject：具体主题，继承Subject，保存主题相关的一些状态。 三. 代码实现打仗的时候，当哨兵观察到敌方来袭会通知所有士兵做好迎敌准备，士兵得到通知和进行准备。这里把哨兵通知当成一个主题，其他士兵（弓兵、骑兵、步兵等）在接到通知的时候作出相应的准备。 观察者接口——Soldier123456789package io.github.brightloong.design.observer;/** * Created by BrightLoong on 2018/5/27. */public interface Soldier &#123; //视具体情况，可以传入适当的参数，甚至可以单独定义一个消息类 void update();&#125; 抽象主题——Sentinel主题是使用抽象类还是接口根据情况而定。 1234567891011121314151617181920212223242526272829303132333435363738package io.github.brightloong.design.observer;import java.util.ArrayList;import java.util.List;/** * 哨兵,在有敌人入侵的时候通知其他士兵（弓兵、骑兵、步兵）准备迎战。 * Created by BrightLoong on 2018/5/27. */public abstract class Sentinel &#123; //持有的观察者集合 private List&lt;Soldier&gt; soldiers = new ArrayList&lt;Soldier&gt;(); /** * 添加观察者. * @param soldier */ public void addSoldier(Soldier soldier) &#123; soldiers.add(soldier); &#125; /** * 移除观察者. * @param soldier */ public void removeSoldier(Soldier soldier) &#123; soldiers.remove(soldier); &#125; /** * 通知所有观察者. */ public void notifySoldier() &#123; for (Soldier soldier : soldiers) &#123; soldier.update(); &#125; &#125;&#125; 具体主题——BraveSentinel12345678910111213141516171819202122232425262728package io.github.brightloong.design.observer;/** * Created by BrightLoong on 2018/5/27. */public class BraveSentinel extends Sentinel &#123; /**哨兵的名字*/ private String name; /**通知消息*/ private String msg; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 具体观察者弓兵 12345678910111213141516171819202122232425package io.github.brightloong.design.observer;/** * Created by BrightLoong on 2018/5/27. */public class Archer implements Soldier &#123; private BraveSentinel sentinel; /** * 构造函数，传入观察的主题，因为主题和观察者是一对多的情况， * 所以这里直接传入具体的BraveSentinel而不是Sentinel, * 当然，这个视具体情况而来 * @param sentinel */ public Archer(BraveSentinel sentinel) &#123; this.sentinel = sentinel; &#125; public void update() &#123; System.out.println("收到哨兵" + sentinel.getName() + "的通知：" + sentinel.getMsg()); System.out.println("弓兵布阵"); &#125;&#125; 骑兵 123456789101112131415161718package io.github.brightloong.design.observer;/** * 骑兵 * Created by BrightLoong on 2018/5/27. */public class Cavalry implements Soldier &#123; private BraveSentinel sentinel; public Cavalry(BraveSentinel sentinel) &#123; this.sentinel = sentinel; &#125; public void update() &#123; System.out.println("收到哨兵" + sentinel.getName() + "的通知：" + sentinel.getMsg()); System.out.println("骑兵上马布阵"); &#125;&#125; 客户端调用和输出12345678910111213141516package io.github.brightloong.design.observer;/** * Created by BrightLoong on 2018/5/27. */public class Client &#123; public static void main(String[] args) &#123; BraveSentinel sentinel = new BraveSentinel(); sentinel.addSoldier(new Archer(sentinel)); sentinel.addSoldier(new Cavalry(sentinel)); sentinel.setName("小二郎"); sentinel.setMsg("敌方十万大军来袭"); sentinel.notifySoldier(); &#125;&#125; 输出如下： 1234收到哨兵小二郎的通知：敌方十万大军来袭弓兵布阵收到哨兵小二郎的通知：敌方十万大军来袭骑兵上马布阵 四. 总结使用场景 当一个对象发生变化，同时其他对象需要因此而改变，并且它不知道具体有多少个对象会因此改变。 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 需要建立一个触发链 优点 实现了观察者和被观察者的解耦，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。 可以方便的增加新的观察者和主题，方便扩展。 缺点 观察者的增加会导致通知所花费时间。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java中的WeakReference]]></title>
    <url>%2F2018%2F05%2F27%2F%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84WeakReference%2F</url>
    <content type="text"><![CDATA[一. 简介在看ThreadLocal源码的时候，其中嵌套类ThreadLocalMap中的Entry继承了WeakReferenc，为了能搞清楚ThreadLocal，只能先了解下了WeakReferenc(是的，很多时候我了搞清楚一个东西，不得不往上追好几层，先搞清楚其所依赖的东西。) 下面进入正题，WeakReference如字面意思，弱引用， 当一个对象仅仅被weak reference（弱引用）指向, 而没有任何其他strong reference（强引用）指向的时候, 如果这时GC运行, 那么这个对象就会被回收，不论当前的内存空间是否足够，这个对象都会被回收。 二. 认识WeakReference类WeakReference继承Reference，其中只有两个构造函数： 12345678910public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public WeakReference(T referent) &#123; super(referent); &#125; public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125;&#125; WeakReference(T referent)：referent就是被弱引用的对象（注意区分弱引用对象和被弱引用的对应，弱引用对象是指WeakReference的实例或者其子类的实例），比如有一个Apple实例apple，可以如下使用，并且通过get()方法来获取apple引用。也可以再创建一个继承WeakReference的类来对Apple进行弱引用，下面就会使用这种方式。 12WeakReference&lt;Apple&gt; appleWeakReference = new WeakReference&lt;&gt;(apple);Apple apple2 = appleWeakReference.get(); WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)：与上面的构造方法比较，多了个ReferenceQueue，在对象被回收后，会把弱引用对象，也就是WeakReference对象或者其子类的对象，放入队列ReferenceQueue中，注意不是被弱引用的对象，被弱引用的对象已经被回收了。 三. 使用WeakReference下面是使用继承WeakReference的方式来使用软引用，并且不使用ReferenceQueue。 简单类Apple1234567891011121314151617181920212223242526272829303132333435363738394041package io.github.brightloong.lab.reference;/** * Apple class * * @author BrightLoong * @date 2018/5/25 */public class Apple &#123; private String name; public Apple(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; /** * 覆盖finalize，在回收的时候会执行。 * @throws Throwable */ @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("Apple： " + name + " finalize。"); &#125; @Override public String toString() &#123; return "Apple&#123;" + "name='" + name + '\'' + '&#125;' + ", hashCode:" + this.hashCode(); &#125;&#125; 继承WeakReference的Salad1234567891011121314151617package io.github.brightloong.lab.reference;import java.lang.ref.WeakReference;/** * Salad class * 继承WeakReference，将Apple作为弱引用。 * 注意到时候回收的是Apple，而不是Salad * * @author BrightLoong * @date 2018/5/25 */public class Salad extends WeakReference&lt;Apple&gt; &#123; public Salad(Apple apple) &#123; super(apple); &#125;&#125; Clent调用和输出1234567891011121314151617181920212223242526272829package io.github.brightloong.lab.reference;import java.lang.ref.WeakReference;/** * Main class * * @author BrightLoong * @date 2018/5/24 */public class Client &#123; public static void main(String[] args) &#123; Salad salad = new Salad(new Apple("红富士")); //通过WeakReference的get()方法获取Apple System.out.println("Apple:" + salad.get()); System.gc(); try &#123; //休眠一下，在运行的时候加上虚拟机参数-XX:+PrintGCDetails，输出gc信息，确定gc发生了。 Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //如果为空，代表被回收了 if (salad.get() == null) &#123; System.out.println("clear Apple。"); &#125; &#125;&#125; 输出如下： 12345Apple:Apple&#123;name=&apos;红富士&apos;&#125;, hashCode:1846274136[GC (System.gc()) [PSYoungGen: 3328K-&gt;496K(38400K)] 3328K-&gt;504K(125952K), 0.0035102 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (System.gc()) [PSYoungGen: 496K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;359K(87552K)] 504K-&gt;359K(125952K), [Metaspace: 2877K-&gt;2877K(1056768K)], 0.0067965 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Apple： 红富士 finalize。clear Apple。 ReferenceQueue的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package io.github.brightloong.lab.reference;import java.lang.ref.Reference;import java.lang.ref.ReferenceQueue;import java.lang.ref.WeakReference;/** * Client2 class * * @author BrightLoong * @date 2018/5/27 */public class Client2 &#123; public static void main(String[] args) &#123; ReferenceQueue&lt;Apple&gt; appleReferenceQueue = new ReferenceQueue&lt;&gt;(); WeakReference&lt;Apple&gt; appleWeakReference = new WeakReference&lt;Apple&gt;(new Apple("青苹果"), appleReferenceQueue); WeakReference&lt;Apple&gt; appleWeakReference2 = new WeakReference&lt;Apple&gt;(new Apple("毒苹果"), appleReferenceQueue); System.out.println("=====gc调用前====="); Reference&lt;? extends Apple&gt; reference = null; while ((reference = appleReferenceQueue.poll()) != null ) &#123; //不会输出，因为没有回收被弱引用的对象，并不会加入队列中 System.out.println(reference); &#125; System.out.println(appleWeakReference); System.out.println(appleWeakReference2); System.out.println(appleWeakReference.get()); System.out.println(appleWeakReference2.get()); System.out.println("=====调用gc====="); System.gc(); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("=====gc调用后====="); //下面两个输出为null,表示对象被回收了 System.out.println(appleWeakReference.get()); System.out.println(appleWeakReference2.get()); //输出结果，并且就是上面的appleWeakReference、appleWeakReference2，再次证明对象被回收了 Reference&lt;? extends Apple&gt; reference2 = null; while ((reference2 = appleReferenceQueue.poll()) != null ) &#123; //如果使用继承的方式就可以包含其他信息了 System.out.println("appleReferenceQueue中：" + reference2); &#125; &#125;&#125; 结果输出如下： 123456789101112131415=====gc调用前=====java.lang.ref.WeakReference@6e0be858java.lang.ref.WeakReference@61bbe9baApple&#123;name=&apos;青苹果&apos;&#125;, hashCode:1627674070Apple&#123;name=&apos;毒苹果&apos;&#125;, hashCode:1360875712=====调用gc=====Apple： 毒苹果 finalize。Apple： 青苹果 finalize。=====gc调用后=====nullnullappleReferenceQueue中：java.lang.ref.WeakReference@6e0be858appleReferenceQueue中：java.lang.ref.WeakReference@61bbe9baProcess finished with exit code 0 可以看到在队列中（ReferenceQueue），调用gc之前是没有内容的，调用gc之后，对象被回收了，并且弱引用对象appleWeakReference和appleWeakReference2被放入了队列中。 关于其他三种引用，强引用、软引用、虚引用，可以参考http://www.cnblogs.com/gudi/p/6403953.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——建造者模式]]></title>
    <url>%2F2018%2F05%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 概述建造者模式（Builder），又叫生成器模式，它将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，使用建造者模式，用户就只需指定需要建造的类型就可以得到它们，二具体建造的过程和细节就不需要知道了。 建造者模式相比于工厂模式更加关注组成部分的装配细节和顺序。 创建者模式属于创建型模式。 二. UML类图解析建造者模式的UML类图如下： Builder：为创建一个Product对象的各个部件指定的抽象接口，buildPart()是对象组成部分构造的抽象方法，根据需求可以有多个组成部分的构造方法。 ConcreteBuilder：具体建造者，继承自Builder，构造和装配各个部件，getResult()返回构造后的实例。 Director：指挥者，持有一个Builder引用，调用具体的创建者的各个部件来创建对象，负责保证对象各部分完整创建或者按某种顺序创建 。 Product：产品，要创建的具体对象，一般来说是一个复杂的对象，包含多个组成部分。 三. 代码实现这里把电脑作为一个产品，一般来说一个可以使用的台式电脑包括显示器、主机、键盘和鼠标，各个组成部分可以有不同的品牌、性能、型号等细节，下面就使用建造者模式来对电脑进行实现。 产品类——Computer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package io.github.brightloong.design.builder;/** * 产品类Computer，为了方便实现，所有组成均用String来表示。 * Created by BrightLoong on 2018/5/24. */public class Computer &#123; /** * 显示器 */ public String displayer; /** * 主机 */ public String host; /** * 键盘 */ public String keyboard; /** * 鼠标 */ public String mouse; public String getDisplayer() &#123; return displayer; &#125; public void setDisplayer(String displayer) &#123; this.displayer = displayer; &#125; public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public String getKeyboard() &#123; return keyboard; &#125; public void setKeyboard(String keyboard) &#123; this.keyboard = keyboard; &#125; public String getMouse() &#123; return mouse; &#125; public void setMouse(String mouse) &#123; this.mouse = mouse; &#125; /** * 覆盖toString方法. * @return */ @Override public String toString() &#123; return "Computer&#123;" + "displayer='" + displayer + '\'' + ", host='" + host + '\'' + ", keyboard='" + keyboard + '\'' + ", mouse='" + mouse + '\'' + '&#125;'; &#125;&#125; 构建抽象——ComputerBuilder123456789101112package io.github.brightloong.design.builder;/** * Created by BrightLoong on 2018/5/24. */public abstract class ComputerBuilder &#123; abstract void buildDisplay(); abstract void buildHost(); abstract void buildKeyBoard(); abstract void buildMouse(); abstract Computer getComputer();&#125; 具体构建类——SuperComputerBuilder1234567891011121314151617181920212223242526272829303132package io.github.brightloong.design.builder;/** * Created by BrightLoong on 2018/5/24. */public class SuperComputerBuilder extends ComputerBuilder &#123; Computer computer; public SuperComputerBuilder() &#123; computer = new Computer(); &#125; void buildDisplay() &#123; computer.setDisplayer("37.5英寸显示器IPS曲面屏微边框防眩光4K屏幕"); &#125; void buildHost() &#123; computer.setHost("i7-6950X/TiTANX 高端硬管水冷电脑六核游戏主机"); &#125; void buildKeyBoard() &#123; computer.setKeyboard("猛禽竞技机械键盘"); &#125; void buildMouse() &#123; computer.setMouse("逆天悬浮鼠标"); &#125; Computer getComputer() &#123; return computer; &#125;&#125; 指挥者——ComputerDirector1234567891011121314151617181920package io.github.brightloong.design.builder;/** * Created by BrightLoong on 2018/5/24. */public class ComputerDirector &#123; private ComputerBuilder computerBuilder; public ComputerDirector(ComputerBuilder computerBuilder) &#123; this.computerBuilder = computerBuilder; &#125; public Computer build() &#123; computerBuilder.buildDisplay(); computerBuilder.buildHost(); computerBuilder.buildKeyBoard(); computerBuilder.buildMouse(); return computerBuilder.getComputer(); &#125;&#125; 客户端调用和输出1234567891011package io.github.brightloong.design.builder;/** * Created by BrightLoong on 2018/5/24. */public class Client &#123; public static void main(String[] args) &#123; Computer computer = new ComputerDirector(new SuperComputerBuilder()).build(); System.out.println(computer); &#125;&#125; 输出： 1Computer&#123;displayer=&apos;37.5英寸显示器IPS曲面屏微边框防眩光4K屏幕&apos;, host=&apos;i7-6950X/TiTANX 高端硬管水冷电脑六核游戏主机&apos;, keyboard=&apos;猛禽竞技机械键盘&apos;, mouse=&apos;逆天悬浮鼠标&apos;&#125; 四. 总结使用场景 用于创建一些复杂的对象，这些对象内部构建的顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。 当创建复杂的对象的算法应该独立于该对象的组成部分已经它们的装配方法时。 优点 建造者模式使得建造代码与表示代码分离，隐藏了产品实现细节。 如果要改变一个产品的内部表示，只要再定义一个具体的建造者就可以了，方便扩展。 建造者模式通过指挥者可以控制组件建造顺序，能实现一定程度的细节把控，特别是那种生成的产品对象之间存在属性依赖的情况。 缺点 如果产品多变，会生成大量的建造类，造成类膨胀。 五. 扩展——构建器在《Effective Java》一书中，第2条提到： 遇到多个构造器参数时要考虑用构建器。 当有多个参数的时候，客户端代码不仅难编写，也很难阅读，再有，客户端可能不清楚每个参数到底代表什么。 这里也使用到了Builder模式，不直接生成想要的对象，二是让客户端利用所有必要的参数调用Builder构造器，得到一个builder对象。然后客户端在builder对象上调用类似于setter的方法，来设置每个相关的可选参数。最后，客户端调用无参的build方法来生成不可变（相比较JavaBeans模式，也就是调用set方法来进行设值，这种方式可以生成不可变对象）的对象。下面的是具体的代码，来自《Effective Java》书上的列子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package io.github.brightloong.design.builder;/** * Created by BrightLoong on 2018/5/24. */public class NutritionFacts &#123; private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder &#123; //Required parameters private final int servingSize; private final int servings; //Optional parameters - initialized to default values private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val) &#123; calories = val; return this; &#125; public Builder fat(int val) &#123; fat = val; return this; &#125; public Builder sodium(int val) &#123; sodium = val; return this; &#125; public Builder carbohydrate(int val) &#123; carbohydrate = val; return this; &#125; public NutritionFacts build() &#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder) &#123; servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; &#125; @Override public String toString() &#123; return "NutritionFacts&#123;" + "servingSize=" + servingSize + ", servings=" + servings + ", calories=" + calories + ", fat=" + fat + ", sodium=" + sodium + ", carbohydrate=" + carbohydrate + '&#125;'; &#125;&#125; 调用和输出： 1234567891011121314package io.github.brightloong.design.builder;/** * Created by BrightLoong on 2018/5/24. */public class Client2 &#123; public static void main(String[] args) &#123; NutritionFacts cocaCola = new NutritionFacts.Builder(240,8) .calories(100).sodium(35) .carbohydrate(27) .build(); System.out.println(cocaCola); &#125;&#125; 输出： 1NutritionFacts&#123;servingSize=240, servings=8, calories=100, fat=0, sodium=35, carbohydrate=27&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——职责链模式]]></title>
    <url>%2F2018%2F05%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 概述职责链模式（Chain of Responsibility）：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止（个人认为并不一定非要满足这种情况，也可以是每个对象可以处理请求的一部分，或者是下一个处理对象需要上一个处理对象首先完成一些工作，将请求沿链一步一步传递，知道请求最终处理完成，既同时兼顾请求处理和请求转发，当然这个仅仅是个人理解，可能不正确，还请谅解）。 使用职责链模式，发起请求的客户端并不用知道是链中的哪一个对象最终处理了这个请求，所以这样系统的更改可以在不影响客户端的情况下动态地重新组织和分配责任。 职责链模式属于行为型模式。 二. UML类图解析职责链模式的UML类图如下： Handler：处理请求的抽象类，持有一个Handler引用作为后继者，setSuccessor(Handler handler)用于设置后继者；handleRequest(Request request)是处理请求的抽象方法，Request是具体的请求，按照自己的需求定义，可以简单的基本类型，集合类，也可以是自定义的类，等待子类具体实现。 ConcreteHandler1、ConcreteHandler2：具体处理者类，处理客户端请求，也可以访问后继者，按照职责链模式的定义，要么处理请求，要么转发请求，不存在两者同时兼顾的行为。 三. 代码实现用向银行贷款作为例子，申请的贷款金额不同需要不同等级的银行人员进行授权。 贷款请求类——LoanRequest首先创建一个贷款请求，具有基本的贷款金额和贷款人信息。 123456789101112131415161718192021222324252627282930313233343536373839package io.github.brightloong.design.chain;/** * 贷款请求类 * Created by BrightLoong on 2018/5/17. */public class LoanRequest &#123; /**贷款金额*/ private Long loanAmount; /**贷款人姓名*/ private String name; /** * 构造函数. * @param loanAmount * @param name */ public LoanRequest(Long loanAmount, String name) &#123; this.loanAmount = loanAmount; this.name = name; &#125; public Long getLoanAmount() &#123; return loanAmount; &#125; public void setLoanAmount(Long loanAmount) &#123; this.loanAmount = loanAmount; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 抽象处理接口——BankStaff123456789101112131415161718192021222324package io.github.brightloong.design.chain;/** * 请求处理抽象类. * Created by BrightLoong on 2018/5/17. */public abstract class BankStaff &#123; /**持有的后继者的引用*/ private BankStaff nextBankStaff; /**设置后继者*/ public void setNextBankStaff(BankStaff bankStaff) &#123; this.nextBankStaff = bankStaff; &#125; /**获取后继者*/ public BankStaff getNextBankStaff() &#123; return this.nextBankStaff; &#125; /**抽象处理方法，等待子类实现*/ public abstract void handleLoan(LoanRequest request);&#125; 银行柜员实现——BankTeller12345678910111213141516package io.github.brightloong.design.chain;/** * Created by BrightLoong on 2018/5/17. */public class BankTeller extends BankStaff &#123; public void handleLoan(LoanRequest request) &#123; if (request.getLoanAmount() &lt;= 20000) &#123; System.out.println(request.getName() + "申请贷款：" + request.getLoanAmount() + "元，" + "由银行柜员处理。" ); &#125; else if (getNextBankStaff() != null) &#123; getNextBankStaff().handleLoan(request); &#125; else &#123; System.out.println("无法处理的贷款请求。"); &#125; &#125;&#125; 银行经理实现——BankManager12345678910111213141516package io.github.brightloong.design.chain;/** * Created by BrightLoong on 2018/5/17. */public class BankManager extends BankStaff&#123; public void handleLoan(LoanRequest request) &#123; if (request.getLoanAmount() &lt;= 100000) &#123; System.out.println(request.getName() + "申请贷款：" + request.getLoanAmount() + "元，" + "由银行经理处理。" ); &#125; else if (getNextBankStaff() != null) &#123; getNextBankStaff().handleLoan(request); &#125; else &#123; System.out.println("无法处理的贷款请求。"); &#125; &#125;&#125; 银行行长实现——BankPresident12345678910package io.github.brightloong.design.chain;/** * Created by BrightLoong on 2018/5/17. */public class BankPresident extends BankStaff &#123; public void handleLoan(LoanRequest request) &#123; System.out.println(request.getName() + "申请贷款：" + request.getLoanAmount() + "元，" + "由银行行长处理。" ); &#125;&#125; 客户端调用和输出12345678910111213141516171819202122package io.github.brightloong.design.chain;/** * Created by BrightLoong on 2018/5/17. */public class Client &#123; public static void main(String[] args) &#123; //构造职责链 BankStaff bankTeller = new BankTeller(); BankStaff bankManager = new BankManager(); BankStaff bankPresident = new BankPresident(); bankTeller.setNextBankStaff(bankManager); bankManager.setNextBankStaff(bankPresident); //构造请求 LoanRequest request = new LoanRequest(10000L, "小明"); bankTeller.handleLoan(request); LoanRequest request2 = new LoanRequest(200000L, "老王"); bankTeller.handleLoan(request2); &#125;&#125; 输出结果: 12小明申请贷款：10000元，由银行柜员处理。老王申请贷款：200000元，由银行行长处理。 四. 总结使用场景 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 在不明确接收者的情况下，向多个对象中的一个处理提交一个请求。 可动态指定一组对象处理请求。 优点 实现了请求发送者和接收者的解耦，降低了耦合度。 方便扩展，可以方便的增加请求处理类。 可以动态的设置请求处理类的顺序，比较灵活。 接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需要保持一个指向后继者的引用。 缺点 请求有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理。 如果要配置比较复杂的链会导致性能受到影响，并且难于调试，易于出错 参考：http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2F2018%2F05%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 概述考虑如下情景，超市搞打折活动，对于消费额度不同提供不同的折扣，比如：满200打9折，满400打8折之类的；或者旅行出游的情景，可以考虑骑自行车，坐汽车、火车、飞机等等。 如何实现上面描述的情景，当然最直接想到的是使用if…else进行判断，执行不同的操作，但是如果在你实现完后有添加了其他的活动或者出行方式呢，这个时候你需要在客户端直接修改代码。 当然，也可能想到之前提到过的工厂模式，但是工厂模式主要是解决对象的创建问题，而打折方式，出行方式这种行为都属于一系列的算法，如何让算法和对象分开来，使得算法可以独立于调用它的客户端变化就是策略模式解决的问题。 策略模式(Strategy) 定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。 策略模式属于对象的行为模式。 二. UML类图解析策略模式的UML图如下所示： IStrategy：策略接口类，定义所有支持的算法的公共接口。（如果算法存在公共的实现逻辑，可以采用抽象类，以继承的方式实现算法，可以把公共代码移到父类，避免代码重复） StrategyA、StrategyB：具体策略类，封装了具体的算法或行为，实现IStategy。 Context：Context上下文，其中定义一个方法来进行配置，维护一个对IStrategy的引用。 三. 代码实现就用上面提到的旅游出行来作为具体的场景用代码进行实现。 策略接口——ITravelStrategy12345678package io.github.brightloong.design.strategy;/** * Created by BrightLoong on 2018/5/6. */public interface ITravelStrategy &#123; void travel();&#125; 策略实现——AirPlaneStrategy12345678910package io.github.brightloong.design.strategy;/** * Created by BrightLoong on 2018/5/6. */public class AirPlaneStrategy implements ITravelStrategy &#123; public void travel() &#123; System.out.println("坐飞机出游。"); &#125;&#125; 策略实现——TrainStrategy12345678910package io.github.brightloong.design.strategy;/** * Created by BrightLoong on 2018/5/6. */public class TrainStrategy implements ITravelStrategy &#123; public void travel() &#123; System.out.println("坐火车出游。"); &#125;&#125; 上下文环境类——TravelContext12345678910111213141516package io.github.brightloong.design.strategy;/** * Created by BrightLoong on 2018/5/6. */public class TravelContext &#123; private ITravelStrategy travelStrategy; public TravelContext(ITravelStrategy travelStrategy) &#123; this.travelStrategy = travelStrategy; &#125; public void travel() &#123; travelStrategy.travel(); &#125;&#125; 客户端调用——Tourist1234567891011package io.github.brightloong.design.strategy;/** * Created by BrightLoong on 2018/5/6. */public class Tourist &#123; public static void main(String[] args) &#123; TravelContext travelContext = new TravelContext(new AirPlaneStrategy()); travelContext.travel(); &#125;&#125; 输出 1坐飞机出游。 四. 扩展在上面的客户端调用中，发现需要客户端了解所有的策略实现，并且需要客户端自己判断使用哪一种策略，如果想将这个判断从客户端移走，这个时候可以将策略模式和简单工厂模式进行结合，修改后的TravelContext如下： 1234567891011121314151617181920212223242526package io.github.brightloong.design.strategy;/** * Created by BrightLoong on 2018/5/6. */public class TravelContextFactory &#123; private ITravelStrategy travelStrategy; /** * 这里的参数最好用枚举进行定义，这样不会出现传入不存在的参数. * @param travelType */ public TravelContextFactory(String travelType) &#123; if ("airPlaen".equals(travelType)) &#123; travelStrategy = new AirPlaneStrategy(); &#125; else if ("train".equals(travelType)) &#123; travelStrategy = new TrainStrategy(); &#125; else &#123; throw new RuntimeException("不支持的策略"); &#125; &#125; public void travel() &#123; travelStrategy.travel(); &#125;&#125; 五.使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种，需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。 出现同一抽象类有多个子类，并且使用判断逻辑if-else之类的来判断选择具体子类。 六. 总结优点 上面提到了，并不一定要使用策略接口，也可以使用抽象类，恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 具有良好的扩展性，新增算法只用添加策略实现。 不同算法之间可以自由切换。 使用策略模式可以避免使用多重条件(if-else)语句。 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。策略模式将责任交给了客户端去承担。 随着策略的不断增加，将产生越来越多的策略类，导致了类膨胀。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——工厂模式]]></title>
    <url>%2F2018%2F05%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一.概述工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，其通过提供对象创建工厂，将创建对象的具体过程屏蔽起来，使调用的客户端不用关心具体的对象创建过程，提高了灵活性。 工厂模式属于创建型模式。 工厂模式根据抽象层的不用，可以分为以下三类： 简单工厂模式 工厂方法模式 抽象工厂模式 其中“简单工厂模式”并不属于设计模式的一种，通俗的说是一种编程经验。 二. 简单工厂模式简单工厂模式是工厂对象根据传入的参数不同，创建不同的对象实例。 UML类图解析 Product：产品接口，也可以是抽象类。 ProductA，ProductB：具体产品实现。 Factory：根据传入的参数创建具体的产品的工厂，供客户端调用。 代码实现图形接口定义12345678package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public interface Shap &#123; void draw();&#125; 图形实现——Circle12345678910package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public class Circle implements Shap&#123; public void draw() &#123; System.out.println("it is a circle"); &#125;&#125; 图形实现——Square12345678910package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public class Square implements Shap &#123; public void draw() &#123; System.out.println("it is a square"); &#125;&#125; 工厂关于工厂，最简单的是传入一个参数，使用 if, else或者case做条件判断返回不同的产品实现，也可以使用反射的方法，来消除这些判断条件。 123456789101112131415161718192021222324252627282930313233package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public class SimpleShapFactory &#123; public Shap create(String shapType) &#123; if ("circle".equals(shapType)) &#123; return new Circle(); &#125; else if ("square".equals(shapType)) &#123; return new Square(); &#125; return null; &#125; /** * 可以使用这种方式消除if之类的条件判断 * @param clz * @param &lt;T&gt; * @return */ public &lt;T&gt; Shap create(Class&lt;T&gt; clz) &#123; Shap shap = null; try &#123; shap = (Shap) clz.newInstance(); &#125; catch (InstantiationException e) &#123; return null; &#125; catch (IllegalAccessException e) &#123; return null; &#125; return shap; &#125;&#125; 客户端调用123456789101112131415161718package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public class Client1 &#123; public static void main(String[] args) &#123; Shap shap = new SimpleShapFactory().create("circle"); if (shap != null) &#123; shap.draw(); &#125; Shap shap1 = new SimpleShapFactory().create(Square.class); if (shap1 != null) &#123; shap1.draw(); &#125; &#125;&#125; 输出结果 12it is a circleit is a square 优点 隐藏了具体的对象创建细节，提高了灵活性。 便于扩展，添加新的产品时候只需要添加一个新的产品类，修改工厂。 缺点 每添加一个新的产品都要修改工厂类在其中添加判断分支（如果没有用反射的方式），违反了开放-封闭原则。 如果添加的产品过多会导致类膨胀。 三. 工厂方法模式工厂方法模式除了对产品类的抽象外，又添加了对工厂的抽象，不再在工厂中进行调用逻辑的判断处理，而是将这个判断放在了客户端。工厂方法针对每一产品都提供一个工厂类，不同的工厂创建不同的产品实例。 UML类图解析 工厂方法模式和简单工厂类似，不同的就是这里对工厂进行了抽象，有了一个抽象的工厂角色——AbstarctFactory。 代码实现产品实现和简单工厂模式的一样，这里不再给出。 AbstractFactory——FactoryMethod12345678package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public abstract class FactoryMethod &#123; abstract Shap createShap();&#125; FactoryA——CircleFactory12345678910package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public class CircleFactory extends FactoryMethod &#123; public Shap createShap() &#123; return new Circle(); &#125;&#125; FactoryB——SquareFactory12345678910package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public class SquareFactory extends FactoryMethod &#123; public Shap createShap() &#123; return new Square(); &#125;&#125; 客户端调用1234567891011package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public class Client2 &#123; public static void main(String[] args) &#123; Shap shap = new SquareFactory().createShap(); shap.draw(); &#125;&#125; 输出 1it is a square 优点 拥有简单工厂模式的优点。 具有简单工厂模式的优点，并且再此基础上满足了开放-封闭原则，系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 缺点 随着产品类的增加，要提供与其对应的子类，系统中类个数成对增加，在一定程度上增加了系统的复杂性。 四. 抽象工厂模式上面说道的简单工厂和工厂模式都只能创建一个产品实例，抽象工厂提供了生成多产品的功能。这里很多地方提到了产品族 的说法，比如生产面包的工厂不止生产面包，还会生产饼干、糖果之类的。 UML类图解析 这里有ProductA和ProductB两个产品抽象，并且分别有两个具体实现，抽象工厂AbstractFactory和之前不同的是这里提供了两个生产产品的方法——crateProductA和crateProductB。 代码实现在之前Shap产品的基础上增加Colro产品，具体代码如下： Color123public interface Color &#123; void fill();&#125; Color实现——Red1234567public class Red implements Color &#123; @Override public void fill() &#123; System.out.println("it is red."); &#125;&#125; Color实现——Green1234567public class Green implements Color &#123; @Override public void fill() &#123; System.out.println("it is green"); &#125;&#125; 抽象工厂—— AbstractFactory1234public abstract class AbstractFactory &#123; abstract Color createColor(); abstract Shape createShape() ;&#125; 工厂实现11234567891011121314package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public class RedCircleFactory extends AbstractFactory &#123; Shap createShap() &#123; return new Circle(); &#125; Color createColor() &#123; return new Red(); &#125;&#125; 工厂实现21234567891011121314package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/5. */public class GreenSquareFactory extends AbstractFactory &#123; Shap createShap() &#123; return new Square(); &#125; Color createColor() &#123; return new Green(); &#125;&#125; 客户端调用1234567891011121314package io.github.brightloong.design.factory;/** * Created by BrightLoong on 2018/5/2. */public class Client3 &#123; public static void main(String[] args) &#123; AbstractFactory factory = new RedCircleFactory(); Shap shap = factory.createShap(); Color color = factory.createColor(); shap.draw(); color.fill(); &#125;&#125; 输出 12it is a circleit is red. 优点 支持了不同类型的产品，更加灵活。 缺点 缺点很明显，类膨胀越来越厉害。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——装饰器模式]]></title>
    <url>%2F2018%2F04%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 概述装饰器模式（Decorator）,动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更为灵活；它允许向一个现有的对象添加新的功能，同时又不改变其结构。 装饰器模式属于结构型模式。 二. UML类图解析装饰器模式的UML类图如下： Component：接口，定义一个抽象接口，真实对象和装饰对象具有相同的接口，以便动态的添加职责。 ConcreteComponent：具体的对象。 Decorator：装饰类，继承了Component,从外类来扩展Component类的功能，并且持有一个构建引用，进行请求转发。 ConcreteDecorator：具体装饰类，用于给实际对象添加职责。 三. 代码实现现在考虑这样一个场景，现在有一个煎饼摊，人们去买煎饼（Pancake）,有些人要加火腿（Ham）的，有些人要加鸡蛋（Egg）的，有些人要加生菜（Lettuce）的，当然土豪可能有啥全给加上^_^。用上述的装饰器模式来进行编码。 1. 定义煎饼接口IPancake123456789101112package io.github.brightloong.design.decorator;/** * 定义一个煎饼接口 * Created by BrightLoong on 2018/4/22. */public interface IPancake &#123; /** * 定义烹饪的操作 */ void cook();&#125; 2. 定义具体的煎饼Pancake1234567891011package io.github.brightloong.design.decorator;/** * 具体的煎饼对象，可用其他装饰类进行动态扩展。 * Created by BrightLoong on 2018/4/22. */public class Pancake implements IPancake&#123; public void cook() &#123; System.out.println("的煎饼"); &#125;&#125; 3. 定义抽象装饰类PancakeDecorator123456789101112131415161718192021package io.github.brightloong.design.decorator;/** * 实现接口的抽象装饰类，建议设置成abstract. * Created by BrightLoong on 2018/4/22. */public abstract class PancakeDecorator implements IPancake &#123; /***/ private IPancake pancake; public PancakeDecorator(IPancake pancake) &#123; this.pancake = pancake; &#125; public void cook() &#123; if (this.pancake != null) &#123; pancake.cook(); &#125; &#125;&#125; 4. 具体装饰类EggDecorator123456789101112131415161718192021package io.github.brightloong.design.decorator;/** * 对煎饼加鸡蛋的装饰类，继承PancakeDecorator，覆盖cook操作 * Created by BrightLoong on 2018/4/22. */public class EggDecorator extends PancakeDecorator &#123; public EggDecorator(IPancake pancake) &#123; super(pancake); &#125; /** * 覆盖cook方法，加入自身的实现，并且调用父类的cook方法，也就是构造函数中 * EggDecorator(IPancake pancake)，这里传入的pancake的cook操作 */ @Override public void cook() &#123; System.out.println("加了一个鸡蛋，"); super.cook(); &#125;&#125; 5. 具体装饰类HamDecorator123456789101112131415161718192021package io.github.brightloong.design.decorator;/** * 对煎饼加火腿的装饰类，继承PancakeDecorator，覆盖cook操作 * Created by BrightLoong on 2018/4/22. */public class HamDecorator extends PancakeDecorator &#123; public HamDecorator(IPancake pancake) &#123; super(pancake); &#125; /** * 覆盖cook方法，加入自身的实现，并且调用父类的cook方法，也就是构造函数中 * EggDecorator(IPancake pancake)，这里传入的pancake的cook操作 */ @Override public void cook() &#123; System.out.println("加了一根火腿，"); super.cook(); &#125;&#125; 6. 具体装饰类LettuceDecorator123456789101112131415161718192021package io.github.brightloong.design.decorator;/** * 对煎饼加生菜的装饰类，继承PancakeDecorator，覆盖cook操作 * Created by BrightLoong on 2018/4/22. */public class LettuceDecorator extends PancakeDecorator &#123; public LettuceDecorator(IPancake pancake) &#123; super(pancake); &#125; /** * 覆盖cook方法，加入自身的实现，并且调用父类的cook方法，也就是构造函数中 * EggDecorator(IPancake pancake)，这里传入的pancake的cook操作 */ @Override public void cook() &#123; System.out.println("加了一颗生菜，"); super.cook(); &#125;&#125; 7. 客户端调用以及结果12345678910111213141516171819202122package io.github.brightloong.design.decorator;/** * 调用客户端 * Created by BrightLoong on 2018/4/22. */public class Client &#123; public static void main(String[] args) &#123; System.out.println("=========我是土豪都给我加上==========="); IPancake pancake = new Pancake(); IPancake pancakeWithEgg = new EggDecorator(pancake); IPancake pancakeWithEggAndHam = new HamDecorator(pancakeWithEgg); IPancake panckeWithEggAndHamAndLettuce = new LettuceDecorator(pancakeWithEggAndHam); panckeWithEggAndHamAndLettuce.cook(); System.out.println("==========我是程序猿，加两个鸡蛋补补=============="); IPancake pancake2 = new Pancake(); IPancake pancakeWithEgg2 = new EggDecorator(pancake2); IPancake pancakeWithTwoEgg = new EggDecorator(pancakeWithEgg2); pancakeWithTwoEgg.cook(); &#125;&#125; 输出结果 123456789=========我是土豪都给我加上===========加了一颗生菜，加了一根火腿，加了一个鸡蛋，的煎饼==========我是程序猿，加两个鸡蛋补补==============加了一个鸡蛋，加了一个鸡蛋，的煎饼 四. 总结关于装饰器模式的使用，在我看来主要有一下几点需要注意的 抽象装饰器和具体被装饰的对象实现同一个接口 抽象装饰器里面要持有接口对象，以便请求传递 具体装饰器覆盖抽象装饰器方法并用super进行调用，传递请求 1. 适用场景 扩展一个类的功能。 动态添加功能，动态撤销。 2. 优点 装饰类和被装饰类都只关心自身的核心业务，实现了解耦。 方便动态的扩展功能，且提供了比继承更多的灵活性。 3. 缺点 如果功能扩展过多，势必产生大量的类。 多层装饰比较复杂。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——单例模式]]></title>
    <url>%2F2018%2F04%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式属于创建模型。 单例模式，是设计模式中比较简单而又最常用的模式之一。通过单例模式可以保证系统中，应用该模式的类只有一个类实例。例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。 模式定义单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。 实现1. 饿汉式饿汉式提供了线程安全的单例，但是不支持懒加载，在第一次加载类到内存中时就会初始化（所以称之为饿汉，不管怎么样，先初始化了再说）。 1234567891011121314151617/** * 饿汉式单例模式. * * @author BrightLoong. */public class Singleton &#123; /** 全局唯一实例. */ private static final Singleton singleton = new Singleton(); private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; return singleton; &#125;&#125; 2. 非线程安全懒汉式相对饿汉式，懒汉式提供了再需要时候初始化的方式，以下是非线程安全的实现方式，不建议使用。 1234567891011121314151617181920212223/** * 非线程安全的懒汉式. * * @author BrightLoong. */public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; /** * 通过懒加载的方式获取实例，但是非线程安全. * @return Singleton实例 */ public static Singleton getSingleton() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 3. 低效的线程安全懒汉式——使用synchronized使用synchronized进行同步，虽然保证了线程安全，但是并不高效，比较单例模式只有在第一次创建的时候会存在线程安全问题，而不需要在创建单例后在以后的每一次调用还要进行同步。 1234567891011121314151617181920212223/** * 低效的线程安全的懒汉式. * * @author BrightLoong. */public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; /** * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例. * @return Singleton实例 */ public static synchronized Singleton getSingleton() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 4. 双重校验锁线程安全懒汉式相对上面的同步方法，双重校验使用同步块解决线程安全问题。两次检查instance == null，一次是在同步块外，一次是在同步快内。为什么在同步块内还要检验一次，因为可能会有多个线程一起进入同步块外的if，如果在同步块内不进行二次检验的话就会生成多个实例了。 注：受限于Jdk5以前的Java内存模型，仍然会有bug，Java5及之后才能正常达到单例效果。 123456789101112131415161718192021222324252627/** * 双重校验锁线程安全懒汉式. * * @author BrightLoong. */public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; /** * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例. * @return Singleton实例 */ public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 5. 枚举式《Effective Java》一书中推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量），但是不支持懒加载。 12345678910/** * 枚举方式的单例. * * @author BrightLoong. */public enum Singleton &#123; INSTANCE;&#125; 6. 静态内部类使用JVM本身机制保证了线程安全问题，其只有显式通过调用getInstance方法时，才会装载SingletonHolder类，从而实例化instance；同时读取实例的时候不会进行同步，没有性能缺陷，也不依赖JDK版本。 1234567891011121314151617181920212223242526272829/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例. * * @author BrightLoong. */public class Singleton &#123; private Singleton() &#123;&#125; /** * 静态内部类. */ private static final class SingletonHolder &#123; private SingletonHolder() &#123;&#125; private static Singleton instance = new Singleton(); &#125; /** * 通过懒加载的方式获取Singleton唯一实例的方法. * @return Singleton实例 */ public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125;&#125; 以上就是对单例模式的简单介绍，单例模式非常简单，其他的优缺点之类的不再赘述。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——命令模式]]></title>
    <url>%2F2018%2F01%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 简介命令模式 ，将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持撤销的操作。 命令模式的特点是对命令进行了封装，将请求的具体操作封装成命令对象，用户无需知道具体需要执行什么样的操作逻辑，只用调用对应的命令即可，实现了用户请求和请求实现的解耦，方便扩展。 二. 模式结构解析UML类图 Client(客户端)：确定命令接收者，并创建具体的命令。 Invoker(命令发起者)：发起命令执行请求 ICommand(命令抽象接口)：声明的命令抽象接口，具有execute()方法。 ConcreteCommand(命令接口的具体实现)：实现命令接口，实现具体的execute()方法，负责调用命令接收者进行命令执行。 Receiver(命令接受者)：接收请求并执行，具体的请求实现，这里的任何类都有可能成为一个命令接收者。 三. 简单命令模式代码实现1. ICommand命令接口定义1234package brightloong.github.io.command.core.simple;public interface ICommand &#123; public void execute();&#125; 2. ConcreteCommand具体命令实现12345678910111213141516171819202122package brightloong.github.io.command.core.simple.impl;import brightloong.github.io.command.core.simple.ICommand;import brightloong.github.io.command.core.simple.Receiver;public class ConcreteCommand implements ICommand &#123; private Receiver receiver; public ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; /** (non-Javadoc) * @see brightloong.github.io.command.core.simple.ICommand#execute() */ public void execute() &#123; System.out.println("ConcreteCommand发送命令给接给命令接收者！"); receiver.action(); &#125;&#125; 3. Receiver具体的命令接收者实现123456789package brightloong.github.io.command.core.simple;public class Receiver &#123; public void action() &#123; System.out.println("Receiver接收到命令并执行！"); &#125;&#125; 4. Invoker命令调用者12345678910111213141516171819202122package brightloong.github.io.command.core.simple;public class Invoker &#123; private ICommand command; /** * @return the command */ public ICommand getCommand() &#123; return command; &#125; public void setCommand(ICommand command) &#123; this.command = command; &#125; public void action() &#123; System.out.println("命令请求者Invoker发起命令！"); this.command.execute(); &#125;&#125; 5. Client客户端测试代码和结果1234567891011121314package brightloong.github.io.command.core.simple;import brightloong.github.io.command.core.simple.impl.ConcreteCommand;public class Client &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); ICommand command = new ConcreteCommand(receiver); Invoker invoker = new Invoker(); invoker.setCommand(command); invoker.action(); &#125;&#125; 输出结果如下： 123命令请求者Invoker发起命令！ConcreteCommand发送命令给接给命令接收者！Receiver接收到命令并执行！ 四. 宏命令的代码实现宏命令，就是又多条命令组成一个命令，是一个命令的组合。实现如下 1. 新增宏命令抽象定义IMacroCommand12345678910package brightloong.github.io.command.core.macro;import brightloong.github.io.command.core.simple.ICommand;public interface IMacroCommand extends ICommand&#123; public void add(ICommand command); public void remove(ICommand command);&#125; 2. 宏命令具体实现MacroCommandImpl1234567891011121314151617181920212223242526272829303132333435package brightloong.github.io.command.core.macro.impl;import java.util.ArrayList;import java.util.List;import brightloong.github.io.command.core.macro.IMacroCommand;import brightloong.github.io.command.core.simple.ICommand;public class MacroCommandImpl implements IMacroCommand&#123; List&lt;ICommand&gt; commands = new ArrayList&lt;ICommand&gt;(); /** (non-Javadoc) * @see brightloong.github.io.command.core.simple.ICommand#execute() */ public void execute() &#123; for (ICommand command : commands) &#123; command.execute(); &#125; &#125; /** (non-Javadoc) * @see brightloong.github.io.command.core.macro.IMacroCommand#add(brightloong.github.io.command.core.simple.ICommand) */ public void add(ICommand command) &#123; commands.add(command); &#125; /** (non-Javadoc) * @see brightloong.github.io.command.core.macro.IMacroCommand#remove(brightloong.github.io.command.core.simple.ICommand) */ public void remove(ICommand command) &#123; commands.remove(command); &#125;&#125; 3. Receiver新增方法12345678910111213141516package brightloong.github.io.command.core.simple;public class Receiver &#123; public void action() &#123; System.out.println("Receiver接收到命令并执行！"); &#125; public void sing() &#123; System.out.println("大河向东流，天上的形象参北斗..."); &#125; public void playGame() &#123; System.out.println("大吉大利，今晚吃鸡。"); &#125;&#125; 4. 新增命令PlayGameCommand和SingCommand12345678910111213141516171819202122package brightloong.github.io.command.core.simple.impl;import brightloong.github.io.command.core.simple.ICommand;import brightloong.github.io.command.core.simple.Receiver;public class PlayGameCommand implements ICommand &#123; private Receiver receiver; public PlayGameCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; /** (non-Javadoc) * @see brightloong.github.io.command.core.simple.ICommand#execute() */ public void execute() &#123; receiver.playGame(); &#125;&#125; 12345678910111213141516171819202122package brightloong.github.io.command.core.simple.impl;import brightloong.github.io.command.core.simple.ICommand;import brightloong.github.io.command.core.simple.Receiver;public class SingCommand implements ICommand &#123; private Receiver receiver; public SingCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; /** (non-Javadoc) * @see brightloong.github.io.command.core.simple.ICommand#execute() */ public void execute() &#123; receiver.sing(); &#125;&#125; 5. 修改客户端Client以及输出结果展示1234567891011121314151617181920212223package brightloong.github.io.command.core.simple;import brightloong.github.io.command.core.macro.IMacroCommand;import brightloong.github.io.command.core.macro.impl.MacroCommandImpl;import brightloong.github.io.command.core.simple.impl.PlayGameCommand;import brightloong.github.io.command.core.simple.impl.SingCommand;public class Client &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); ICommand singCommand = new SingCommand(receiver); ICommand playGameCommand = new PlayGameCommand(receiver); IMacroCommand macroCommand = new MacroCommandImpl(); macroCommand.add(singCommand); macroCommand.add(playGameCommand); Invoker invoker = new Invoker(); invoker.setCommand(macroCommand); invoker.action(); &#125;&#125; 输出结果如下： 123命令请求者Invoker发起命令！大河向东流，天上的形象参北斗...大吉大利，今晚吃鸡。 五. 使用场景1. 应用场景 使用命令模式作为”CallBack”在面向对象系统中的替代。”CallBack”讲的便是先将一个函数登记上，然后在以后调用此函数。 需要在不同的时间指定请求、将请求排队。一个命令对象和原先的请求发出者可以有不同的生命期。换言之，原先的请求发出者可能已经不在了，而命令对象本身仍然是活动的。这时命令的接收者可以是在本地，也可以在网络的另外一个地址。命令对象可以在串形化之后传送到另外一台机器上去。 系统需要支持命令的撤消(undo)。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用undo()方法，把命令所产生的效果撤销掉。命令对象还可以提供redo()方法，以供客户端在需要时，再重新实施命令效果。 如果一个系统要将系统中所有的数据更新到日志里，以便在系统崩溃时，可以根据日志里读回所有的数据更新命令，重新调用Execute()方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。 2. 具体场景 Multi-level undo（多级undo操作） 如果系统需要实现多级回退操作，这时如果所有用户的操作都以command对象的形式实现，系统可以简单地用stack来保存最近执行的命令，如果用户需要执行undo操作，系统只需简单地popup一个最近的 command对象然后执行它的undo()方法既可。 Transactional behavior（原子事务行为） 借助command模式，可以简单地实现一个具有原子事务的行为。当一个事务失败时，往往需要回退到执行前的状态，可以借助command对象保存这种状态，简单地处理回退操作。 Progress bars（状态条） 假如系统需要按顺序执行一系列的命令操作，如果每个command对象都提供一个 getEstimatedDuration()方法，那么系统可以简单地评估执行状态并显示出合适的状态条。 Wizards（导航） 通常一个使用多个wizard页面来共同完成一个简单动作。一个自然的方法是使用一个command对象来封装wizard过程，该command对象在第一个wizard页面显示时被创建，每个wizard页面接收用户输入并设置到该command对象中，当最后一个wizard页面用户按下“Finish”按钮时，可以简单地触发一个事件调用execute()方法执行整个动作。通过这种方法，command类不包含任何跟用户界面有关的代码，可以分离用户界面与具体的处理逻辑。 GUI buttons and menu items（GUI按钮与菜单条等等） Swing系统里，用户可以通过工具条按钮，菜单按钮执行命令，可以用command对象来封装命令的执行。 Thread pools（线程池） 通常一个典型的线程池实现类可能有一个名为addTask()的public方法，用来添加一项工作任务到任务队列中。该任务队列中的所有任务可以用command对象来封装，通常这些command对象会实现一个通用的接口比如java.lang.Runnable。 Macro recording（宏纪录） 可以用command对象来封装用户的一个操作，这样系统可以简单通过队列保存一系列的command对象的状态就可以记录用户的连续操作。这样通过执行队列中的command对象，就可以完成”Play back”操作了。 Networking 通过网络发送command命令到其他机器上运行。 Parallel Processing（并发处理） 当一个调用共享某个资源并被多个线程并发处理时。 六. 优缺点1. 优点 更松散的耦合 命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。 更动态的控制 命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。 很自然的复合命令 命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。 更好的扩展性 由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。 2. 缺点 同样的和大部分设计模式一样，会增加系统的复杂性，这里主要指的是类的数量的增加。 参考 http://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html http://blog.csdn.net/zdsicecoco/article/details/51332440]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——模板方法模式]]></title>
    <url>%2F2018%2F01%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法属于行为型模式 一. 简介模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 模板方法模式是基于集成的代码复用的模式。 二. UML类图 AbstractTemplate(抽象模板)： templateMethod()：模板方法，可能实现了部分逻辑，并调用abstractMethod()方法，将其他实现延迟到子类中去实现。 abstractMethod()：抽象操作方法，子类集成并实现。 ConcreteTemplate1(抽象模板具体实现1)：实现父类定义的一个或多个抽象方法(也可以不是抽象方法，可以是一个钩子方法，钩子方法可以让子类决定是否对算法的不同点进行挂钩)。 Client(客户端)：调用具体的模板实现 三. 代码实现1. AbstractTemplate抽象模板类1234567891011package brightloong.github.io.template;public abstract class AbstractTemplate &#123; public void templateMehtod() &#123; System.out.println("开始连接，连接成功..."); abstracMethod(); System.out.println("断开连接，释放资源..."); &#125; protected abstract void abstracMethod();&#125; 2. concreteTemplate1抽象模板类具体实现112345678910111213package brightloong.github.io.template;public class ConcreteTemplate1 extends AbstractTemplate&#123; /** (non-Javadoc) * @see brightloong.github.io.template.AbstractTemplate#abstracMethod() */ @Override public void abstracMethod() &#123; System.out.println("查询用户表...."); &#125;&#125; 3. concreteTemplate2抽象模板类具体实现212345678910111213package brightloong.github.io.template;public class ConcreteTemplate2 extends AbstractTemplate&#123; /** (non-Javadoc) * @see brightloong.github.io.template.AbstractTemplate#abstracMethod() */ @Override public void abstracMethod() &#123; System.out.println("查询商品表..."); &#125;&#125; 4. Client客户端调用测试代码和结果1234567891011package brightloong.github.io.template;public class Client &#123; public static void main(String[] args) &#123; AbstractTemplate template = new ConcreteTemplate1(); template.templateMehtod(); System.out.println(""); AbstractTemplate template2 = new ConcreteTemplate2(); template2.templateMehtod(); &#125;&#125; 运行结果如下： 1234567开始连接，连接成功...查询用户表....断开连接，释放资源...开始连接，连接成功...查询商品表...断开连接，释放资源... 四. 使用场景 某些方法中使用了相同的代码或者方法造成代码重复。 控制子类扩展，子类必须遵守一定的算法规则。 HttpServlet就是典型的应用，其中service()方法作为模板方法，而doPost()和doGet()等方法就是可以被子类实现的具体方法。 五. 优缺点1. 优点 可以将公共代码行为进行提取，以达到复用的目的。 子类实现算法的某些细节，有助于算法的扩展。 通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。 2. 缺点 每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简介UML类图]]></title>
    <url>%2F2017%2F10%2F18%2F%E7%AE%80%E4%BB%8BUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML全称Unified Modeling Language 又称统一建模语言或标准建模语言。我们再学习各种框架或者设计模式之类的时候经常会看到UML类图，这里将UML类图一些基本点做一个记录。 在文章中所涉及到的UML类图是使用starUML工具创建，使用其他工具创建会有所不同。 总体印象 上面的UML类图基本展示了UML类图的大部分元素，以及类与类之间的关系，下面将对其一一进行解释。 NOTE UML类图注解的表示方法，如上右半部所示。 类结构表示 类的表示方法如图，一般分为三层，从上到下依次为类名、属性和方法。接口表示和类的表示类似，只是在上面标明了是interface（这只是表示接口的一种方式，并且不同的工具展现方式可能不同，还有一种棒棒糖的形式，就是一个圆加一条竖线，并不常见，所以也不过多介绍），并且这里我隐藏了属性层。如果是抽象类，在使用starUML工具创建的时候类名会以斜线表示。关于类的表示有以下几点： +：public，-：private，#：protected 属性冒号后的内容表示属性的类型 方法冒号后的内容表示属性的返回值 类型说明并不是必须的 类关系表示实现 实现(Realization)，用一个带空心三角箭头的虚线来表示。用来表示接口和实现类的关系。比如：Plane(飞机)和Car(汽车)都实现了接口IVehicle(交通工具)。 继承 继承(Generalization，也称为泛化关系)，用一个带空心三角箭头的实线来表示。表示父类与子类之间的关系。比如：Trunck(卡车)和Bus(公交车)都继承自父类Car(汽车)。 关联关系关联(Association)，关联关系分为以下几种 自关联：用一头带箭头的实线表示，自己指向自己 单向关联：用一头带箭头的实线表示，箭头指向被关联类 双向关联：用一条实线表示，或者使用双箭头 关联关系表示类与类之间的联系，是同一层次上的关系，它不像依赖关系具有偶然性和临时性。一般情况是关联类引用被关联类作为全局变量。如下Human持有Name。 大多数的关联关系都是单向的。 聚合关系 聚合(Aggregation)，用一头是空心菱形的直线表示(有些时候是一头为空心菱形，一头为箭头的实线)。聚合也是关联关系的一种，是整体和部分之间的关系，也就是has-a的关系(很多地方has-a，contains-a已经比较混乱，我理解上来看是has-a)，整体包含部分，但是部分脱离整体后依然可以单独存在。如上：Car(汽车)包含Engine(引擎)，但是Engine脱离了Car依然可以独立存在。 组合关系 组合(Composition)，用一头是实心菱形的直线表示(有些时候是一头为实心菱形，一头为箭头的实线)。组合同样是一种关联关系，也同样是整体和部分之间的关系，我把它理解为contains-a的关系。和聚合的区别在于，部分脱离整体和无法单独存在，整体和部分具有相同的生命周期，整体不存在了，部分也就消失了。如上：Human(人类)包含Head(头)和Body(身体)，头和身体并不能单独存在。 依赖关系 依赖(Dependency)，用一头带箭头的虚线表示。表示类与类之间，一个类依赖于另一个类的定义。被依赖类的变化将会引起依赖类的变化。在java中依赖关系通常体现为，一个类使用另一个类作为局部变量，方法参数或静态方法调用，表示为use-a。如上，Engine的方法startEngine()方法使用Gasoline(汽油)作为参数，可能是调用了Gasoline中的burn()方法。]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用树形结构保存实体]]></title>
    <url>%2F2017%2F10%2F09%2F%E4%BD%BF%E7%94%A8%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E4%BF%9D%E5%AD%98%E5%AE%9E%E4%BD%93%2F</url>
    <content type="text"><![CDATA[之前在项目需要实现一个功能——将xml文件映射成实体，然后对映射的实体进行逻辑处理，最后保存到数据库中；由于xml结构的数据是结构化的数据，所以需要保证保存的数据具有正确的主外键关联。如下所示，是一个需要保存到数据库的xml文件。当映射成对应的实体school和student的时候，我们需要知道“school-one”下面有哪些学生，“school-two”下面有哪些学生，这个时候想到了使用树形结构来保存实体，让实体之间依然存在关联关系。 1234567891011121314151617181920&lt;school-inf&gt; &lt;msg&gt;2017-10-1XX省学校信息总汇&lt;/msg&gt; &lt;schools&gt; &lt;school&gt; &lt;name&gt;school-one&lt;/name&gt; &lt;students&gt; &lt;student&gt;Jack&lt;/student&gt; &lt;student&gt;Rose&lt;/student&gt; &lt;student&gt;Jon&lt;/student&gt; &lt;/students&gt; &lt;/school&gt; &lt;school&gt; &lt;name&gt;school-two&lt;/name&gt; &lt;students&gt; &lt;student&gt;Bob&lt;/student&gt; &lt;student&gt;Alisa&lt;/student&gt; &lt;/students&gt; &lt;/school&gt; &lt;/schools&gt;&lt;/school-inf&gt; 树形工具以下是树形工具类的实现，包含了树形节点类和树形结构类，由于代码中注释已经比较全面，所以不做过多的说明。 树形节点类BeanTreeNode.java每一个节点对应一个实体，节点包含了实体信息，为了保证实体之间的关联关系，需要留有父节点信息，所有的子节点信息。由此推断出，节点的主要成员有 父节点信息 所有子节点信息 当前实体信息 为了方便操作，我还多增加了id和pid（parent id）,以及节点类型（nodeType）。对id的相关操作我并没有添加，如果需要可以自行添加。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import java.util.ArrayList;import java.util.List;import java.util.UUID;/** * 实体树形结构点 * BeanTreeNode * @author BrightLoong * @version 1.0 * */public class BeanTreeNode &#123; /**标识id*/ private String id; /**父id标识，为了方便获取冗余出来*/ private String pid; /**父节点*/ private BeanTreeNode parentNode; /**节点类型*/ private String nodeType; /**节点值*/ private Object bean; /**子节点*/ private List&lt;BeanTreeNode&gt; childNodes; /** * @param parentNode * @param nodeType * @param bean * @param childNodes */ public BeanTreeNode(BeanTreeNode parentNode, String nodeType, Object bean) &#123; this.parentNode = parentNode; this.nodeType = nodeType; this.bean = bean; this.childNodes = new ArrayList&lt;BeanTreeNode&gt;(); this.id = UUID.randomUUID().toString().replaceAll("-", ""); if (parentNode != null) &#123; this.pid = parentNode.getId(); &#125; &#125; /** * @return the nodeType */ public String getNodeType() &#123; return nodeType; &#125; /** * @param nodeType the nodeType to set */ public void setNodeType(String nodeType) &#123; this.nodeType = nodeType; &#125; /** * @return the parentNode */ public BeanTreeNode getParentNode() &#123; return parentNode; &#125; /** * @param parentNode the parentNode to set */ public void setParentNode(BeanTreeNode parentNode) &#123; this.parentNode = parentNode; &#125; /** * @return the bean */ public Object getBean() &#123; return bean; &#125; /** * @param bean the bean to set */ public void setBean(Object bean) &#123; this.bean = bean; &#125; /** * @return the childNodes */ public List&lt;BeanTreeNode&gt; getChildNodes() &#123; return childNodes; &#125; /** * @param childNodes the childNodes to set */ public void setChildNodes(List&lt;BeanTreeNode&gt; childNodes) &#123; this.childNodes = childNodes; &#125; /** * @return the id */ public String getId() &#123; return id; &#125; /** * @param id the id to set */ public void setId(String id) &#123; this.id = id; &#125; /** * @return the pid */ public String getPid() &#123; return pid; &#125; /** * @param pid the pid to set */ public void setPid(String pid) &#123; this.pid = pid; &#125; /** * 是否具有子节点 * @return true or false */ public boolean haveChild() &#123; return !CollectionUtils.isEmpty(childNodes); &#125;&#125; 树形结构类BeanTree.javaBeanTree.java里面包含了如下的一些常用操作： 返回根节点 返回最后添加节点 判断是否具有子节点 添加节点 移动节点到其他节点下 获取对应nodeType的所有节点或实体 根据实体获取节点 获取父节点 转化为map结构 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315import java.util.ArrayList;import java.util.Collection;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.collections.CollectionUtils;/** * 实体树形结构 * BeanTree * @author BrightLoong * @version 1.0 * */public class BeanTree &#123; /**根节点*/ private BeanTreeNode root; /** * 最新添加的节点 */ private BeanTreeNode currentNode; /** * @return the currentNode */ public BeanTreeNode getCurrentNode() &#123; return currentNode; &#125; /** * @return the root */ public BeanTreeNode getRoot() &#123; return root; &#125; /** * 判断节点是否有子节点. * @param node 要判断的节点 * @return true or false */ public boolean haveChild(BeanTreeNode node) &#123; return CollectionUtils.isEmpty(node.getChildNodes()); &#125; /** * 在父节点上面添加节点，并返回天添加的节点. * @param parentNode 父节点 * @param bean 要添加的bean * @param nodeType 节点类型 * @return 返回包含bean的节点 */ public BeanTreeNode addNode(BeanTreeNode parentNode, Object bean, String nodeType) &#123; BeanTreeNode node; if (bean == null) &#123; return null; &#125; //如果没有父节点说明为root根节点 if (parentNode == null) &#123; node = root = new BeanTreeNode(null, nodeType, bean); &#125; else &#123; //创建子节点，并添加到父节点上 node = new BeanTreeNode(parentNode, nodeType, bean); parentNode.getChildNodes().add(node); &#125; currentNode = node; return node; &#125; /** * 将当期bean-sBean,以及sBean下的子Bean，挂到dBean下 * @param sBean 源Bean * @param dBean 目的父Bean */ public void removeTo(Object sBean, Object dBean) &#123; BeanTreeNode sNode = getNodeByBean(sBean); BeanTreeNode dNode = getNodeByBean(dBean); removeTo(sNode, dNode); &#125; /** * 将当期node-sNode,以及sNode下的子Node，挂到dNode下 * @param sNode 源node * @param dNode 目的父node */ public void removeTo(BeanTreeNode sNode, BeanTreeNode dNode) &#123; //从当前父节点移除sNode sNode.getParentNode().getChildNodes().remove(sNode); //将sNode移到dNode下 dNode.getChildNodes().add(sNode); //修改sNode的父Id和父节点 sNode.setPid(dNode.getId()); sNode.setParentNode(dNode); &#125; /** * 获取父bean. * @param bean 子bean * @return 返回父bean */ public Object getParentBean(Object bean) &#123; return getNodeByBean(bean).getParentNode().getBean(); &#125; /** * 根据传入的bean获取bean下面对应类型的子bean. * @param bean 当前bean * @param nodeType 节点类型 * @return 子bean的集合 */ public List&lt;Object&gt; getBeanListByBeanAndNodeType(Object bean, String nodeType) &#123; BeanTreeNode node = getNodeByBean(bean); return getBeanListByNodeType(node, nodeType); &#125; /** * 根据传入的bean获取包含bean的Node节点 * @param node 当前node * @param bean 要查找的bean * @return node节点 */ public BeanTreeNode getNodeByBean(BeanTreeNode node, Object bean) &#123; BeanTreeNode resultNode = null; if (node.getBean().equals(bean)) &#123; resultNode = node; return resultNode; &#125; else &#123; for (BeanTreeNode tempNode : node.getChildNodes()) &#123; resultNode = getNodeByBean(tempNode, bean); if (resultNode != null) &#123; break; &#125; &#125; &#125; return resultNode; &#125; /** * 根据传入的bean获取root节点下包含bean的Node节点 * @param bean 要查找的bean * @return node节点 */ public BeanTreeNode getNodeByBean(Object bean) &#123; return getNodeByBean(root, bean); &#125; /** * 根据节点类型返回当前节点下对应节点类型的bean的list集合. * 默认如果当前节点满足类型，那么当前节点不会存在相同类型的子节点 * @param node 当前节点 * @param nodeType 节点类型 * @return */ @SuppressWarnings("unchecked") public &lt;T&gt; List&lt;T&gt; getBeanListByNodeType(BeanTreeNode node, String nodeType) &#123; List&lt;T&gt; beanList = new ArrayList&lt;T&gt;(); if (node.getNodeType().equals(nodeType)) &#123; beanList.add((T)node.getBean()); &#125; else &#123; for (BeanTreeNode tempNode : node.getChildNodes()) &#123; beanList.addAll((Collection&lt;? extends T&gt;) getBeanListByNodeType(tempNode, nodeType)); &#125; &#125; return beanList; &#125; /** * 根据节点类型返回根节点下对应节点类型的bean的list集合. * @param nodeType 节点类型 * @return */ public &lt;T&gt; List&lt;T&gt; getBeanListByNodeType(String nodeType) &#123; return getBeanListByNodeType(root, nodeType); &#125; /** * 从root节点开始获取对应nodeType的node. * @param nodeType 节点类型 * @return nodeType类型的节点集合 */ public List&lt;BeanTreeNode&gt; getNodeListByNodeType(String nodeType) &#123; return getNodeListByNodeType(root, nodeType); &#125; /** * 从node节点开始获取对应nodeType的node. * @param node node节点 * @param nodeType 节点类型 * @return nodeType类型的节点集合 */ public List&lt;BeanTreeNode&gt; getNodeListByNodeType(BeanTreeNode node, String nodeType) &#123; List&lt;BeanTreeNode&gt; nodeList = new ArrayList&lt;BeanTreeNode&gt;(); if(node==null)&#123; return nodeList; &#125; if (nodeType.equals(node.getNodeType())) &#123; nodeList.add(node); &#125; else &#123; for (BeanTreeNode tempNode : node.getChildNodes()) &#123; nodeList.addAll(getNodeListByNodeType(tempNode, nodeType)); &#125; &#125; return nodeList; &#125; /** * 将树形结构转化为map. * @return */ public Map&lt;String, List&lt;Object&gt;&gt; toMap() &#123; return toMap(root); &#125; /** * 将对应节点及其子节点转化为map. * @param node 树节点 * @return 转化后的map */ public Map&lt;String, List&lt;Object&gt;&gt; toMap(BeanTreeNode node) &#123; Map&lt;String, List&lt;Object&gt;&gt; map = new HashMap&lt;String, List&lt;Object&gt;&gt;(); toMap(node, map); return map; &#125; /** * 根据传入的nodeType删除对应的节点以及其所有子节点. * @param nodeType */ public void delNodeByNodeType(String nodeType) &#123; delNodeByNodeType(root, nodeType); &#125; /** * 删除node节点下，类型为nodeType的节点和所有子节点 * @param node * @param nodeType */ public void delNodeByNodeType(BeanTreeNode node, String nodeType) &#123; List&lt;BeanTreeNode&gt; nodeList = getNodeListByNodeType(node, nodeType); for (BeanTreeNode beanTreeNode : nodeList) &#123; beanTreeNode.getParentNode().getChildNodes().remove(beanTreeNode); &#125; &#125; /** * 从树结构里面删除bean和相关node. * @param bean bean */ public void delNodeByBean(Object bean) &#123; BeanTreeNode node = getNodeByBean(bean); BeanTreeNode parentNode = node.getParentNode(); List&lt;BeanTreeNode&gt; childNodes = parentNode.getChildNodes(); Iterator&lt;BeanTreeNode&gt; it = childNodes.iterator(); while (it.hasNext()) &#123; BeanTreeNode beanTreeNode = it.next(); if (node == beanTreeNode) &#123; it.remove(); &#125; &#125; &#125; /** * 根据class返回对应的beanList. * @param cls class * @return beanList */ public &lt;T&gt; List&lt;Object&gt; getBeanListByClass(Class&lt;T&gt; cls) &#123; return getBeanListByClass(root, cls); &#125; /** * 根据class返回对应的beanList. * @param node 节点 * @param cls class * @return beanList */ public &lt;T&gt; List&lt;Object&gt; getBeanListByClass(BeanTreeNode node, Class&lt;T&gt; cls) &#123; List&lt;Object&gt; beanList = new ArrayList&lt;Object&gt;(); Object bean = node.getBean(); if (cls.isAssignableFrom(bean.getClass())) &#123; beanList.add(bean); &#125; List&lt;BeanTreeNode&gt; childNodes = node.getChildNodes(); for (BeanTreeNode beanTreeNode : childNodes) &#123; beanList.addAll(getBeanListByClass(beanTreeNode, cls)); &#125; return beanList; &#125; /** * 将对应节点及其子节点转化为map. * @param node 树节点 * @param map 用来保存结果的map */ private void toMap(BeanTreeNode node, Map&lt;String, List&lt;Object&gt;&gt; map) &#123; String key = node.getNodeType(); Object bean = node.getBean(); if (map.containsKey(key)) &#123; map.get(key).add(bean); &#125; else &#123; List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); list.add(bean); map.put(key, list); &#125; for (BeanTreeNode tempNode : node.getChildNodes()) &#123; toMap(tempNode, map); &#125; &#125;&#125; 测试树形工具使用上面的xml进行测试，这里就不再做xml映射，假设存在上面xml所示的所有实体，“school-one”和“school-two”以及5个student，看看能否构造出想要的结构，测试类代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class SchoolInf &#123; private String msg; public SchoolInf(String msg) &#123; this.msg = msg; &#125;&#125;class Student &#123; private String name; public Student(String name) &#123; this.name = name; &#125;&#125;class School &#123; private String name; public School(String name) &#123; this.name = name; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; SchoolInf schoolInf = new SchoolInf("2017-10-1XX省学校信息总汇"); School school_one = new School("school-one"); School school_two = new School("school-two"); Student Jack = new Student("Jack"); Student Rose = new Student("Rose"); Student Jon = new Student("Jon"); Student Bob = new Student("Bob"); Student Alisa = new Student("Alisa"); BeanTree tree = new BeanTree(); BeanTreeNode root = tree.addNode(null, schoolInf, "root"); BeanTreeNode school_node1 = tree.addNode(root, school_one, "school"); BeanTreeNode school_node2 = tree.addNode(root, school_two, "school"); tree.addNode(school_node1, Jack, "root"); tree.addNode(school_node1, Rose, "root"); tree.addNode(school_node1, Jon, "root"); tree.addNode(school_node2, Bob, "root"); tree.addNode(school_node2, Alisa, "root"); System.out.println("end"); &#125;&#125; 我们通过调试观察树结构变量“tree”的值如下： 可以看出来能够构造出正确的结构，BeanTree中其他的一些方法这里就不在一一测试了。 更新记录 2018/1/10，在BeanTree中添加更多的操作方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java项目间通过文件调用方法工具（frequest）]]></title>
    <url>%2F2017%2F09%2F19%2FJava%E9%A1%B9%E7%9B%AE%E9%97%B4%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一.简介frequest：这是一个用JAVA编写的，可以通过文件进行方法调用请求传输的工具。 项目gitgub地址：https://github.com/BrightLoong/frequest 二.背景之前在项目中遇到一下的需求，如图所示: 甲处要访问部署在乙处的服务serverB(因为数据库在乙处)，不过因为一些限制原因导致甲乙两地的网络不通。但是甲乙两地之间有一个文件传输的系统仅仅可以进行文件的传输交换。 基于以上的条件，考虑在甲地也搭建一个同样的服务serverA（A和B相同，并都加入对请求的处理），。但是过滤它对service层的调用，将方法调用放入文件中（也就是请求文件中），然后将文件发送到乙地对应目录（文件发送的功能并不由这两个系统负责）。serverB将解析文件的请求，调用对应方法，并将结果也存到文件中发送到甲的服务器serveA处，实现请求的响应。 这里把拦截本地方法调用，生请求文件，等待远端返回结果和远端响应文件请求并将结果生成问文件的功能抽取出来，并对这部分功能进行了提炼重构，修改了一些问题，形成了工具frquest(file-request)。 三.具体思路 甲：本地服务，需要点去远端服务乙 乙：远端服务，可自己访问自己，亦可以接收甲的请求 甲处发起请求，调用了方法，使用aspectj对方法调用进行拦截 对拦截到的方法进行解析，记录下调用方法名，参数，类，接口等信息，并将信息放入传输bean生成json字符串，写入到文件 把生成的请求文件发送到指定目录，并等待远端返回结果 …… 乙远端扫描到请求文件，开始远端方法调用 对文件进行解析，反过来转为json字符串，再转为传输Bean，从中获取方法名，参数等信息，进行一定的处理。使用反射（invok）调用方法，把得到的结果放入传输Bean中，转为json字符串放入结果文件，发送到指定目录 …… 甲检测到结果文件，转为json字符串，再转为传输Bean，获取结果信息。 四. 使用可在java项目中使用。 1. 引用 直接下载jar包，下载地址http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22frequest%22 使用maven的方式引用 12345&lt;dependency&gt; &lt;groupId&gt;io.github.brightloong&lt;/groupId&gt; &lt;artifactId&gt;frequest&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 注：如果是java项目需要继承aspectj环境，如果是集成了spring的web项目需要开启aspectj支持 2. 配置发送接收文件的目录请求端的发送目录是指拦截请求生成的请求文件，接收目录是指发送请求后等待接收的结果文件的目录。 远端的发送目录是值生成的结果文件的发送目录，接收目录是指扫描请求端的请求文件的目录。 项目中使用了xml配置的方式，格式如下。 注：本工具不负责文件的传输，所以如果想用该工具在本机做测试，可以把远端和请求端的send-path和receive-path交替配置 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configs&gt; &lt;config&gt; &lt;send-path&gt;d:\send&lt;/send-path&gt; &lt;receive-path&gt;d:\receive&lt;/receive-path&gt; &lt;/config&gt; &lt;!--远端可以配置多个config，可能会有多个请求端需要同一个远端响应,请求端配置多个也默认只取第一个--&gt; &lt;config&gt; &lt;send-path&gt;d:\send&lt;/send-path&gt; &lt;receive-path&gt;d:\receive&lt;/receive-path&gt; &lt;/config&gt;&lt;/configs&gt; 3. 请求端（被拦截端）配置 同样首先需要配置收发文件目录（也就是上面说的xml） 如果是简单的java项目可使用下面的方式启动。 继承ServiceProxyInterceptor并且实现serviceAroundImpl()方法 在实现方法类调用父类的serviceAround() 标注上@Around注解 在Around里面加入切入点，PointConstants.POINT_SERVICE是在工具中定义的一个切入点，也就是对具有自定义注解 @ServiceProxy的方法进行拦截，也可以定义自己的切入点。 启动frequest功能，如下mian()方法中前两行代码所示。 如下，如果要对say()方法进行拦截，则加上 @ServiceProxy注解(前提是你使用了定义的切入点PointConstants.POINT_SERVICE，并且要保证请求端和远端拥有相同的方法，包括方法所在的类和包) 1234567891011121314151617181920212223@Aspectpublic class Test extends ServiceProxyInterceptor&#123; @Override @Around(PointConstants.POINT_SERVICE) public Object serviceAroundImpl(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; return super.serviceAround(proceedingJoinPoint); &#125; @ServiceProxy public String say(String msg) &#123; System.out.println(msg); return msg; &#125; public static void main(String[] args) &#123; //setIsRemote(false),设置为请求端，并设置xml的目录。 NormalConfig.getInstance().setXmlConfigPath("com/test/xml/config.xml").setIsRemote(false); //开启frequest功能 StartEngine.start(); Test test = new Test(); System.out.println(test.say("hello")); &#125;&#125; 4. 远端（相应文件请求端）配置 同样首先需要配置收发文件目录（也就是上面说的xml） 如果是简单的java项目可使用下面的方式启动。如果是web项目，同样也是调用mian()方法中的两行代码，保证其能在合适的地方进行调用，启动功能。 12345678public class Start &#123; public static void main(String[] args) &#123; //setIsRemote(true),设置为远端，并设置xml的目录。 NormalConfig.getInstance().setIsRemote(true).setXmlConfigPath("com/test/xml/config.xml"); //开启frequest功能 StartEngine.start(); &#125;&#125; ​ ​ 5. 其他配置下面的配置具有默认值，所以不进行配置也是可以的。 sleepTime：休眠时间，单位ms，扫描文件变动的间隔时间和等待远端返回结果的每次等待时间，默认是100ms。 waitCount：请求端等待远端返回结果的次数，每次间隔时间为sleepTime，所以总共等待时间为waitCount*sleepTime(ms)。默认等待次数是300次 12//设置休眠时间sleepTime,设置等待结果次数300次 NormalConfig.getInstance().setSleepTime(100).setWaitCount(300); 五. LICENSE遵循Apache License 2.0]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>frequest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组->JSON字符串->数组过程中的问题]]></title>
    <url>%2F2017%2F09%2F03%2F%E6%95%B0%E7%BB%84-JSON%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%95%B0%E7%BB%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[之前在使用 alibaba的fastjson做数组的相关转换操作的时候遇到一些问题，这里把遇到的问题以及如何解决的记录如下。 一. 转换过程中的问题话不多说，先上代码。 12345678910111213public class JsonTest &#123; public static void main(String[] args) &#123; //创建一个String数组 String[][] stringArray = new String[][]&#123;&#123;"1","2","3"&#125;,&#123;"4","5","6"&#125;&#125;; //使用fastjson转为json字符串 String jsonString = JSON.toJSONString(stringArray); System.out.println(jsonString); //解析json字符串后输出class发现是jsonArray的。 Object array = JSON.parse(jsonString); System.out.println(array.getClass()); &#125;&#125; 输出结果是： 123Before class:class [[Ljava.lang.String;[["1","2","3"],["4","5","6"]]After class:class com.alibaba.fastjson.JSONArray 遇到的问题如上，把一个数组转为json字符串后，再使用用JSON.parse()转换回来，获取到的class类型却是JSONArray的。 当然你也可以用很简单的办法把他给转换成需要的String二维数组。不过我的需求是： 只知道是个数组，知道到数组的原始Class类型(如果是String[][]知道是String.class) 不知道是几维数组，也不知道最开始传入的数组的长度 在拿到从Json字符串转换回来的object的时候，必须要使用原始类型(比如是String[][],那么转换回来的object，使用object.getClass()应该得到[[Ljava.lang.String)，否则无法使用。 为了解决上述问题，在网上查阅各种资料无果，最后突然想到查询数组的反射，找到了java.lang.reflect.Array这个包，下面对这个包里面的一些使用做一个简单的介绍。 二. 关于java.lang.reflect.Array同样先上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class ArrayTest &#123; /** * 创建一维数组. * @param cls 数组基本类型Class * @param length 创建数组长度 * @return 创建的数组 */ public static Object creatOneDimArray(Class cls, int length) &#123; return Array.newInstance(cls, length); &#125; /** * 创建多维数组. * @param cls 数组基本类型Class * @param dims 维度信息 * @return 创建的数组 */ public static Object creatMultiDimsArray(Class cls, int[] dims) &#123; return Array.newInstance(cls, dims); &#125; /** * 获取数组的长度和class信息. * @param array 使用Array.newInstance()创建的array * @return 长度和class信息 */ public static String getArrayInfo(Object array) &#123; Class cls = array.getClass(); //只会返回第一维度的长度，比如String[1][2][3]返回1，String[3][4]返回3 int length = Array.getLength(array); return "CLASS:" + cls + "-----" + "LENGTH:" + length; &#125; public static void main(String[] args) &#123; //创建长度为10的一维String数组 Object oneArray = creatOneDimArray(String.class, 10); System.out.println(getArrayInfo(oneArray)); //创建一个[2,3,4]的二维String数组 int[] dims = new int[]&#123;2,3,4&#125;; Object threeArray = creatMultiDimsArray(String.class,dims); System.out.println(getArrayInfo(threeArray)); //************************** //* 数组赋值操作 * //************************** //---------1.强制转换赋值 ((String[])oneArray)[1] = "hello"; ((String[])oneArray)[9] = " world"; System.out.println(((String[])oneArray)[1] + ((String[])oneArray)[9]); ((String[][][])threeArray)[1][2][3] = "hello"; ((String[][][])threeArray)[0][1][3] = " java"; System.out.println(((String[][][])threeArray)[1][2][3] + ((String[][][])threeArray)[0][1][3]); //--------2.使用Array.set()进行赋值操作 //使用Array.get()可以获取到下一维的值，比如三维的获取到二维 //获取三维中index=1的二维数组，Strign[1][][]。 Object two = Array.get(threeArray,1); //从输出可以看到获取到的是一个二维数组 System.out.println("CLASS:" + two.getClass()); //对String[1][0][]赋值 Array.set(two,0,new String[]&#123;"this"," is"," a"," test"&#125;); System.out.println(((String[][][])threeArray)[1][0][0] + ((String[][][])threeArray)[1][0][1] + ((String[][][])threeArray)[1][0][2] + ((String[][][])threeArray)[1][0][3]); //再获取一维String[1][1][] Object one = Array.get(two,1); System.out.println("CLASS:" + one.getClass()); Array.set(one,0,"my"); Array.set(one,1," name"); Array.set(one,2," is"); Array.set(one,3," brightloong"); System.out.println(((String[][][])threeArray)[1][1][0] + ((String[][][])threeArray)[1][1][1] + ((String[][][])threeArray)[1][1][2] + ((String[][][])threeArray)[1][1][3]); &#125;&#125; 输出结果是： 12345678CLASS:class [Ljava.lang.String;-----LENGTH:10CLASS:class [[[Ljava.lang.String;-----LENGTH:2hello worldhello javaCLASS:class [[Ljava.lang.String;this is a testCLASS:class [Ljava.lang.String;my name is brightloong 这里已经在上述代码中做了大部分的注释，这里也不在详细介绍，主要说一下几个方法的作用。 Array.newInstance(Class&lt;?&gt; componentType, int length)和Array.newInstance(Class&lt;?&gt; componentType, int... dimensions)第一个用于创建传入类型的长度为length的一维数组，第二个可以用于创建传入类型的多维数组，维度和长度由传入的第二个参数决定。 Array.get(Object array, int index)用于获取传入的数组array的index下的内容。 Array.set(Object array, int index, Object value)用于对传入的数组array的index进行赋值，赋值为value，具体使用见上述的代码。 三. 如何解决转换问题在具备了以上的了解后，再来解决所遇到的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class JsonArrayToArray &#123; public static void main(String[] args) &#123; //创建一个String数组 String[][] stringArray = new String[][]&#123;&#123;"1","2","3"&#125;,&#123;"4","5","6"&#125;&#125;; //使用fastjson转为json字符串 String jsonString = JSON.toJSONString(stringArray); System.out.println(jsonString); //解析json字符串后输出class发现是jsonArray的。 Object array = JSON.parse(jsonString); System.out.println(array.getClass()); Object realArray = null; try &#123; realArray = getArrayInstanceByClassAndArg(String.class, array); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; parseJsonArray(array, realArray); System.out.println(realArray.getClass()); System.out.println(realArray.getClass().equals(String[][].class)); &#125; /** * 解析jsonArray还原为最开始的数组 * @param o 解析后的类型是jsonArray的参数 * @param array 实际要组装的数组 */ private static void parseJsonArray(Object o, Object array) &#123; parseJsonArray(o, array, null, 0); &#125; /** * 利用递归调用，解析jsonArray还原为最开始的数组 * @param o 解析后的类型是jsonArray的参数 * @param array 实际要组装的数组 * @param lastArray 上一个array * @param index index */ private static void parseJsonArray(Object o, Object array, Object lastArray, int index) &#123; JSONArray tempArray; //如果class不是JSONArray，使用Array.set()赋值 if (!o.getClass().equals(JSONArray.class)) &#123; Array.set(lastArray,index , o); return; &#125; //如果是JSONArray,继续继续循环递归调用 tempArray = (JSONArray)o; for (int i = 0; i &lt; tempArray.size(); i++) &#123; Object arrayTemp = Array.get(array, i); parseJsonArray(tempArray.get(i), arrayTemp, array, i); &#125; &#125; /** * 根据class和传入的解析后的类型是jsonArray的参数，获取对应维度和大小的数组 * @param cls Class * @param argValue 解析后的类型是jsonArray的参数 * @return 返回数组 * @throws ClassNotFoundException 异常 */ private static Object getArrayInstanceByClassAndArg(Class cls, Object argValue) throws ClassNotFoundException &#123; Object temp = argValue; JSONArray tempArray; List&lt;Integer&gt; dimsInf = new ArrayList&lt;Integer&gt;(); //获取jsonArray对应的数组维度和长度 while (temp.getClass().equals(JSONArray.class)) &#123; tempArray = (JSONArray)temp; dimsInf.add(tempArray.size()); temp = tempArray.get(0); &#125; int[] dims = new int[dimsInf.size()]; for (int i = 0; i &lt; dimsInf.size(); i++) &#123; dims[i] = dimsInf.get(i); &#125; //返回对应的数组 return Array.newInstance(cls, dims); &#125;&#125; 输出结果是： 1234[["1","2","3"],["4","5","6"]]class com.alibaba.fastjson.JSONArrayclass [[Ljava.lang.String;true 可以看到最后被将转换后的Class为JSONArray的结果在转换为最初的数组类型，String[][]，由最后realArray.getClass().equals(String[][].class)返回结果true也可以得到确实转换正确了。具体的解析方法可以看上面的parseJsonArray()方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JSONArray转数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Commons FileUpload]]></title>
    <url>%2F2017%2F07%2F24%2FApache-Commons-FileUpload%2F</url>
    <content type="text"><![CDATA[Apache Commons FileUpload是用于解析上传文件的包。这里将其一些简单的特性和使用进行一个大概的介绍。 一.简介用于解析上传的文件，”Form-based File Upload in HTML”。也就是说,如果使用POST方法提交HTTP请求,并且使用内容类型“multipart / form-data”,则FileUpload可以解析该请求。 二.简单使用1.满足的条件 form表单使用POST请求,并且form表单的内容格式要定义成multipart/form-data格式 form表单内，要添加空间&lt;input type=&quot;file&quot; name=&quot;&quot;&gt;或者其他的比如：Uploadify插件 123456&lt;form method="POST" enctype="multipart/form-data" action="fup.cgi"&gt; File to upload: &lt;input type="file" name="upfile"&gt;&lt;br/&gt; Notes about the file: &lt;input type="text" name="note"&gt;&lt;br/&gt; &lt;br/&gt; &lt;input type="submit" value="Press"&gt; to upload the file!&lt;/form&gt; 2.具体使用 使用前判断是否有上传文件的请求 12// Check that we have a file upload requestboolean isMultipart = ServletFileUpload.isMultipartContent(request); 简单的例子 12345678910111213// Create a factory for disk-based file itemsDiskFileItemFactory factory = new DiskFileItemFactory();// Configure a repository (to ensure a secure temp location is used)，默认会放在System.getProperty("java.io.tmpdir")ServletContext servletContext = this.getServletConfig().getServletContext();File repository = (File) servletContext.getAttribute("javax.servlet.context.tempdir");factory.setRepository(repository);// Create a new file upload handlerServletFileUpload upload = new ServletFileUpload(factory);// Parse the requestList&lt;FileItem&gt; items = upload.parseRequest(request); 加入一些控制的例子 12345678910111213141516// Create a factory for disk-based file itemsDiskFileItemFactory factory = new DiskFileItemFactory();// Set factory constraints//默认为10k，小于这个值的会放在内容中，否则放在设置的disk路径下factory.setSizeThreshold(yourMaxMemorySize);factory.setRepository(yourTempDirectory);// Create a new file upload handlerServletFileUpload upload = new ServletFileUpload(factory);// Set overall request size constraint，最大上传文件upload.setSizeMax(yourMaxRequestSize);// Parse the requestList&lt;FileItem&gt; items = upload.parseRequest(request); 也可以一并配置多个属性 12// Create a factory for disk-based file itemsDiskFileItemFactory factory = new DiskFileItemFactory(yourMaxMemorySize, yourTempDirectory); 获取上传的文件信息 123456789// Process a file uploadif (!item.isFormField()) &#123; String fieldName = item.getFieldName(); String fileName = item.getName(); String contentType = item.getContentType(); boolean isInMemory = item.isInMemory(); long sizeInBytes = item.getSize(); ...&#125; 保存文件前获取文件的一些方式 123456789// Process a file uploadif (writeToFile) &#123; File uploadedFile = new File(...); item.write(uploadedFile);&#125; else &#123; InputStream uploadedStream = item.getInputStream(); ... uploadedStream.close();&#125; OR 123// Process a file upload in memorybyte[] data = item.get();... 三.清理文件仅仅适用于DiskFileItem,也就是说在上传前，文件被写入了临时文件，如果不再使用这些临时文件，则需要删除这些临时文件。DiskFileItemFactory有一个属性FileCleaningTracker，设置这个属性可以用来追踪删除临时文件。当这个临时文件不再被使用时将会被立即删除，更精确的说是这个文件对象被垃圾收集器回收时，FileCleaningTracker将启动收割者线程(reaper thread)自动删除这个临时文件。 为了确保这个后台线程在它不再被需要时被停止，在 servlet 环境里，我们通过一个名叫 FileCleanerCleanup 的 servlet 上下文监听器，在web应用关闭时调用FileCleaningTracker.exitWhenFinished()来终止收割机线程。在servlet环境中，使用 FileCleanerCleanup,FileCleanerCleanup提供了FileCleaningTracker的一个实例，要让FileCleanerCleanup监听器工作，你需要在 web.xml 增加如下代码：。 123456789&lt;web-app&gt; ... &lt;listener&gt; &lt;listener-class&gt; org.apache.commons.fileupload.servlet.FileCleanerCleanup &lt;/listener-class&gt; &lt;/listener&gt; ...&lt;/web-app&gt; 在使用FileCleanerCleanup,应该像下面这样创建DiskFileItemFactory1234567891011public static DiskFileItemFactory newDiskFileItemFactory(ServletContext context, File repository) &#123; //FileCleaningTracker类，这个类用于跟踪要删除的文件 FileCleaningTracker fileCleaningTracker = FileCleanerCleanup.getFileCleaningTracker(context); DiskFileItemFactory factory = new DiskFileItemFactory(DiskFileItemFactory.DEFAULT_SIZE_THRESHOLD, repository); factory.setFileCleaningTracker(fileCleaningTracker); return factory;&#125; 四.上传进度下面是一个创建进度监听的一个例子12345678910111213//Create a progress listenerProgressListener progressListener = new ProgressListener()&#123; public void update(long pBytesRead, long pContentLength, int pItems) &#123; System.out.println("We are currently reading item " + pItems); if (pContentLength == -1) &#123; System.out.println("So far, " + pBytesRead + " bytes have been read."); &#125; else &#123; System.out.println("So far, " + pBytesRead + " of " + pContentLength + " bytes have been read."); &#125; &#125;&#125;;upload.setProgressListener(progressListener); 但是这样会存在问题，有可能会被频繁的调用而造成性能问题。123456789101112131415161718//Create a progress listenerProgressListener progressListener = new ProgressListener()&#123; private long megaBytes = -1; public void update(long pBytesRead, long pContentLength, int pItems) &#123; long mBytes = pBytesRead / 1000000; if (megaBytes == mBytes) &#123; return; &#125; megaBytes = mBytes; System.out.println("We are currently reading item " + pItems); if (pContentLength == -1) &#123; System.out.println("So far, " + pBytesRead + " bytes have been read."); &#125; else &#123; System.out.println("So far, " + pBytesRead + " of " + pContentLength + " bytes have been read."); &#125; &#125;&#125;; 如果想在页面展示，可以自己实现一个ProgressListener接口，将进度的相关信息放在session中。通过ajax之类的进行调用。具体可以参照博客– Common-FileUpload带进度条上传]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>apache commons</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现一个简单的缓存]]></title>
    <url>%2F2017%2F04%2F17%2FJAVA%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;缓存是在web开发中经常用到的，将程序经常使用到或调用到的对象存在内存中，或者是耗时较长但又不具有实时性的查询数据放入内存中，在一定程度上可以提高性能和效率。下面我实现了一个简单的缓存，步骤如下。 创建缓存对象EntityCache.java123456789101112131415161718192021222324252627282930313233343536373839404142public class EntityCache &#123; /** * 保存的数据 */ private Object datas; /** * 设置数据失效时间,为0表示永不失效 */ private long timeOut; /** * 最后刷新时间 */ private long lastRefeshTime; public EntityCache(Object datas, long timeOut, long lastRefeshTime) &#123; this.datas = datas; this.timeOut = timeOut; this.lastRefeshTime = lastRefeshTime; &#125; public Object getDatas() &#123; return datas; &#125; public void setDatas(Object datas) &#123; this.datas = datas; &#125; public long getTimeOut() &#123; return timeOut; &#125; public void setTimeOut(long timeOut) &#123; this.timeOut = timeOut; &#125; public long getLastRefeshTime() &#123; return lastRefeshTime; &#125; public void setLastRefeshTime(long lastRefeshTime) &#123; this.lastRefeshTime = lastRefeshTime; &#125; &#125; 定义缓存操作接口，ICacheManager.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public interface ICacheManager &#123; /** * 存入缓存 * @param key * @param cache */ void putCache(String key, EntityCache cache); /** * 存入缓存 * @param key * @param cache */ void putCache(String key, Object datas, long timeOut); /** * 获取对应缓存 * @param key * @return */ EntityCache getCacheByKey(String key); /** * 获取对应缓存 * @param key * @return */ Object getCacheDataByKey(String key); /** * 获取所有缓存 * @param key * @return */ Map&lt;String, EntityCache&gt; getCacheAll(); /** * 判断是否在缓存中 * @param key * @return */ boolean isContains(String key); /** * 清除所有缓存 */ void clearAll(); /** * 清除对应缓存 * @param key */ void clearByKey(String key); /** * 缓存是否超时失效 * @param key * @return */ boolean isTimeOut(String key); /** * 获取所有key * @return */ Set&lt;String&gt; getAllKeys();&#125; 实现接口ICacheManager，CacheManagerImpl.java&emsp;&emsp;这里我使用了ConcurrentHashMap来保存缓存，本来以为这样就是线程安全的，其实不然，在后面的测试中会发现它并不是线程安全的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class CacheManagerImpl implements ICacheManager &#123; private static Map&lt;String, EntityCache&gt; caches = new ConcurrentHashMap&lt;String, EntityCache&gt;(); /** * 存入缓存 * @param key * @param cache */ public void putCache(String key, EntityCache cache) &#123; caches.put(key, cache); &#125; /** * 存入缓存 * @param key * @param cache */ public void putCache(String key, Object datas, long timeOut) &#123; timeOut = timeOut &gt; 0 ? timeOut : 0L; putCache(key, new EntityCache(datas, timeOut, System.currentTimeMillis())); &#125; /** * 获取对应缓存 * @param key * @return */ public EntityCache getCacheByKey(String key) &#123; if (this.isContains(key)) &#123; return caches.get(key); &#125; return null; &#125; /** * 获取对应缓存 * @param key * @return */ public Object getCacheDataByKey(String key) &#123; if (this.isContains(key)) &#123; return caches.get(key).getDatas(); &#125; return null; &#125; /** * 获取所有缓存 * @param key * @return */ public Map&lt;String, EntityCache&gt; getCacheAll() &#123; return caches; &#125; /** * 判断是否在缓存中 * @param key * @return */ public boolean isContains(String key) &#123; return caches.containsKey(key); &#125; /** * 清除所有缓存 */ public void clearAll() &#123; caches.clear(); &#125; /** * 清除对应缓存 * @param key */ public void clearByKey(String key) &#123; if (this.isContains(key)) &#123; caches.remove(key); &#125; &#125; /** * 缓存是否超时失效 * @param key * @return */ public boolean isTimeOut(String key) &#123; if (!caches.containsKey(key)) &#123; return true; &#125; EntityCache cache = caches.get(key); long timeOut = cache.getTimeOut(); long lastRefreshTime = cache.getLastRefeshTime(); if (timeOut == 0 || System.currentTimeMillis() - lastRefreshTime &gt;= timeOut) &#123; return true; &#125; return false; &#125; /** * 获取所有key * @return */ public Set&lt;String&gt; getAllKeys() &#123; return caches.keySet(); &#125;&#125; CacheListener.java,监听失效数据并移除。1234567891011121314151617181920212223public class CacheListener&#123; Logger logger = Logger.getLogger("cacheLog"); private CacheManagerImpl cacheManagerImpl; public CacheListener(CacheManagerImpl cacheManagerImpl) &#123; this.cacheManagerImpl = cacheManagerImpl; &#125; public void startListen() &#123; new Thread()&#123; public void run() &#123; while (true) &#123; for(String key : cacheManagerImpl.getAllKeys()) &#123; if (cacheManagerImpl.isTimeOut(key)) &#123; cacheManagerImpl.clearByKey(key); logger.info(key + "缓存被清除"); &#125; &#125; &#125; &#125; &#125;.start(); &#125;&#125; 测试类TestCache.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TestCache &#123; Logger logger = Logger.getLogger("cacheLog"); /** * 测试缓存和缓存失效 */ @Test public void testCacheManager() &#123; CacheManagerImpl cacheManagerImpl = new CacheManagerImpl(); cacheManagerImpl.putCache("test", "test", 10 * 1000L); cacheManagerImpl.putCache("myTest", "myTest", 15 * 1000L); CacheListener cacheListener = new CacheListener(cacheManagerImpl); cacheListener.startListen(); logger.info("test:" + cacheManagerImpl.getCacheByKey("test").getDatas()); logger.info("myTest:" + cacheManagerImpl.getCacheByKey("myTest").getDatas()); try &#123; TimeUnit.SECONDS.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; logger.info("test:" + cacheManagerImpl.getCacheByKey("test")); logger.info("myTest:" + cacheManagerImpl.getCacheByKey("myTest")); &#125; /** * 测试线程安全 */ @Test public void testThredSafe() &#123; final String key = "thread"; final CacheManagerImpl cacheManagerImpl = new CacheManagerImpl(); ExecutorService exec = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 100; i++) &#123; exec.execute(new Runnable() &#123; public void run() &#123; if (!cacheManagerImpl.isContains(key)) &#123; cacheManagerImpl.putCache(key, 1, 0); &#125; else &#123; //因为+1和赋值操作不是原子性的，所以把它用synchronize块包起来 synchronized (cacheManagerImpl) &#123; int value = (Integer) cacheManagerImpl.getCacheDataByKey(key) + 1; cacheManagerImpl.putCache(key,value , 0); &#125; &#125; &#125; &#125;); &#125; exec.shutdown(); try &#123; exec.awaitTermination(1, TimeUnit.DAYS); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; logger.info(cacheManagerImpl.getCacheDataByKey(key).toString()); &#125;&#125; testCacheManager()输出结果如下：1234567891011122017-4-17 10:33:51 io.github.brightloong.cache.TestCache testCacheManager信息: test:test2017-4-17 10:33:51 io.github.brightloong.cache.TestCache testCacheManager信息: myTest:myTest2017-4-17 10:34:01 io.github.brightloong.cache.CacheListener$1 run信息: test缓存被清除2017-4-17 10:34:06 io.github.brightloong.cache.CacheListener$1 run信息: myTest缓存被清除2017-4-17 10:34:11 io.github.brightloong.cache.TestCache testCacheManager信息: test:null2017-4-17 10:34:11 io.github.brightloong.cache.TestCache testCacheManager信息: myTest:null testThredSafe()输出结果如下（选出了各种结果中的一个举例）：122017-4-17 10:35:36 io.github.brightloong.cache.TestCache testThredSafe信息: 96 可以看到并不是预期的结果100，为什么呢？ConcurrentHashMap只能保证单次操作的原子性，但是当复合使用的时候，没办法保证复合操作的原子性，以下代码：123if (!cacheManagerImpl.isContains(key)) &#123; cacheManagerImpl.putCache(key, 1, 0); &#125; 多线程的时候回重复更新value，设置为1，所以出现结果不是预期的100。所以办法就是在CacheManagerImpl.java中都加上synchronized，但是这样一来相当于操作都是串行，使用ConcurrentHashMap也没有什么意义，不过只是简单的缓存还是可以的。或者对测试方法中的run里面加上synchronized块也行，都是大同小异。更高效的方法我暂时也想不出来，希望大家能多多指教。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java静态代理&动态代理笔记]]></title>
    <url>%2F2017%2F03%2F17%2FJava%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在学习Java反射的一些知识，看到了一些有关代理的例子，好记性不如烂笔头，所以这里将它记录下来。接下来话不多说，直接进入主题。 代理：为其他对象提供一个代理以控制对某个对象的访问。 静态代理 接口 123public interface IDoSomething &#123; public int doSometing(int num);&#125; 被代理类的实现 12345678public class Sing implements IDoSomething &#123; @Override public int doSometing(int num) &#123; System.out.println("Sing a song"); return num; &#125;&#125; 代理类的实现 12345678910111213 public class SingProxy implements IDoSomething&#123; private IDoSomething sing = new Sing(); @Override public int doSometing(int num) &#123; System.out.println("Befor singing "); int result = sing.doSometing(num); System.out.println("After singing"); return result; &#125;&#125; 测试类 12345678public class ProxyDemo &#123; public static int sing(IDoSomething sing, int num) &#123; return sing.doSometing(num); &#125; public static void main(String[] args) &#123; System.out.println(ProxyDemo.sing(new SingProxy(), 5)); &#125; &#125; 输出结果 1234Befor singing Sing a songAfter singing5 &emsp;&emsp;以上就是简单的静态代理，不在过多的介绍，下面是动态代理。 动态代理&emsp;&emsp;Java的动态代理可以动态的创建代理并动态的处理对所代理方法的调用。动态代理有两种实现方法，一种是使用JDK自带的，一种是使用Cglib实现。 实现JDK自带的动态代理&emsp;&emsp;实现JDK自带的动态代理，关键是实现InvocationHandler，同时它要求被代理对象必须有接口。下面是实现的代码，我加上了必要的注释。 接口 123public interface IProxyClass &#123; public int doSomething(int i);&#125; 被代理类的实现 1234567public class ProxyClassImpl implements IProxyClass &#123; @Override public int doSomething(int num) &#123; System.out.println("方法执行中....."); return num; &#125;&#125; 实现InvocationHandler接口 &emsp;&emsp;这里我实现了InvocationHandler接口，并手动生成了代理类，保存到了电脑F盘上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class DynamicProxyHandler implements InvocationHandler &#123; private Object proxied; /** * @param proxied 被代理对象 */ public DynamicProxyHandler(Object proxied) &#123; this.proxied = proxied; &#125; /** * 返回代理对象 * @return */ public Object newProxyInstance() &#123; return Proxy.newProxyInstance(proxied.getClass().getClassLoader(), proxied.getClass().getInterfaces(), this); &#125; /** * * @param proxy 代理对象 * @param method 代理方法 * @param args 方法参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //将代理对象生成字节码到F盘上，方便反编译出java文件查看，实际动态代理是不需要自己生成的 addClassToDisk(proxy.getClass().getName(), ProxyClassImpl.class,"F:/$Proxy0.class"); System.out.println("method:"+method.getName()); System.out.println("args:"+args[0].getClass().getName()); System.out.println("Before invoke method..."); Object object=method.invoke(proxied, args); System.out.println("After invoke method..."); return object; &#125; /** * 用于生产代理对象的字节码，并将其保存到硬盘上 * @param className * @param cl * @param path */ private void addClassToDisk(String className, Class&lt;?&gt; cl, String path) &#123; //用于生产代理对象的字节码 byte[] classFile = ProxyGenerator.generateProxyClass(className, cl.getInterfaces()); FileOutputStream out = null; try &#123; out = new FileOutputStream(path); //将代理对象的class字节码写到硬盘上 out.write(classFile); out.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 测试类 123456789public class SimpleProxyDemo &#123; public static void main(String[] args) throws SecurityException, NoSuchMethodException &#123; ProxyClassImpl c = new ProxyClassImpl(); DynamicProxyHandler proxyHandler = new DynamicProxyHandler(c); IProxyClass proxyClass = (IProxyClass)proxyHandler.newProxyInstance(); System.out.println(proxyClass.getClass().getName()); System.out.println(proxyClass.doSomething(5)); &#125;&#125; 输出结果 1234567com.sun.proxy.$Proxy0method:doSomethingargs:java.lang.IntegerBefore invoke method...方法执行中.....After invoke method...5 &emsp;&emsp;从结果我们可以看到(IProxyClass)proxyHandler.newProxyInstance();实际返回的是com.sun.proxy.$Proxy0，我们把生成的$Proxy0.class文件，使用jad.exe进行反编译，使用命令（要求文件和jad.exe在同一个目录下，或者你可以吧jad加到环境变量中去）： jad -p java $Proxy0.class 得到的$Proxy0.java如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public final class $Proxy0 extends Proxy implements IProxyClass&#123; public $Proxy0(InvocationHandler invocationhandler) &#123; super(invocationhandler); &#125; public final boolean equals(Object obj) &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[] &#123; obj &#125;)).booleanValue(); &#125; catch(Error _ex) &#123; &#125; catch(Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final void doSomething(int i) &#123; try &#123; super.h.invoke(this, m3, new Object[] &#123; Integer.valueOf(i) &#125;); return; &#125; catch(Error _ex) &#123; &#125; catch(Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final int hashCode() &#123; try &#123; return ((Integer)super.h.invoke(this, m0, null)).intValue(); &#125; catch(Error _ex) &#123; &#125; catch(Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final String toString() &#123; try &#123; return (String)super.h.invoke(this, m2, null); &#125; catch(Error _ex) &#123; &#125; catch(Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; private static Method m1; private static Method m3; private static Method m0; private static Method m2; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] &#123; Class.forName("java.lang.Object") &#125;); m3 = Class.forName("io.github.brightloong.proxy.IProxyClass").getMethod("doSomething", new Class[] &#123; Integer.TYPE &#125;); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); &#125; catch(NoSuchMethodException nosuchmethodexception) &#123; throw new NoSuchMethodError(nosuchmethodexception.getMessage()); &#125; catch(ClassNotFoundException classnotfoundexception) &#123; throw new NoClassDefFoundError(classnotfoundexception.getMessage()); &#125; &#125;&#125; 可以看到实际调用的是25行的doSometing()方法。如果你想了解更加具体的JDK动态代理的实现原理可以访问Rejoy的博文JDK动态代理实现原理。 使用Cglib实现动态代理&emsp;&emsp;Cglib不是jdk自带的jar包，需要下载并加入到项目中。个人觉得Cglib比使用jdk自带的实现动态代理更为先进，毕竟它不再需要接口，而且它还有其他强大的功能，大家可以自行研究。 实现MethodInterceptor接口 12345678910111213141516171819202122232425262728293031public class CglibProxy implements MethodInterceptor&#123; private Enhancer enhancer = new Enhancer(); @Override /** * * @param o 是被代理对象 * @param method 调用方法的Method对象 * @param args 方法参数 * @param methodProxy * @return cglib生成用来代替Method对象的一个对象，使用MethodProxy比调用JDK自身的Method直接执行方法效率会有提升 * @throws Throwable */ public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;before &quot; + methodProxy.getSuperName()); System.out.println(method.getName()); Object o1 = methodProxy.invokeSuper(o, args); //Object o2 = method.invoke(o, args); 使用这种方式会发生死循环，因为方法会被拦截 System.out.println(&quot;after &quot; + methodProxy.getSuperName()); return o1; &#125; public Object newProxyInstance(Class&lt;?&gt; c) &#123; //设置产生的代理对象的父类。 enhancer.setSuperclass(c); //设置CallBack接口的实例 enhancer.setCallback(this); //使用默认无参数的构造函数创建目标对象 return enhancer.create(); &#125;&#125; 被代理对象和测试类 12345678910111213public class CglibDemo &#123; public static void main(String[] args) &#123; CglibProxy cglibProxy = new CglibProxy(); Do o = (Do)cglibProxy.newProxyInstance(Do.class); System.out.println(o.doSomething(5)); &#125;&#125;class Do&#123; public int doSomething(int num)&#123; System.out.println("方法执行中。。。。。。"); return num; &#125;&#125; 输出结果 12345before CGLIB$doSomething$0doSomething方法执行中。。。。。。after CGLIB$doSomething$05 本篇笔记参考于：http://www.cnblogs.com/shijiaqi1066/p/3429691.htmlhttp://rejoy.iteye.com/blog/1627405]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>静态代理</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web之限制用户多处登录]]></title>
    <url>%2F2017%2F03%2F08%2FJava-Web%E4%B9%8B%E9%99%90%E5%88%B6%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%A4%9A%E5%A4%84%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在项目中遇到一个需求，要求限制单个用户在多个终端登录（比如用户在A处登录，然后又在B处登录，此时A处就应该被挤下线）。最开始我是想使用spring的security直接通过配置实现，简单又方便。不过很可惜的是，我所做的项目使用的是公司封装的框架，依然在使用sprign2.X。好吧，既然这个方法行不通，那我自己老老实实写代码实现吧，想想网上实现的方法应该很多吧，度娘、谷歌走一波，果断很多，不过过去过来感觉都是同一个。还有就是什么使用application啊，session什么的。最后，我还是自己动手，丰衣足食吧。首先我说一下自己的思路： 用一个全局Map在登录的时候用来保存sessionId，Map的key为登录名，value为sessionID，因为是后来的挤掉前面的，所以不用判断，直接覆盖Map中的值就OK。实现一个HttpSessionListener，在session销毁(比如session过期)的时候清除Map中对应的值。实现一个Filter，用于拦截请求，判断改用当前的sessionId是否在Map中，如果不在执行退出操作。 用来保存登入用户SessionID的类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class LoginUserMap &#123; private static Map&lt;String, String&gt; loginUsers = new ConcurrentHashMap&lt;String, String&gt;(); /** * 将用户和sessionId存入map * @param key * @param value */ public static void setLoginUsers(String loginId, String sessionId) &#123; loginUsers.put(loginId, sessionId); &#125; /** * 获取loginUsers * @return */ public static Map&lt;String, String&gt; getLoginUsers() &#123; return loginUsers; &#125; /** * 根据sessionId移除map中的值 * @param sessionId */ public static void removeUser(String sessionId) &#123; for (Map.Entry&lt;String, String&gt; entry : loginUsers.entrySet()) &#123; if (sessionId.equals(entry.getValue())) &#123; loginUsers.remove(entry.getKey()); break; &#125; &#125; &#125; /** * 判断用户是否在loginusers中 * @param loginId * @param sessionId * @return */ public static boolean isInLoginUsers(String loginId, String sessionId) &#123; return (loginUsers.containsKey(loginId) &amp;&amp; sessionId.equals(loginUsers.get(loginId))); &#125; &#125; 在登录方法中保存sessionID&emsp;&emsp;这里我就不给出具体的实现了，毕竟不同的项目是不同的，我写个大概的步骤，帮助理解：12345678910//登录方法所在的地方public void login(ttpServletRequest request) &#123; try &#123; ......//一系列登录的方法 HttpSession session = request.getSession(); LoginUserMap.setLoginUsers(username, session.getId());//保存sessionId到map中 &#125; catch (LoginException ex) &#123; throw ex; &#125;&#125; 实现HttpSessionListener12345678910111213141516171819202122232425public class SessionListener implements HttpSessionListener &#123; private Log log = LogFactory.getLog(SessionListener.class); /** * 创建session时候的动作 * @param event */ @Override public void sessionCreated(HttpSessionEvent event) &#123; &#125; /** * 销毁session时候的动作 * @param event */ @Override public void sessionDestroyed(HttpSessionEvent event) &#123; HttpSession session = event.getSession(); String sessionId = session.getId(); //移除loginUsers中已经被销毁的session LoginUserMap.removeUser(sessionId); log.info(sessionId + "被销毁！"); &#125;&#125; xml配置如下： 123&lt;listener&gt; &lt;listener-class&gt;io.github.brightloong.loginlimite.SessionListener&lt;/listener-class&gt;&lt;/listener&gt; Filter实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class LoginLimitFilter implements Filter&#123; private Log log = LogFactory.getLog(LoginLimitFilter.class); /** * 销毁时的方法 */ @Override public void destroy() &#123; &#125; /** * 过滤请求 * @param request * @param response * @param filterChain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest servletRequest = (HttpServletRequest) request; HttpServletResponse servletResponse = (HttpServletResponse) response; HttpSession session = servletRequest.getSession(); //获取项目路径 String path = servletRequest.getContextPath(); String basePath = servletRequest.getScheme()+"://"+servletRequest.getServerName()+":"+servletRequest.getServerPort()+path; try &#123; //获取用户信息，如果没获取到会抛出错误,我的是这样,代表用户还没有登录 IUser user = UserUtils.getCurrUserInfo(); String loginId = user.getLoginId(); //判断当前用户的sessionId是否在loginUsers中，如果没有执行if后的操作 if(!LoginUserMap.isInLoginUsers(loginId, session.getId())) &#123; //当前用户logout logout();//自己的logout方法 //调到登录页面，并表明退出方式为挤下线 servletResponse.sendRedirect(basePath + "?logoutway=edge"); &#125; &#125; catch (Exception e) &#123; log.debug("获取当前用户信息失败，用户未登陆！", e); &#125; finally &#123; filterChain.doFilter(request, response); &#125; &#125; /** * 初始化方法 * @param arg0 * @throws ServletException */ @Override public void init(FilterConfig arg0) throws ServletException &#123; &#125;&#125; xml配置如下：12345678&lt;filter&gt; &lt;filter-name&gt;LoginLimitFilter&lt;/filter-name&gt; &lt;filter-class&gt;io.github.brightloong.loginlimite.LoginLimitFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;LoginLimitFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 显示提示信息&emsp;&emsp;当用户点击的时候就会触发filter去监测，如果监测到已经登录，就会转到登录页面，这个时候要判断是否是被挤下来的，我这使用了layer提示框。123456789101112131415161718192021222324window.onload = function()&#123; if(window.parent != window)&#123; window.parent.location.href=window.location.href; &#125; else &#123; if(GetQueryString('logoutway')) &#123; //alert('该用户已在其他地方登录，你已下线'); layer.alert('该账号已在其他地方登录，您已被迫下线，如非本人操作请重新登录并及时修改密码', &#123; skin: 'layui-layer-lan', //样式类名 title: '提示' ,closeBtn: 0 &#125;, function()&#123; var url = window.location.href; window.location.href = url.substr(0,url.indexOf('?logoutway=edge')); &#125;); &#125; &#125;&#125;function GetQueryString(name)&#123; var reg = new RegExp("(^|&amp;)"+ name +"=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if(r!=null)return unescape(r[2]); return null;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>用户登录限制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合&单元测试集成备忘]]></title>
    <url>%2F2017%2F03%2F06%2FSSM%E6%95%B4%E5%90%88-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9B%86%E6%88%90%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;SSM框架，既是Sping + Spring MVC + Mybatis，本篇博文主要是作为本人的备忘，记录如何整合SSM框架，以及如何集成单元测试，关于每一个配置的作用大都加上了注释，至于如何搭建项目这里不在赘述（我使用的是web项目），可以自己查找相关资料。我使用的Spring版本是4.1.3.RELEASE，Mybatis版本是3.3.0，使用Maven进行构建。 注意：首先申明如下的配置是根据我的目录结构来配置的，我的目录结构如下所示： 使用Maven添加相关jar包。&emsp;&emsp;关于pom.xml的配置如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ssm_test&lt;/groupId&gt; &lt;artifactId&gt;ssm_test&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;ssm_test&lt;/name&gt; &lt;description /&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!--配置依赖包 --&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 1.日志，slf4j规范 日志实现：log4j,logback,commin-logging 使用：slf4j + logback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2.数据库相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3.dao mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis自身实现的整合spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4.servelet web 相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 5.spring的依赖 --&gt; &lt;!-- 1)spring核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring aop 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2)spring dao层依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3)spring web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4)spring test依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;warSourceDirectory&gt;$&#123;basedir&#125;/WebRoot&lt;/warSourceDirectory&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; SSM整合配置&emsp;&emsp;为了使配置层次清楚，结构清晰，我把配置按照web、service和dao分别分为spring-web.xml、spring-service.xml和spirng-dao.xml，下面依次介绍这几个配置文件。 spring-web.xm配置&emsp;&emsp;该配置中主要是一些资源映射的相关配置。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 配置springMVC --&gt; &lt;!-- 1.开启springMVC注解模式 --&gt; &lt;!-- 简化配置： 1)自动注册defaultAnnotationHandlerMapping,AnnotationMethodHandlARadpter 2)提供一系列：数据绑定，数字和日期的format @NumberFoamat,@DataTiemFormat xml,json默认读写支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--2.servelt-mapping 映射路径:"/" 静态资源默认servlet配置 1.加入对静态资源的处理：js，gif，png 2.允许用/做整体映射--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3. 配置jsp显示viewResolver--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"&gt;&lt;/property&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的包 --&gt; &lt;context:component-scan base-package="com.chenlong.study.web"&gt;&lt;/context:component-scan&gt; &lt;!-- 获取properties --&gt; &lt;bean id="propertyConfigurer" class="com.chenlong.study.utils.PropertyUtil"&gt; &lt;property name="locations" &gt; &lt;list&gt; &lt;value&gt;classpath:*.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; &emsp;&emsp;在上述配置中最后关于获取properties的配置，我创建了一个PropertyUtil类用来获取properties文件，并读取里面的属性。PropertyUtil.java如下：1234567891011121314151617181920public class PropertyUtil extends PropertyPlaceholderConfigurer &#123; private static Map&lt;String,String&gt; propertyMap; @Override protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props) throws BeansException &#123; super.processProperties(beanFactoryToProcess, props); propertyMap = new HashMap&lt;String, String&gt;(); for (Object key : props.keySet()) &#123; String keyStr = key.toString(); String value = props.getProperty(keyStr); propertyMap.put(keyStr, value); &#125; &#125; //static method for accessing context properties public static Object getProperty(String name) &#123; return propertyMap.get(name); &#125;&#125; spring-service.xml配置&emsp;&emsp;配置自动扫描，用于自动注入；并配置注解事务。1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 扫描service包下的所有注解类型 --&gt; &lt;context:component-scan base-package="com.chenlong.study.service"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置事务管理器，dataSource在spring-dao.xml中配置 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明事务 默认使用注解来管理事务行为--&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 配置spring-dao.xml&emsp;&emsp;在配置sprign-dao.xml之前，先配置mybatis的全局文件mybatis-config.xml如下：123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true"&gt;&lt;/setting&gt; &lt;!-- 使用列命替换别名 --&gt; &lt;setting name="useColumnLabel" value="true"&gt;&lt;/setting&gt; &lt;!-- 开启驼峰命名转换 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"&gt;&lt;/setting&gt; &lt;/settings&gt;&lt;/configuration&gt; &emsp;&emsp;在jdbc.properties中配置数据库信息如下：1234jdbc.username=rootjdbc.password=jdbc.driverClass=com.mysql.jdbc.Driverjdbc.jdbcUrls=jdbc:mysql://localhost:3306/test?useUnicode\=true&amp;amp;characterEncoding\=UTF-8 &emsp;&emsp;然后配置spring-dao.xml如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置整合mybatis过程 --&gt; &lt;!-- 1.配置数据库相关参数 --&gt; &lt;!-- 引入属性文件 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt; &lt;!-- 2.配置数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrls&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;!-- 配置连接池私有属性 --&gt; &lt;property name="maxPoolSize" value="30"&gt;&lt;/property&gt; &lt;property name="minPoolSize" value="10"&gt;&lt;/property&gt; &lt;!-- 关闭连接后不自动提交 --&gt; &lt;property name="autoCommitOnClose" value="false"&gt;&lt;/property&gt; &lt;!--获取连接超时时间 --&gt; &lt;property name="checkoutTimeout" value="1000"&gt;&lt;/property&gt; &lt;!-- 重试次数 --&gt; &lt;property name="acquireRetryAttempts" value="2"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 3.配置sqlsessionfactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 配置mybatis全局文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;!-- 扫描entity包使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.chenlong.study.entity"&gt;&lt;/property&gt; &lt;!-- 扫描mapper文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/chenlong/study/dao/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描dao接口包，动态实现dao接口，自动注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlsessionfactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;!-- 给出扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.chenlong.study.dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 配置web.xml&emsp;&emsp;在完成上述配置后，配置web.xml，配置springmvc和spring的servlet1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;sh_student&lt;/display-name&gt; &lt;!-- 配置springmvc dispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispacherservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispacherservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 单元测试集成&emsp;&emsp;在pom.xm文件中我们曾加入如下的jar包用来做单元测试。123456789101112&lt;!-- 4)spring test依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &emsp;&emsp;下面我给出一个测试示例:1234567891011121314151617//整合junit和spring，让junit在启动时候加载springIOC容器@RunWith(SpringJUnit4ClassRunner.class)//告诉junit spring的配置文件,需要用到的配置文件，如果是dao的话可以不用spring-service.xml@ContextConfiguration(&#123; "classpath:spring-dao.xml", "classpath:spring-service.xml" &#125;)public class SeckillServiceTest &#123; @Autowired private SeckillService seckillService; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Test public void testGetSeckillList() &#123; List&lt;Seckill&gt; seckills = seckillService.getSeckillList(); logger.info("list=&#123;&#125;", seckills); &#125;&#125; &emsp;&emsp;关于SSM框架的整合和单元测试的集成就到此结束。]]></content>
      <categories>
        <category>ssm&amp;ssh</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类的初始化顺序]]></title>
    <url>%2F2017%2F02%2F27%2F%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在看回顾Java基础的时候，发现看似很简单的类初始化的顺序却并不是那么简单（往往越是简单的东西反而越容易出错呢），所以我觉得还是把它写下来，作为自己的备忘录比较好。既然都记录了我觉得我还是记录得比较全面的较好，所以显得有点啰嗦。 普通类的初始化（不存在继承，内部类的时候）&emsp;&emsp;为了更详细的验证类的初始化顺序，首先我创建了一个被另一个类使用的类B.java1234567891011121314151617181920212223public class B &#123; private int varOneInB = initInt("varOneInB"); // 6 14 private static int staticVarOneInB = initInt("staticVarOneB"); // 4 private int varTwoInB = initInt("varTwoInB"); // 7 15 private static int staticvarTwoInB = initInt("staticvarTwoInB"); // 5 /** * 构造方法 */ public B() &#123; System.out.println("B constructor"); // 8 16 &#125; /** * 用于对int类型的变量赋值 * @param varName * @return */ private static int initInt(String varName) &#123; System.out.println(varName + " init"); return 2017; &#125;&#125; &emsp;&emsp;然后我创建了一个A类来验证初始化顺序，并且在该类中同时使用的static变量和static块等。123456789101112131415161718192021222324252627282930313233343536373839public class A &#123; private int varOneInA = initInt("varOneInA"); // 11 private static int staticVarOneInA = initInt("staticVarOneInA"); // 1 &#123; int varTwoInA = initInt("varTwoInA"); // 12 &#125; static &#123; int staticvarTwoInA = initInt("staticvarTwoInA"); // 2 &#125; private B b = new B(); // 13 private static B staticB = new B(); // 3 /** * 构造方法 */ public A() &#123; System.out.println("A constructor"); // 17 &#125; /** * 用于对int型变量赋值 * @param varName * @return */ private static int initInt(String varName) &#123; System.out.println(varName + " init"); return 2017; &#125; public void run() &#123; System.out.println("run be called");// 23 &#125; public static void main (String[] args) &#123; System.out.println("start running");// 9 A a = new A();// 10 a.run();// 18 &#125;&#125; 运行后结果为：123456789101112131415staticVarOneInA initstaticvarTwoInA initstaticVarOneB initstaticvarTwoInB initvarOneInB initvarTwoInB initB constructorstart runningvarOneInA initvarTwoInA initvarOneInB initvarTwoInB initB constructorA constructorrun be called &emsp;&emsp;对《Think in java》这本书里面的关于初始化顺序的总结进行归纳如下： 注意：即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。 即使没有显示地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类的对象时（构造器可以看出静态方法），或者类的静态方法/静态域被首次访问时，Java解释器必须查找类路径。 然后载入class，有关静态初始化的所有动作都会执行（所以静态初始化只在Class对象首次被加载的时候进行一次）。 当使用new创建对象的时候，首先将在堆上为对象分配足够的存储空间。 这块存储空间会被清零，这就自动将Dog对象中的所有基本类型数据都设置成了默认值（对数字来说就是0，对布尔类型和字符类型也相同），而引用就则被设置成了null。 执行出现于字段定义出的初始化动作。 执行构造器。 &emsp;&emsp;有了上面的知识点，再来看上面的结果。我用数字1 2 3做了标记，括号后的阿拉伯数字表示上面代码对应的地方。 在类A中执行main方法，由于main()是静态方法，必须加载A类，然后起静态域staticVarOneInA(1)，staticvarTwoInA(2)，staticB(3)被初始化。 在staticB被初始化的时候，导致B类被加载，因为是第一次加载，对静态域进行初始化，因此staticVarOneInB(4)，staticvarTwoInB(5)被初始化。 之后顺序初始化varOneInB(6)，varTwoInB(7)，执行构造器B(8)。 在A静态域初始化后，回到main()方法，打印出了“start running”(9),在new A()(10)的时候，分配a对象的空间，开始顺序初始化varOneInA(11)，varTwoInA(12)和b(13)，初始化b的时候因为不是第一次加载，所以staticVarOneInB，staticvarTwoInB不再被初始化，只是初始化了varOneInB(14)，varTwoInB(15)，然后执行构造B(16)。 初始化完成后，调用A的构造器(17)；最后通过a.run()调用run(18)方法，打印出“run be called”。 具有继承的类的初始化&emsp;&emsp;下面，我创建了一个Father类和一个继承Father类的Son类，来探究在有继承的时候类的初始化和加载，情况基本和上面类似，我就不再写太多的注释了。Father类如下：12345678910111213public class Father &#123; private int varInFather = initInt("varInFather"); private static int staticVarInFather = initInt("staticVarInFather"); public Father(String name) &#123; System.out.println("Father constructor" + " name:" + name); &#125; private static int initInt(String varName) &#123; System.out.println(varName + " init"); return 2017; &#125;&#125; Son.java如下：12345678910111213141516171819public class Son extends Father&#123; private int varInSon = initInt("varInSon"); private static int staticVarInSon = initInt("staticVarInSon"); public Son(String name) &#123; super(name); System.out.println("Son constructor" + " name:" + name); &#125; private static int initInt(String varName) &#123; System.out.println(varName + " init"); return 2017; &#125; public static void main(String[] args) &#123; System.out.println("start running"); Son son = new Son("Bob"); &#125;&#125; 输出结果如下；1234567staticVarInFather initstaticVarInSon initstart runningvarInFather initFather constructor name:BobvarInSon initSon constructor name:Bob &emsp;&emsp;同样的，我将《Think in java》中的关于继承的类加载和初始化归纳如下： 注意：即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。 （同上）即使没有显示地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类的对象时（构造器可以看出静态方法），或者类的静态方法/静态域被首次访问时，Java解释器必须查找类路径，在对它进行加载的过程中，编译器注意到它有一个基类（有extends得知），于是它继续加载，不管你时候打算产生一个该基类的对象。如果该基类还有其自身的基类，那么第二个基类就会被加载，如此类推。 接下来，根基类的static初始化会被执行，然后是下一个导出类，如此类推。 必要的类加载完成后，对象就可以被创建。同样的，首先对象中所有的基本类型都会被设为默认值，对象引用被设为null——通过将对象内存设为二进制零值而一举生成。 然后基类的构造器会被调用。基类构造器和导出类的构造器一样，以相同的顺序来经历相同的过程。 在基类构造器完成之后，实例变量按其次序被初始化。 最后，构造器的其余部分被执行。 &emsp;&emsp;在有了上述归纳后，我们来分析上面程序的结果。 在类Son中执行main方法，由于main()是静态方法，必须加载Son类，在加载的时候发现其有父类Father，进而加载Father类。 Father类被加载的时候，其静态变量staticVarInFather被初始化，之后Son类中的静态变量staticVarInSon被初始化。 回到main方法，打印出“start running” 在执行new Son(“Bob”)的时候，对基类也就是Father中的varInFather进行初始化，之后Father的构造器被调用。 之后导出类变量varInSon被初始化，调用导出类Son的构造器。 具有继承的静态内部类&emsp;&emsp;关于这个的讲解，我引用一道2015携程Java工程师笔试题。来自csdb博客fuck两点水的 2015携程JAVA工程师笔试题(基础却又没多少人做对的面向对象面试题)。题目如下：1234567891011121314151617181920212223242526public class Base&#123; private String baseName = &quot;base&quot;; public Base() &#123; callName(); &#125; public void callName() &#123; System. out. println(baseName); &#125; static class Sub extends Base &#123; private String baseName = &quot;sub&quot;; public void callName() &#123; System. out. println (baseName) ; &#125; &#125; public static void main(String[] args) &#123; Base b = new Sub(); &#125;&#125; &emsp;&emsp;当时看到这道题的时候，关于类的加载，初始化基本已经忘记，所以直接做错。该题的正确答案是：1null 为什么是null?首先我们从上面的内容可以了解到，类的初始化顺序是： 父类静态块 -&gt;子类静态块 -&gt;父类初始化语句 -&gt;父类构造函器 -&gt;子类初始化语句 子类构造器。 其实在掌握了我上面说的东西后，这道题的的答案为什么为null,已经是“柳暗花明又一村了”；所以我这里直接把fuck两点水博客上的内容摘抄过来 Base b = new Sub();在 main方法中声明父类变量b对子类的引用，JAVA类加载器将Base,Sub类加载到JVM;也就是完成了 Base 类和 Sub 类的初始化 JVM 为 Base,Sub 的的成员开辟内存空间且值均为null;在初始化Sub对象前，首先JAVA虚拟机就在堆区开辟内存并将子类 Sub 中的 baseName 和父类 Base 中的 baseName（已被隐藏）均赋为 null，就是子类继承父类的时候，同名的属性不会覆盖父类，只是会将父类的同名属性隐藏 调用父类的无参构造调用 Sub 的构造函数，因为子类没有重写构造函数，默认调用无参的构造函数，调用了 super() 。 callName 在子类中被重写，因此调用子类的 callName();调用了父类的构造函数，父类的构造函数中调用了 callName 方法，此时父类中的 baseName 的值为 base，可是子类重写了 callName 方法，且 调用父类 Base 中的 callName 是在子类 Sub 中调用的，因此当前的 this 指向的是子类，也就是说是实现子类的 callName 方法 调用子类的callName，打印baseName 实际上在new Sub()时，实际执行过程为：1234public Sub()&#123; super(); baseName = "sub"; &#125; 可见，在 baseName = “sub” 执行前，子类的 callName() 已经执行，所以子类的 baseName 为默认值状态 null 。&emsp;&emsp;上面的题，大家可以试着把子类中的baseName使用static进行修饰，看看会得到什么结果，加深自己的理解。&emsp;&emsp;关于类的加载和初始化的备忘录就到此结束了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>类初始化顺序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客(三)——百度分享集成]]></title>
    <url>%2F2017%2F02%2F26%2FHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在上一篇博客Hexo+Github搭建个人博客(二)——配置&amp;主题中我还留下了一个有关百度分享的东西没有说明。我之前也说这是我在搭建博客中遇到的最大的坑（没有之一）。在这篇博客中叫我将说一说我遇到了什么坑，以及怎么从坑里面爬出来的。当然怎么解决百度分享在https中的使用的具体方法并不是我搞出来的，首先要感谢hrwhisper在他的博文百度分享不支持https的解决方案中提出的解决方案。但是我在使用的过程中并不是很顺利的解决了我的问题（可能由于我使用的是Next)的主题），在使用其方案过程中还有不少坑需要注意的，下面我将一一说明。 注意：以下问题可能你没有遇到，我是在使用Next主题)中遇到的。 做好基本的配置&emsp;&emsp;请大家参照我的上一篇博文Hexo+Github搭建个人博客(二)——配置&amp;主题中有关百度分享集成的部分，先做好基本配置。 1. 在站点配置文件中，添加字段baidushare，值为 true&emsp;&emsp;关于什么是站点配置文件，我相信大家应该清楚了，如果不知道的话请看我的上一篇博文中有所提及。1baidushare: true #百度分享功能 2. 在主题配置文件中，找到baidushare字段，设置其展现方式12baidushare: type: button #百度分享展示的方式button|slide &emsp;&emsp;做好上面两步后，在你的百度分享还没有出现的情况下，打开浏览器的F12,发现提示https访问http资源的问题。之后介绍怎么解决百度分享在https下的使用。 百度分享在https中的使用&emsp;&emsp;百度分享不能使用的主要原因是它会去请求http中的资源，一个share.js，既然这样，我们能想到的就是把这个资源放到非http上，或者干脆直接放到我们自己的目录下面。&emsp;&emsp;大家可以按照方案提供者hrwhisper依照他的博文百度分享不支持https的解决方案去做，在遇到问题的时候回到我的博文，或者可以直接按照我说的做。 下载资源文件，并放到自己blog的目录下。 &emsp;&emsp;Github地址：https://github.com/hrwhisper/baiduShare&emsp;&emsp;这里我要强调一下，在站点配置文件中，有一个source_dir字段，这个是你访问资源的根目录，比如我在sourc中放置了一个test.jpg的文件，那么访问它的路径就是/test.jpg1source_dir: source &emsp;&emsp;static 解压后丢到站点根目录，也就是source目录下面。然后将百度分享中的代码修改，我使用的是Next主题，这段代码在文件F:\myblog\themes\next\layout_partials\share\baidushare.swing中，如果你找不到可以在你的主题文件夹中搜索baidushare。123.src=&apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt;改为.src=&apos;/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; 这样之后重启服务，看看百度分享是不是出现了，如果出现了，恭喜你，成功了。如果没有，请你继续往下看。 在站点配置文件中设置skip_render字段&emsp;&emsp;在你发现百度分享还是没有出现的时候，打开F12，是不是发现share.js文件已经成功加载了，但是这个文件报错，你进入F:\myblog.deploy_git\static\api\js(我的就是这个目录，因为我把博客放在了F:\myblog下)，打开share.js文件，发现这个文件末尾并没有加载完，我我们下载下来的static\api\js\share.js是不一样的，为什么？&emsp;&emsp; 原来，hexo会把/source下的文件全部渲染 怎么解决这个问题，有两种办法：你可以设置站点配置文件下的skip_rende字段，让hexo在渲染的时候跳过static之下的所有文件。123456789skip_rende: static/**#单个文件夹下的全部文件：skip_render: test/*#单个文件夹下的指定类型文件：skip_render: test/*.md#单个文件夹下的全部文件以及子目录:skip_render: test/**#多个文件夹：#skip_render:# test1/*.html #注意前面的空格，代表是skip_render之下的# test2/** &emsp;&emsp;你也可以选择不设置这个属性，而是把static文件放在主题文件的source目录下，我的是（F:\myblog\themes\next\source）。做完这些操作后，你的百度分享应该已经出现在你的博客中了，just enjoy it。（ps：除了以上解决百度在https下使用的方法以外，还有一个方法就是使用CDN，具体方式请参考巧用七牛CDN的镜像功能使百度分享支持HTTPS。再多说一句关于JiaThis不能支持https的问题个人觉得也可以用以上的方式来解决，这个大家可以自行研究。）（ps plus：关于博客的搭建就暂时告一段落了。）]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
        <tag>百度分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客(二)——配置&主题]]></title>
    <url>%2F2017%2F02%2F25%2FHexo-Github%E5%BB%BA%E7%AB%99%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在上一篇博客Hexo+Github搭建个人博客(一)——开始搭建中介绍了如何安装git、hexo以及将文件推送到github上，相信看到这篇博客的时候你已经有了一个漂亮的博客。这篇博客主要介绍如何发布文章、在站点配置文件中配置一些个性化的信息，以及更换主题（我现在使用的是Next主题，所以关于主题配置以及之后的集成第三方工具等都是基于Next主题来说的），更换主题后如何集成第三方工具。 发布新的博客&emsp;&emsp;既然博客已经搭建好了，那么不发几篇博文有就没有意义了，使用下面的命令来新建一篇叫做”brightloong”的文章。 1hexo new &apos;brightloong&apos; &emsp;&emsp;命令执行之后，你会在你文件博客根目录的source/_post目录下找到你刚刚新建的md后缀的文件，比如我的是F:\myblog\source_posts\brightloong.md，hexo博客是使用markdown语法来书写的，如果不熟悉markdown语法可以快速的看一下markdown语法说明，或者是认识与入门Markdown,后者也有推荐一些不同平台下使用的编辑Markdown的工具，本人使用的是Cmd Markdown，它既支持在线的编辑，也可以下载下来使用。生成的md文件打开如下： 注意：在冒号后面一定要加上一个空格，否则在生成静态文件的时候会报错，并且也不能将其成功推送到github。 123456---title: brightloong #文章标题date: 2017-02-24 12:03:12 #创建时间tags: #文章标签，如果有多个标签可以使用[1,2,3]的形式，还有其他形式自己摸索吧---#这之后是正文 &emsp;&emsp;文章编写好之后，只用以下命令生成静态文件并推送到github上，执行完成后打开自己的博客页面，是不是发现刚刚编写的文章出现了；如果你想删除某一篇文章，那么在source/_post目录下找到对应的文章将其删除后，同样执行一下命令就OK了。 123hexo cleanhexo ghexo d 站点配置文件_config.yml&emsp;&emsp;站点配置文件_config.yml是在你博客保存目录的根目录下，注意将它与主题配置文件进行区分，比如我保存的博客目录为F:\myblog那么我站点配置文件为F:\myblog_config.yml，我使用的主题是Next主题，所以我的主题配置文件为F:\myblog\themes\next_config.yml。下面我先介绍下站点配置文件，我将一些主要的配置做了注释，如果你想了解更多的配置的含义和作用，请访问Hexo官方教程查看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: BrightLoong&apos;s Blog #博客的标题subtitle: #子标题description: Remember what should be remembered, and forget what should be forgotten.Alter what is changeable, and accept what is mutable. #博客描述，可以是一段你喜欢的话，也可以是你博客的描述，只要你开心就好。author: BrightLoong #作者language: zh-Hans #语言（我使用的是简体中文）timezone: #时区（默认使用电脑时间）##之下的保持默认就好，没有什么需要更改的# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; #and root as &apos;/child/&apos;url: https://brightloong.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: source #source目录public_dir: publictag_dir: tags #标签目录archive_dir: archives category_dir: categories #分类目录code_dir: downloads/codei18n_dir: :langskip_render: static/** #注意这个属性（跳过渲染），你暂时不用配置，我之后会讲到，这个也是我遇到的坑##之下的保持默认就好，没有什么需要更改的# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #你设置的主题，接下来我会说到这个# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/BrightLoong/BrightLoong.github.io.git branch: master 主题更换&emsp;&emsp;搭建自己的博客，最吸引人的莫过于那千变万化的主题了，大家可以在Hexo官网上看到无数漂亮、大方、简洁的主题。本人使用的是简洁的Next主题，你可以选择你喜欢的下载下来，将其解压放入themes目录中，比如我的目录是F:\myblog\themes，然后修改我在上面提到的站点配置文件中的theme属性，为你刚刚放入themes目录中文件的名字（最好是对解压文件修改一个名字，否则名字可能会比较长，我把我下载下来的主题改文了next）,做完这些之后并不代表你完成了，你还需要参考你所下载的主题所说的配置步骤进行相关的配置，由于不同的主题配置过程也尽不相同，大家根据自己下载的主题去配置，我在这里只说我使用的Next主题如何配置。 1theme: next 注意：从下面开始所说的都是Next主题的相关配置。 配置Next主题&emsp;&emsp;如果你使用的和我一样，也是Next的主题，那么你最好还是看官方提供Next使用文档，并且文档是中文版的,我也仅仅是讲一些容易被忽略的配置，以及我使用的配置，以及在使用过程中遇到的问题;至于如何更换头像，添加分类和标签页面、切换主题样式（Next主题包含3中样式）之类的，大家还是照着官方的做更好。 1. 配置网站图标&emsp;&emsp;如何让网站前能显示自己想要的图标，我当时也是找了很久，最后发现是在主题配置文件（我的是F:\myblog\themes\next_config.yml）的最前面，有一个favicon属性，我把一个名字叫favicon.ico的图片放到了F:\myblog\source下，然后配置如下：1favicon: /favicon.ico 2. 首页显示阅读全文按钮&emsp;&emsp;首页的文章是不是默认展开了，显示出了整篇文章，怎么才能显示出如下的阅读全文的按钮。在主题配置文件中找到auto_excerpt属性进行配置123auto_excerpt: enable: true #改写为true length: 150 #默认展示的高度 你也可以在自己的博文中添加&lt;!--more--&gt;来决定在首页展示到什么位置（我就喜欢用这种方式），这个标签后的内容就不会展示到首页啦。 3. 集成多说评论&emsp;&emsp;登录多说，登录后在首页选择“我要安装”。创建站点，填写表单。多说域名 这一栏填写的即是你的 duoshuo_shortname，如图：&emsp;&emsp;创建站点完成后在 站点配置文件(我的是F:\myblog_config.yml) 中新增 duoshuo_shortname 字段，值设置成上一步红框中的值。 注意：新增字段的时候一定不要让字段前面有空格，否则会被认为是子字段，无法正确解析 12#多说评论duoshuo_shortname: brightloong #设置为红框中的值 &emsp;&emsp;多说评论中可以开启热评文章，在站点配置文件中增加字段：1duoshuo_hotartical: true 开启后你可能会发现点击热评文章并不能跳转到对应的网页，进入多说后台查看，发现原来网址不正确，那简单，点击编辑修改成正确的网址就OK了。 4. 阅读次数统计&emsp;&emsp;次数统计又leancloud提供，请参考由由Doublemine 贡献提供的为Next主题添加阅读次数统计功能 5. 集成百度分享&emsp;&emsp;分享功能的集成是最坑的没有之一，我大概花了半天多的时间查找各种方法才将其解决，这里我先说官网的配置：编辑 站点配置文件，添加字段 baidushare，值为 true。1baidushare: true #百度分享功能 &emsp;&emsp;欢欢喜喜的打开自己的博客。咦！百度分享功能咋没有添加上啊。不急，听我慢道来。我在主题文件中发现一个文件F:\myblog\themes\next\layout_partials\share\baidushare.swing，内容如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123;% if theme.baidushare.type === &quot;button&quot; %&#125; &lt;div class=&quot;bdsharebuttonbox&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tsina&quot; data-cmd=&quot;tsina&quot; title=&quot;分享到新浪微博&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_douban&quot; data-cmd=&quot;douban&quot; title=&quot;分享到豆瓣网&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_sqq&quot; data-cmd=&quot;sqq&quot; title=&quot;分享到QQ好友&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_qzone&quot; data-cmd=&quot;qzone&quot; title=&quot;分享到QQ空间&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_weixin&quot; data-cmd=&quot;weixin&quot; title=&quot;分享到微信&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tieba&quot; data-cmd=&quot;tieba&quot; title=&quot;分享到百度贴吧&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_twi&quot; data-cmd=&quot;twi&quot; title=&quot;分享到Twitter&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_fbook&quot; data-cmd=&quot;fbook&quot; title=&quot;分享到Facebook&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_more&quot; data-cmd=&quot;more&quot;&gt;&lt;/a&gt; &lt;a class=&quot;bds_count&quot; data-cmd=&quot;count&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;2&quot;, &quot;bdMiniList&quot;: false, &quot;bdPic&quot;: &quot;&quot; &#125;, &quot;share&quot;: &#123; &quot;bdSize&quot;: &quot;16&quot;, &quot;bdStyle&quot;: &quot;0&quot; &#125;, &quot;image&quot;: &#123; &quot;viewList&quot;: [&quot;tsina&quot;, &quot;douban&quot;, &quot;sqq&quot;, &quot;qzone&quot;, &quot;weixin&quot;, &quot;twi&quot;, &quot;fbook&quot;], &quot;viewText&quot;: &quot;分享到：&quot;, &quot;viewSize&quot;: &quot;16&quot; &#125; &#125; &lt;/script&gt;&#123;% elseif theme.baidushare.type === &quot;slide&quot; %&#125; &lt;script&gt; window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;1&quot;, &quot;bdMiniList&quot;: false, &quot;bdPic&quot;: &quot;&quot; &#125;, &quot;image&quot;: &#123; &quot;viewList&quot;: [&quot;tsina&quot;, &quot;douban&quot;, &quot;sqq&quot;, &quot;qzone&quot;, &quot;weixin&quot;, &quot;twi&quot;, &quot;fbook&quot;], &quot;viewText&quot;: &quot;分享到：&quot;, &quot;viewSize&quot;: &quot;16&quot; &#125;, &quot;slide&quot;: &#123; &quot;bdImg&quot;: &quot;5&quot;, &quot;bdPos&quot;: &quot;left&quot;, &quot;bdTop&quot;: &quot;100&quot; &#125; &#125; &lt;/script&gt;&#123;% endif %&#125;&lt;script&gt; with(document)0[(getElementsByTagName(&apos;head&apos;)[0]||body).appendChild(createElement(&apos;script&apos;)).src=&apos;/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; &emsp;&emsp;注意到最开始的语句了吗if theme.baidushare.type === “button”，以及之后的else if theme.baidushare.type === “slide”什么意思，在theme下也就是主题配置文件中，baidushare字段下的type字段，我们打开主题配置文件(我的是F:\myblog\themes\next_config.yml)，这个配置是不是被注释掉了：12baidushare: type: button #百度分享展示的方式button|slide &emsp;&emsp;修改之后，再启动，发现还是没有（如果你是用的本地启动用local的方式访问可能会看到百度分享功能已经出现了），这个是后打开浏览器F12的调试功能，是不是发现控制台报错了，提示你从https中去访问http的资源是不行的。不知道大家有没有看到刚刚我们修改的主题配置文件中，在上面有一段注释： 123# Warning: Baidu Share does not support https.百度分享不支持httpsbaidushare: type: button 是的不支持https的方式，自己的域名是用https开头的（除非你自己购买了域名，如何购买更换域名请大家参考【Hexo+Github】域名和github绑定的问题）。并且，JiaThis等都不支持https，怎么办？我将在下一篇博客中单独介绍我在搭建博客中遇到的最大的坑，百度分享如何在https下使用。]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>建站</tag>
        <tag>hexo配置</tag>
        <tag>Next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客(一)——开始搭建]]></title>
    <url>%2F2017%2F02%2F24%2FHexo-Github%E5%BB%BA%E7%AB%99-%E4%B8%80-%E5%BC%80%E5%A7%8B%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前段时间本人利用业余时间，在网上查询各种资料，使用Hexo+Github的方式搭建起了我个人的博客——BrightLoong。相信网上已经有无数前辈写了类似的文章来记录如何搭建博客的过程和步骤，我也不哗众取宠或者班门弄斧了，把我在搭建博客中使用 资料做一个收集，同时也将我在搭建博客过程中遇到的坑列举出来，以及对应的解决方法，也是对搭建博客过程的一个记录，毕竟好记性不如烂笔头。那话不多说，接下来就是一个简单的介绍以及如何搭建的步骤(本文基本也是安照官方的步骤在介绍，我只是在有些地方记了下自己踩过的坑，强烈建议大家跟着Hexo官方文档操作)。 本文适用于Windows搭建 正文什么是Hexo&emsp;&emsp;在Hexo官网上如此描述：Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.（Hexo是一个快速，简单和强大的博客框架。你可以使用Markdown（或其他语言）写博客，之后Hexo能在几秒钟生成具有美观主题的静态文件。）如果你想了解更多关于Hexo的东西，请移步Hexo官网。&emsp;&emsp;Hexo是一款基于Node.js的静态博客框架，可以deploy到Github上，所以首先要在电脑上安装git和node.js,并在Github上注册自己的账号，由于这些东西不是本篇博客要涉及到的主要内容，你可以谷歌、百度，也可以参考我下面提供的链接。 Git安装&emsp;&emsp;你可以去官网下载Git，因为国外资源可能很慢，你也可以下载我在网盘上提供的Git镜像。具体如何使用，请参照廖雪峰老师关于Git的教程，如果你仅仅是想安装git那看看Git安装的那个章节 Node.js安装配置&emsp;&emsp;关于Node.js的安装以及配置，可以参照菜鸟教程上面关于Node.js安装配置的教程，上面也有下载的链接，本人就是参照上面安装的。具网上有些文章说，安装完成后最好重启电脑，以免之后无法使用hexo的相关命令，我倒是没有遇到，不过如果大家遇到这种问题就重启吧。 Hexo安装&emsp;&emsp;必须要在你安装了上述的Git以及Node.js之后才能进行Hexo的安装。 1. 用以下命令安装Hexo&emsp;&emsp;在任意地方点击右键，选择Git Bash Here $ npm install -g hexo-cli &emsp;&emsp;如果安装过程中遇到一下错误： ERROR Deployer not found : github &emsp;&emsp;运行 $ npm install hexo-deployer-git --save 2. 创建博客存放目录，并进行初始化，安装依赖包（最好不要使用带中文的路径，以免后面出现不必要的麻烦）&emsp;&emsp;打开一个目录，在这个地方点击右键选择Git Bash Here,执行以下命令 $ hexo init &lt;folder&gt; #创建目录并执行初始化 $ cd &lt;folder&gt; $ npm install #安装依赖包 &lt;folder&gt;改为你想要的目录。&emsp;&emsp;当然你也可以自己新建一个目录，比如我在F盘中创建了myblog目录，进入目录中点击右键选择Git Bash Here，直接执行以下命令 $ hexo init $ npm install &emsp;&emsp;不管你用哪种方式，执行完毕后你会发现以下目录结构 . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 3. 启动服务&emsp;&emsp;执行以下命令来启动服务 $hexo g #hexo generate，生成静态文件 $ hexo s #hexo server，启动本地服务器 &emsp;&emsp;如果启动过程中没有报错，此时你用浏览器访问http://localhost:4000/，是不是看到了一个Hello World的博客页面，hexo3.0使用的默认主题是landscape（之后我会讲如何更换主题，以及集成第三方的工具），而且此时的服务是本地启动的，别人并不能看到（继续我接下来的操作就好了）。&emsp;&emsp;这个时候如果在浏览器没看到漂亮的博客页面怎么办，别急，先确认你在启动过程中是不是报错了，如过有的话估计是上面的操作有误，如果没有并且发现页面一直在加载中，估计是端口被占用了，我就遇到了这个问题。怎么办?把4000端口给杀死，还有更简单的——在hexo s命令后面加上启动参数，修改默认端口：hexo s -p &lt;port&gt;，比如我用的 hexo s -p 8000，现在重新访问http://localhost:8000/记得把地址的8000改成你自己对应的端口号，是不是看到了美丽的界面。 4. 注册Github账号，并创建仓库。&emsp;&emsp;想要别人也访问到你的页面，跟着继续吧。首先在Github官网上注册一个账号，有账号的跳过注册，直接登录。登录后找到new repository按钮创建一个新的仓库。 &emsp;&emsp;然后填写repository name就行了，要注意的是：这个名字的格式必须为youname.github.io，并且必须和你的账户名相同，比如我的账户名是BrightLoong，我的地址就是brightloong.github.io（最开始我就是将name随意填写，虽然是这个格式但是根本访问不了，会报404的错误）。 5. 将本地文件推送到github&emsp;&emsp;最后，剩下的就是将本地文件推送到github上了，首先打开站点配置文件_config.yml，比如我的路径是：F:\myblog_bonfig.yml。找到最后的deploy属性，如果没有就自己添加，将配置修改为： deploy: type: git #推送方式 repository: https://github.com/BrightLoong/BrightLoong.github.io.git #你的推送地址 branch: master #你要推送的分支 这个地方要注意的是属性后面的冒号必须要有一个空格，否则会报错 &emsp;&emsp;配置好之后使用以下命令将服务部署到github上。 $ hexo clean $ hexo g $ hexo d &emsp;&emsp;使用hexo d命令，第一次会要求你输入用户名和密码，用户名和密码就是你注册github时候使用的用户名和密码。如果遇到以下错误： ERROR Deployer not found : github &emsp;&emsp;运行 $ npm install hexo-deployer-git --save &emsp;&emsp;再执行上面的命令。 $ npm install hexo-deployer-git --save &emsp;&emsp;如果你没有配置Github的SSH，那么可能需要配置一下，你可以用以下命令查看一下 ssh -T git@github.com &emsp;&emsp;如果成功会有以下提示（我的账户名叫BrightLoong） Hi BrightLoong! You&apos;ve successfully authenticated, but GitHub does not provide shell access. &emsp;&emsp;如果没有，可以参考博客git添加ssh-key查看config。 &emsp;&emsp;如果没有报错误，那么博客就已经搭建起来，并发布到Github上了，在浏览器输入youname.github.io就能看到自己的博客了，如果中途报错说未识别的用户名，那么如果你确定你填写是正确的，重复使用hexo d命令，我当时就遇到过这种情况，我估计是网络不好引起的。 结尾&emsp;&emsp;博客已经搭建起来了，是不是正如Hexo所说——fast, simple and powerful，这篇文章就说这么多。之后我介绍如何发布文章，更换主题，站点配置文件，以及如何集成第三方应用（多说评论、百度分享等）。希望对大家有帮助。 版权声明：本文为博主原创文章，转载请注明出处 BrightLoong’s Blog]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始Blog之旅]]></title>
    <url>%2F2017%2F02%2F17%2F%E5%BC%80%E5%A7%8Bblog%E4%B9%8B%E6%97%85%2F%E5%BC%80%E5%A7%8Bblog%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;终于在2017年，也是我大学毕业的第二个年头，抽业余时间，搭建起了属于自己的博客网，说实话，感觉有点迟。但是不管怎么样，至少是开始了，就如那一句话“最困难的是下定决心去做，剩下的只是坚持而已”，我下定决心去做了，并实现了第一步，但是或许最困难的其实是那后面的“坚持而已”。&emsp;&emsp;不知在何时何地何处，在何人的博客上曾看到过，大概的意思是有输入也要有输出，也就是说不仅要学习新东西，还要能够将学到的东西通过自己输出，反馈给大众；上升到哲学问题，在我看来就是中国的那一句“达则兼济天下”。“输出”我大概是还不太够资格，“达则兼济天下”我可能也做不到，既然如此我也就只好“穷则独善其身”，将自己的所感所想记录下来作为自己的回忆，将自己学习到的东西记录下来作为自己的备忘录，但是如果我自己的“独善其身”能够帮助到一些人，那也是极好的。&emsp;&emsp;这篇“开始Blog之旅”本就没什么中心思想，作为我的第一篇博客，文笔和内容肯定欠佳。既然如此，我干脆再多说一个话题。最近在大学的群里和同学朋友聊天，二十四、二十五岁的我们仿佛大多都处于一个迷茫的时期，大学毕业后，接收社会的冲撞与洗礼，工作快两年的我们却显得越来越迷茫，不知道自己想要什么，找不到自己要追求的目标，甚至更为甚者觉得生活失去了意义。想想自己，何尝不是也处于这个阶段，也许是因为一成不变的生活让我们感到无趣，也许是工作的压力让我们无法如往日一般无忧无虑，也许是发现自己曾经“面朝大海，春暖花开”的梦想被现实摧毁，又也许是那“采菊东篱下，悠然见南山”的意境已经当然无存。对于这种阶段我不知道怎么办，在思考良久后我给出我自己的回答——不管怎样，生活终将会继续，不是你和生活一同奔跑，就是你被生活推着向前，趁着离三十岁还有一段距离，趁着离“四十而立”还有一段路程，暂时不要把金钱看得太重太重（当然我并没有说没有金钱能生活下去，只是看得太过重要可能你就是被生活推着走了），多尝试不同的东西，可能在不断的尝试中你便能找到那个你能为之付出余生的事，年轻的我们还有试错的机会；找一个能陪你走一辈子的人，这样或许你会期待每一天下班之后回家；健康是最重要的，毕竟健康是“1”，其他是“1”后面的一串“0”,”1之不存0将焉附”；培养自己至少一个兴趣，哪怕这个兴趣就是打游戏，兴趣是你疲劳时候以及不堪工作压力时候放松的途径;最后一点：人生终究不圆满，至少不要让遗憾随处可见。&emsp;&emsp;感觉自己的话有点多了，那这一段就作为这篇没有中心思想的文章的结尾吧。希望这些文字能成为自己不断学习进步的动力，成为自己生活的回忆以及乐趣，也希望能做到自己博客上的那一句话：Remember what should be remembered, and forget what should be forgotten.Alter what is changeable, and accept what is mutable——记住该记住的，忘记该忘记的。改变能改变的，接受不能改变的，同时也对有拖延症的自己下一个决心，尽力做好后面的“坚持而已”。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2017/2/20]]></content>
      <categories>
        <category>随笔&amp;感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
</search>
