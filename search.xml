<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式——单例模式]]></title>
    <url>%2F2018%2F04%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式属于创建模型。 单例模式，是设计模式中比较简单而又最常用的模式之一。通过单例模式可以保证系统中，应用该模式的类只有一个类实例。例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。 模式定义单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。 实现1. 饿汉式饿汉式提供了线程安全的单例，但是不支持懒加载，在第一次加载类到内存中时就会初始化（所以称之为饿汉，不管怎么样，先初始化了再说）。 1234567891011121314151617/** * 饿汉式单例模式. * * @author BrightLoong. */public class Singleton &#123; /** 全局唯一实例. */ private static final Singleton singleton = new Singleton(); private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; return singleton; &#125;&#125; 2. 非线程安全懒汉式相对饿汉式，懒汉式提供了再需要时候初始化的方式，以下是非线程安全的实现方式，不建议使用。 1234567891011121314151617181920212223/** * 非线程安全的懒汉式. * * @author BrightLoong. */public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; /** * 通过懒加载的方式获取实例，但是非线程安全. * @return Singleton实例 */ public static Singleton getSingleton() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 3. 低效的线程安全懒汉式——使用synchronized使用synchronized进行同步，虽然保证了线程安全，但是并不高效，比较单例模式只有在第一次创建的时候会存在线程安全问题，而不需要在创建单例后在以后的每一次调用还要进行同步。 1234567891011121314151617181920212223/** * 低效的线程安全的懒汉式. * * @author BrightLoong. */public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; /** * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例. * @return Singleton实例 */ public static synchronized Singleton getSingleton() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 4. 双重校验锁线程安全懒汉式相对上面的同步方法，双重校验使用同步块解决线程安全问题。两次检查instance == null，一次是在同步块外，一次是在同步快内。为什么在同步块内还要检验一次，因为可能会有多个线程一起进入同步块外的if，如果在同步块内不进行二次检验的话就会生成多个实例了。 注：受限于Jdk5以前的Java内存模型，仍然会有bug，Java5及之后才能正常达到单例效果。 123456789101112131415161718192021222324252627/** * 双重校验锁线程安全懒汉式. * * @author BrightLoong. */public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; /** * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例. * @return Singleton实例 */ public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 5. 枚举式《Effective Java》一书中推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量），但是不支持懒加载。 12345678910/** * 枚举方式的单例. * * @author BrightLoong. */public enum Singleton &#123; INSTANCE;&#125; 6. 静态内部类使用JVM本身机制保证了线程安全问题，其只有显式通过调用getInstance方法时，才会装载SingletonHolder类，从而实例化instance；同时读取实例的时候不会进行同步，没有性能缺陷，也不依赖JDK版本。 1234567891011121314151617181920212223242526272829/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例. * * @author BrightLoong. */public class Singleton &#123; private Singleton() &#123;&#125; /** * 静态内部类. */ private static final class SingletonHolder &#123; private SingletonHolder() &#123;&#125; private static Singleton instance = new Singleton(); &#125; /** * 通过懒加载的方式获取Singleton唯一实例的方法. * @return Singleton实例 */ public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125;&#125; 以上就是对单例模式的简单介绍，单例模式非常简单，其他的优缺点之类的不再赘述。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——命令模式]]></title>
    <url>%2F2018%2F01%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 简介命令模式 ，将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持撤销的操作。 命令模式的特点是对命令进行了封装，将请求的具体操作封装成命令对象，用户无需知道具体需要执行什么样的操作逻辑，只用调用对应的命令即可，实现了用户请求和请求实现的解耦，方便扩展。 二. 模式结构解析UML类图 Client(客户端)：确定命令接收者，并创建具体的命令。 Invoker(命令发起者)：发起命令执行请求 ICommand(命令抽象接口)：声明的命令抽象接口，具有execute()方法。 ConcreteCommand(命令接口的具体实现)：实现命令接口，实现具体的execute()方法，负责调用命令接收者进行命令执行。 Receiver(命令接受者)：接收请求并执行，具体的请求实现，这里的任何类都有可能成为一个命令接收者。 三. 简单命令模式代码实现1. ICommand命令接口定义1234package brightloong.github.io.command.core.simple;public interface ICommand &#123; public void execute();&#125; 2. ConcreteCommand具体命令实现12345678910111213141516171819202122package brightloong.github.io.command.core.simple.impl;import brightloong.github.io.command.core.simple.ICommand;import brightloong.github.io.command.core.simple.Receiver;public class ConcreteCommand implements ICommand &#123; private Receiver receiver; public ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; /** (non-Javadoc) * @see brightloong.github.io.command.core.simple.ICommand#execute() */ public void execute() &#123; System.out.println("ConcreteCommand发送命令给接给命令接收者！"); receiver.action(); &#125;&#125; 3. Receiver具体的命令接收者实现123456789package brightloong.github.io.command.core.simple;public class Receiver &#123; public void action() &#123; System.out.println("Receiver接收到命令并执行！"); &#125;&#125; 4. Invoker命令调用者12345678910111213141516171819202122package brightloong.github.io.command.core.simple;public class Invoker &#123; private ICommand command; /** * @return the command */ public ICommand getCommand() &#123; return command; &#125; public void setCommand(ICommand command) &#123; this.command = command; &#125; public void action() &#123; System.out.println("命令请求者Invoker发起命令！"); this.command.execute(); &#125;&#125; 5. Client客户端测试代码和结果1234567891011121314package brightloong.github.io.command.core.simple;import brightloong.github.io.command.core.simple.impl.ConcreteCommand;public class Client &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); ICommand command = new ConcreteCommand(receiver); Invoker invoker = new Invoker(); invoker.setCommand(command); invoker.action(); &#125;&#125; 输出结果如下： 123命令请求者Invoker发起命令！ConcreteCommand发送命令给接给命令接收者！Receiver接收到命令并执行！ 四. 宏命令的代码实现宏命令，就是又多条命令组成一个命令，是一个命令的组合。实现如下 1. 新增宏命令抽象定义IMacroCommand12345678910package brightloong.github.io.command.core.macro;import brightloong.github.io.command.core.simple.ICommand;public interface IMacroCommand extends ICommand&#123; public void add(ICommand command); public void remove(ICommand command);&#125; 2. 宏命令具体实现MacroCommandImpl1234567891011121314151617181920212223242526272829303132333435package brightloong.github.io.command.core.macro.impl;import java.util.ArrayList;import java.util.List;import brightloong.github.io.command.core.macro.IMacroCommand;import brightloong.github.io.command.core.simple.ICommand;public class MacroCommandImpl implements IMacroCommand&#123; List&lt;ICommand&gt; commands = new ArrayList&lt;ICommand&gt;(); /** (non-Javadoc) * @see brightloong.github.io.command.core.simple.ICommand#execute() */ public void execute() &#123; for (ICommand command : commands) &#123; command.execute(); &#125; &#125; /** (non-Javadoc) * @see brightloong.github.io.command.core.macro.IMacroCommand#add(brightloong.github.io.command.core.simple.ICommand) */ public void add(ICommand command) &#123; commands.add(command); &#125; /** (non-Javadoc) * @see brightloong.github.io.command.core.macro.IMacroCommand#remove(brightloong.github.io.command.core.simple.ICommand) */ public void remove(ICommand command) &#123; commands.remove(command); &#125;&#125; 3. Receiver新增方法12345678910111213141516package brightloong.github.io.command.core.simple;public class Receiver &#123; public void action() &#123; System.out.println("Receiver接收到命令并执行！"); &#125; public void sing() &#123; System.out.println("大河向东流，天上的形象参北斗..."); &#125; public void playGame() &#123; System.out.println("大吉大利，今晚吃鸡。"); &#125;&#125; 4. 新增命令PlayGameCommand和SingCommand12345678910111213141516171819202122package brightloong.github.io.command.core.simple.impl;import brightloong.github.io.command.core.simple.ICommand;import brightloong.github.io.command.core.simple.Receiver;public class PlayGameCommand implements ICommand &#123; private Receiver receiver; public PlayGameCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; /** (non-Javadoc) * @see brightloong.github.io.command.core.simple.ICommand#execute() */ public void execute() &#123; receiver.playGame(); &#125;&#125; 12345678910111213141516171819202122package brightloong.github.io.command.core.simple.impl;import brightloong.github.io.command.core.simple.ICommand;import brightloong.github.io.command.core.simple.Receiver;public class SingCommand implements ICommand &#123; private Receiver receiver; public SingCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; /** (non-Javadoc) * @see brightloong.github.io.command.core.simple.ICommand#execute() */ public void execute() &#123; receiver.sing(); &#125;&#125; 5. 修改客户端Client以及输出结果展示1234567891011121314151617181920212223package brightloong.github.io.command.core.simple;import brightloong.github.io.command.core.macro.IMacroCommand;import brightloong.github.io.command.core.macro.impl.MacroCommandImpl;import brightloong.github.io.command.core.simple.impl.PlayGameCommand;import brightloong.github.io.command.core.simple.impl.SingCommand;public class Client &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); ICommand singCommand = new SingCommand(receiver); ICommand playGameCommand = new PlayGameCommand(receiver); IMacroCommand macroCommand = new MacroCommandImpl(); macroCommand.add(singCommand); macroCommand.add(playGameCommand); Invoker invoker = new Invoker(); invoker.setCommand(macroCommand); invoker.action(); &#125;&#125; 输出结果如下： 123命令请求者Invoker发起命令！大河向东流，天上的形象参北斗...大吉大利，今晚吃鸡。 五. 使用场景1. 应用场景 使用命令模式作为”CallBack”在面向对象系统中的替代。”CallBack”讲的便是先将一个函数登记上，然后在以后调用此函数。 需要在不同的时间指定请求、将请求排队。一个命令对象和原先的请求发出者可以有不同的生命期。换言之，原先的请求发出者可能已经不在了，而命令对象本身仍然是活动的。这时命令的接收者可以是在本地，也可以在网络的另外一个地址。命令对象可以在串形化之后传送到另外一台机器上去。 系统需要支持命令的撤消(undo)。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用undo()方法，把命令所产生的效果撤销掉。命令对象还可以提供redo()方法，以供客户端在需要时，再重新实施命令效果。 如果一个系统要将系统中所有的数据更新到日志里，以便在系统崩溃时，可以根据日志里读回所有的数据更新命令，重新调用Execute()方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。 2. 具体场景 Multi-level undo（多级undo操作） 如果系统需要实现多级回退操作，这时如果所有用户的操作都以command对象的形式实现，系统可以简单地用stack来保存最近执行的命令，如果用户需要执行undo操作，系统只需简单地popup一个最近的 command对象然后执行它的undo()方法既可。 Transactional behavior（原子事务行为） 借助command模式，可以简单地实现一个具有原子事务的行为。当一个事务失败时，往往需要回退到执行前的状态，可以借助command对象保存这种状态，简单地处理回退操作。 Progress bars（状态条） 假如系统需要按顺序执行一系列的命令操作，如果每个command对象都提供一个 getEstimatedDuration()方法，那么系统可以简单地评估执行状态并显示出合适的状态条。 Wizards（导航） 通常一个使用多个wizard页面来共同完成一个简单动作。一个自然的方法是使用一个command对象来封装wizard过程，该command对象在第一个wizard页面显示时被创建，每个wizard页面接收用户输入并设置到该command对象中，当最后一个wizard页面用户按下“Finish”按钮时，可以简单地触发一个事件调用execute()方法执行整个动作。通过这种方法，command类不包含任何跟用户界面有关的代码，可以分离用户界面与具体的处理逻辑。 GUI buttons and menu items（GUI按钮与菜单条等等） Swing系统里，用户可以通过工具条按钮，菜单按钮执行命令，可以用command对象来封装命令的执行。 Thread pools（线程池） 通常一个典型的线程池实现类可能有一个名为addTask()的public方法，用来添加一项工作任务到任务队列中。该任务队列中的所有任务可以用command对象来封装，通常这些command对象会实现一个通用的接口比如java.lang.Runnable。 Macro recording（宏纪录） 可以用command对象来封装用户的一个操作，这样系统可以简单通过队列保存一系列的command对象的状态就可以记录用户的连续操作。这样通过执行队列中的command对象，就可以完成”Play back”操作了。 Networking 通过网络发送command命令到其他机器上运行。 Parallel Processing（并发处理） 当一个调用共享某个资源并被多个线程并发处理时。 六. 优缺点1. 优点 更松散的耦合 命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。 更动态的控制 命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。 很自然的复合命令 命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。 更好的扩展性 由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。 2. 缺点 同样的和大部分设计模式一样，会增加系统的复杂性，这里主要指的是类的数量的增加。 参考 http://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html http://blog.csdn.net/zdsicecoco/article/details/51332440]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——模板方法模式]]></title>
    <url>%2F2018%2F01%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法属于行为型模式 一. 简介模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 模板方法模式是基于集成的代码复用的模式。 二. UML类图 AbstractTemplate(抽象模板)： templateMethod()：模板方法，可能实现了部分逻辑，并调用abstractMethod()方法，将其他实现延迟到子类中去实现。 abstractMethod()：抽象操作方法，子类集成并实现。 ConcreteTemplate1(抽象模板具体实现1)：实现父类定义的一个或多个抽象方法(也可以不是抽象方法，可以是一个钩子方法，钩子方法可以让子类决定是否对算法的不同点进行挂钩)。 Client(客户端)：调用具体的模板实现 三. 代码实现1. AbstractTemplate抽象模板类1234567891011package brightloong.github.io.template;public abstract class AbstractTemplate &#123; public void templateMehtod() &#123; System.out.println("开始连接，连接成功..."); abstracMethod(); System.out.println("断开连接，释放资源..."); &#125; protected abstract void abstracMethod();&#125; 2. concreteTemplate1抽象模板类具体实现112345678910111213package brightloong.github.io.template;public class ConcreteTemplate1 extends AbstractTemplate&#123; /** (non-Javadoc) * @see brightloong.github.io.template.AbstractTemplate#abstracMethod() */ @Override public void abstracMethod() &#123; System.out.println("查询用户表...."); &#125;&#125; 3. concreteTemplate2抽象模板类具体实现212345678910111213package brightloong.github.io.template;public class ConcreteTemplate2 extends AbstractTemplate&#123; /** (non-Javadoc) * @see brightloong.github.io.template.AbstractTemplate#abstracMethod() */ @Override public void abstracMethod() &#123; System.out.println("查询商品表..."); &#125;&#125; 4. Client客户端调用测试代码和结果1234567891011package brightloong.github.io.template;public class Client &#123; public static void main(String[] args) &#123; AbstractTemplate template = new ConcreteTemplate1(); template.templateMehtod(); System.out.println(""); AbstractTemplate template2 = new ConcreteTemplate2(); template2.templateMehtod(); &#125;&#125; 运行结果如下： 1234567开始连接，连接成功...查询用户表....断开连接，释放资源...开始连接，连接成功...查询商品表...断开连接，释放资源... 四. 使用场景 某些方法中使用了相同的代码或者方法造成代码重复。 控制子类扩展，子类必须遵守一定的算法规则。 HttpServlet就是典型的应用，其中service()方法作为模板方法，而doPost()和doGet()等方法就是可以被子类实现的具体方法。 五. 优缺点1. 优点 可以将公共代码行为进行提取，以达到复用的目的。 子类实现算法的某些细节，有助于算法的扩展。 通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。 2. 缺点 每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简介UML类图]]></title>
    <url>%2F2017%2F10%2F18%2F%E7%AE%80%E4%BB%8BUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML全称Unified Modeling Language 又称统一建模语言或标准建模语言。我们再学习各种框架或者设计模式之类的时候经常会看到UML类图，这里将UML类图一些基本点做一个记录。 在文章中所涉及到的UML类图是使用starUML工具创建，使用其他工具创建会有所不同。 总体印象 上面的UML类图基本展示了UML类图的大部分元素，以及类与类之间的关系，下面将对其一一进行解释。 NOTE UML类图注解的表示方法，如上右半部所示。 类结构表示 类的表示方法如图，一般分为三层，从上到下依次为类名、属性和方法。接口表示和类的表示类似，只是在上面标明了是interface（这只是表示接口的一种方式，并且不同的工具展现方式可能不同，还有一种棒棒糖的形式，就是一个圆加一条竖线，并不常见，所以也不过多介绍），并且这里我隐藏了属性层。如果是抽象类，在使用starUML工具创建的时候类名会以斜线表示。关于类的表示有以下几点： +：public，-：private，#：protected 属性冒号后的内容表示属性的类型 方法冒号后的内容表示属性的返回值 类型说明并不是必须的 类关系表示实现 实现(Realization)，用一个带空心三角箭头的虚线来表示。用来表示接口和实现类的关系。比如：Plane(飞机)和Car(汽车)都实现了接口IVehicle(交通工具)。 继承 继承(Generalization，也称为泛化关系)，用一个带空心三角箭头的实线来表示。表示父类与子类之间的关系。比如：Trunck(卡车)和Bus(公交车)都继承自父类Car(汽车)。 关联关系关联(Association)，关联关系分为以下几种 自关联：用一头带箭头的实线表示，自己指向自己 单向关联：用一头带箭头的实线表示，箭头指向被关联类 双向关联：用一条实线表示，或者使用双箭头 关联关系表示类与类之间的联系，是同一层次上的关系，它不像依赖关系具有偶然性和临时性。一般情况是关联类引用被关联类作为全局变量。如下Human持有Name。 大多数的关联关系都是单向的。 聚合关系 聚合(Aggregation)，用一头是空心菱形的直线表示(有些时候是一头为空心菱形，一头为箭头的实线)。聚合也是关联关系的一种，是整体和部分之间的关系，也就是has-a的关系(很多地方has-a，contains-a已经比较混乱，我理解上来看是has-a)，整体包含部分，但是部分脱离整体后依然可以单独存在。如上：Car(汽车)包含Engine(引擎)，但是Engine脱离了Car依然可以独立存在。 组合关系 组合(Composition)，用一头是实心菱形的直线表示(有些时候是一头为实心菱形，一头为箭头的实线)。组合同样是一种关联关系，也同样是整体和部分之间的关系，我把它理解为contains-a的关系。和聚合的区别在于，部分脱离整体和无法单独存在，整体和部分具有相同的生命周期，整体不存在了，部分也就消失了。如上：Human(人类)包含Head(头)和Body(身体)，头和身体并不能单独存在。 依赖关系 依赖(Dependency)，用一头带箭头的虚线表示。表示类与类之间，一个类依赖于另一个类的定义。被依赖类的变化将会引起依赖类的变化。在java中依赖关系通常体现为，一个类使用另一个类作为局部变量，方法参数或静态方法调用，表示为use-a。如上，Engine的方法startEngine()方法使用Gasoline(汽油)作为参数，可能是调用了Gasoline中的burn()方法。]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用树形结构保存实体]]></title>
    <url>%2F2017%2F10%2F09%2F%E4%BD%BF%E7%94%A8%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E4%BF%9D%E5%AD%98%E5%AE%9E%E4%BD%93%2F</url>
    <content type="text"><![CDATA[之前在项目需要实现一个功能——将xml文件映射成实体，然后对映射的实体进行逻辑处理，最后保存到数据库中；由于xml结构的数据是结构化的数据，所以需要保证保存的数据具有正确的主外键关联。如下所示，是一个需要保存到数据库的xml文件。当映射成对应的实体school和student的时候，我们需要知道“school-one”下面有哪些学生，“school-two”下面有哪些学生，这个时候想到了使用树形结构来保存实体，让实体之间依然存在关联关系。 1234567891011121314151617181920&lt;school-inf&gt; &lt;msg&gt;2017-10-1XX省学校信息总汇&lt;/msg&gt; &lt;schools&gt; &lt;school&gt; &lt;name&gt;school-one&lt;/name&gt; &lt;students&gt; &lt;student&gt;Jack&lt;/student&gt; &lt;student&gt;Rose&lt;/student&gt; &lt;student&gt;Jon&lt;/student&gt; &lt;/students&gt; &lt;/school&gt; &lt;school&gt; &lt;name&gt;school-two&lt;/name&gt; &lt;students&gt; &lt;student&gt;Bob&lt;/student&gt; &lt;student&gt;Alisa&lt;/student&gt; &lt;/students&gt; &lt;/school&gt; &lt;/schools&gt;&lt;/school-inf&gt; 树形工具以下是树形工具类的实现，包含了树形节点类和树形结构类，由于代码中注释已经比较全面，所以不做过多的说明。 树形节点类BeanTreeNode.java每一个节点对应一个实体，节点包含了实体信息，为了保证实体之间的关联关系，需要留有父节点信息，所有的子节点信息。由此推断出，节点的主要成员有 父节点信息 所有子节点信息 当前实体信息 为了方便操作，我还多增加了id和pid（parent id）,以及节点类型（nodeType）。对id的相关操作我并没有添加，如果需要可以自行添加。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import java.util.ArrayList;import java.util.List;import java.util.UUID;/** * 实体树形结构点 * BeanTreeNode * @author BrightLoong * @version 1.0 * */public class BeanTreeNode &#123; /**标识id*/ private String id; /**父id标识，为了方便获取冗余出来*/ private String pid; /**父节点*/ private BeanTreeNode parentNode; /**节点类型*/ private String nodeType; /**节点值*/ private Object bean; /**子节点*/ private List&lt;BeanTreeNode&gt; childNodes; /** * @param parentNode * @param nodeType * @param bean * @param childNodes */ public BeanTreeNode(BeanTreeNode parentNode, String nodeType, Object bean) &#123; this.parentNode = parentNode; this.nodeType = nodeType; this.bean = bean; this.childNodes = new ArrayList&lt;BeanTreeNode&gt;(); this.id = UUID.randomUUID().toString().replaceAll("-", ""); if (parentNode != null) &#123; this.pid = parentNode.getId(); &#125; &#125; /** * @return the nodeType */ public String getNodeType() &#123; return nodeType; &#125; /** * @param nodeType the nodeType to set */ public void setNodeType(String nodeType) &#123; this.nodeType = nodeType; &#125; /** * @return the parentNode */ public BeanTreeNode getParentNode() &#123; return parentNode; &#125; /** * @param parentNode the parentNode to set */ public void setParentNode(BeanTreeNode parentNode) &#123; this.parentNode = parentNode; &#125; /** * @return the bean */ public Object getBean() &#123; return bean; &#125; /** * @param bean the bean to set */ public void setBean(Object bean) &#123; this.bean = bean; &#125; /** * @return the childNodes */ public List&lt;BeanTreeNode&gt; getChildNodes() &#123; return childNodes; &#125; /** * @param childNodes the childNodes to set */ public void setChildNodes(List&lt;BeanTreeNode&gt; childNodes) &#123; this.childNodes = childNodes; &#125; /** * @return the id */ public String getId() &#123; return id; &#125; /** * @param id the id to set */ public void setId(String id) &#123; this.id = id; &#125; /** * @return the pid */ public String getPid() &#123; return pid; &#125; /** * @param pid the pid to set */ public void setPid(String pid) &#123; this.pid = pid; &#125; /** * 是否具有子节点 * @return true or false */ public boolean haveChild() &#123; return !CollectionUtils.isEmpty(childNodes); &#125;&#125; 树形结构类BeanTree.javaBeanTree.java里面包含了如下的一些常用操作： 返回根节点 返回最后添加节点 判断是否具有子节点 添加节点 移动节点到其他节点下 获取对应nodeType的所有节点或实体 根据实体获取节点 获取父节点 转化为map结构 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315import java.util.ArrayList;import java.util.Collection;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.collections.CollectionUtils;/** * 实体树形结构 * BeanTree * @author BrightLoong * @version 1.0 * */public class BeanTree &#123; /**根节点*/ private BeanTreeNode root; /** * 最新添加的节点 */ private BeanTreeNode currentNode; /** * @return the currentNode */ public BeanTreeNode getCurrentNode() &#123; return currentNode; &#125; /** * @return the root */ public BeanTreeNode getRoot() &#123; return root; &#125; /** * 判断节点是否有子节点. * @param node 要判断的节点 * @return true or false */ public boolean haveChild(BeanTreeNode node) &#123; return CollectionUtils.isEmpty(node.getChildNodes()); &#125; /** * 在父节点上面添加节点，并返回天添加的节点. * @param parentNode 父节点 * @param bean 要添加的bean * @param nodeType 节点类型 * @return 返回包含bean的节点 */ public BeanTreeNode addNode(BeanTreeNode parentNode, Object bean, String nodeType) &#123; BeanTreeNode node; if (bean == null) &#123; return null; &#125; //如果没有父节点说明为root根节点 if (parentNode == null) &#123; node = root = new BeanTreeNode(null, nodeType, bean); &#125; else &#123; //创建子节点，并添加到父节点上 node = new BeanTreeNode(parentNode, nodeType, bean); parentNode.getChildNodes().add(node); &#125; currentNode = node; return node; &#125; /** * 将当期bean-sBean,以及sBean下的子Bean，挂到dBean下 * @param sBean 源Bean * @param dBean 目的父Bean */ public void removeTo(Object sBean, Object dBean) &#123; BeanTreeNode sNode = getNodeByBean(sBean); BeanTreeNode dNode = getNodeByBean(dBean); removeTo(sNode, dNode); &#125; /** * 将当期node-sNode,以及sNode下的子Node，挂到dNode下 * @param sNode 源node * @param dNode 目的父node */ public void removeTo(BeanTreeNode sNode, BeanTreeNode dNode) &#123; //从当前父节点移除sNode sNode.getParentNode().getChildNodes().remove(sNode); //将sNode移到dNode下 dNode.getChildNodes().add(sNode); //修改sNode的父Id和父节点 sNode.setPid(dNode.getId()); sNode.setParentNode(dNode); &#125; /** * 获取父bean. * @param bean 子bean * @return 返回父bean */ public Object getParentBean(Object bean) &#123; return getNodeByBean(bean).getParentNode().getBean(); &#125; /** * 根据传入的bean获取bean下面对应类型的子bean. * @param bean 当前bean * @param nodeType 节点类型 * @return 子bean的集合 */ public List&lt;Object&gt; getBeanListByBeanAndNodeType(Object bean, String nodeType) &#123; BeanTreeNode node = getNodeByBean(bean); return getBeanListByNodeType(node, nodeType); &#125; /** * 根据传入的bean获取包含bean的Node节点 * @param node 当前node * @param bean 要查找的bean * @return node节点 */ public BeanTreeNode getNodeByBean(BeanTreeNode node, Object bean) &#123; BeanTreeNode resultNode = null; if (node.getBean().equals(bean)) &#123; resultNode = node; return resultNode; &#125; else &#123; for (BeanTreeNode tempNode : node.getChildNodes()) &#123; resultNode = getNodeByBean(tempNode, bean); if (resultNode != null) &#123; break; &#125; &#125; &#125; return resultNode; &#125; /** * 根据传入的bean获取root节点下包含bean的Node节点 * @param bean 要查找的bean * @return node节点 */ public BeanTreeNode getNodeByBean(Object bean) &#123; return getNodeByBean(root, bean); &#125; /** * 根据节点类型返回当前节点下对应节点类型的bean的list集合. * 默认如果当前节点满足类型，那么当前节点不会存在相同类型的子节点 * @param node 当前节点 * @param nodeType 节点类型 * @return */ @SuppressWarnings("unchecked") public &lt;T&gt; List&lt;T&gt; getBeanListByNodeType(BeanTreeNode node, String nodeType) &#123; List&lt;T&gt; beanList = new ArrayList&lt;T&gt;(); if (node.getNodeType().equals(nodeType)) &#123; beanList.add((T)node.getBean()); &#125; else &#123; for (BeanTreeNode tempNode : node.getChildNodes()) &#123; beanList.addAll((Collection&lt;? extends T&gt;) getBeanListByNodeType(tempNode, nodeType)); &#125; &#125; return beanList; &#125; /** * 根据节点类型返回根节点下对应节点类型的bean的list集合. * @param nodeType 节点类型 * @return */ public &lt;T&gt; List&lt;T&gt; getBeanListByNodeType(String nodeType) &#123; return getBeanListByNodeType(root, nodeType); &#125; /** * 从root节点开始获取对应nodeType的node. * @param nodeType 节点类型 * @return nodeType类型的节点集合 */ public List&lt;BeanTreeNode&gt; getNodeListByNodeType(String nodeType) &#123; return getNodeListByNodeType(root, nodeType); &#125; /** * 从node节点开始获取对应nodeType的node. * @param node node节点 * @param nodeType 节点类型 * @return nodeType类型的节点集合 */ public List&lt;BeanTreeNode&gt; getNodeListByNodeType(BeanTreeNode node, String nodeType) &#123; List&lt;BeanTreeNode&gt; nodeList = new ArrayList&lt;BeanTreeNode&gt;(); if(node==null)&#123; return nodeList; &#125; if (nodeType.equals(node.getNodeType())) &#123; nodeList.add(node); &#125; else &#123; for (BeanTreeNode tempNode : node.getChildNodes()) &#123; nodeList.addAll(getNodeListByNodeType(tempNode, nodeType)); &#125; &#125; return nodeList; &#125; /** * 将树形结构转化为map. * @return */ public Map&lt;String, List&lt;Object&gt;&gt; toMap() &#123; return toMap(root); &#125; /** * 将对应节点及其子节点转化为map. * @param node 树节点 * @return 转化后的map */ public Map&lt;String, List&lt;Object&gt;&gt; toMap(BeanTreeNode node) &#123; Map&lt;String, List&lt;Object&gt;&gt; map = new HashMap&lt;String, List&lt;Object&gt;&gt;(); toMap(node, map); return map; &#125; /** * 根据传入的nodeType删除对应的节点以及其所有子节点. * @param nodeType */ public void delNodeByNodeType(String nodeType) &#123; delNodeByNodeType(root, nodeType); &#125; /** * 删除node节点下，类型为nodeType的节点和所有子节点 * @param node * @param nodeType */ public void delNodeByNodeType(BeanTreeNode node, String nodeType) &#123; List&lt;BeanTreeNode&gt; nodeList = getNodeListByNodeType(node, nodeType); for (BeanTreeNode beanTreeNode : nodeList) &#123; beanTreeNode.getParentNode().getChildNodes().remove(beanTreeNode); &#125; &#125; /** * 从树结构里面删除bean和相关node. * @param bean bean */ public void delNodeByBean(Object bean) &#123; BeanTreeNode node = getNodeByBean(bean); BeanTreeNode parentNode = node.getParentNode(); List&lt;BeanTreeNode&gt; childNodes = parentNode.getChildNodes(); Iterator&lt;BeanTreeNode&gt; it = childNodes.iterator(); while (it.hasNext()) &#123; BeanTreeNode beanTreeNode = it.next(); if (node == beanTreeNode) &#123; it.remove(); &#125; &#125; &#125; /** * 根据class返回对应的beanList. * @param cls class * @return beanList */ public &lt;T&gt; List&lt;Object&gt; getBeanListByClass(Class&lt;T&gt; cls) &#123; return getBeanListByClass(root, cls); &#125; /** * 根据class返回对应的beanList. * @param node 节点 * @param cls class * @return beanList */ public &lt;T&gt; List&lt;Object&gt; getBeanListByClass(BeanTreeNode node, Class&lt;T&gt; cls) &#123; List&lt;Object&gt; beanList = new ArrayList&lt;Object&gt;(); Object bean = node.getBean(); if (cls.isAssignableFrom(bean.getClass())) &#123; beanList.add(bean); &#125; List&lt;BeanTreeNode&gt; childNodes = node.getChildNodes(); for (BeanTreeNode beanTreeNode : childNodes) &#123; beanList.addAll(getBeanListByClass(beanTreeNode, cls)); &#125; return beanList; &#125; /** * 将对应节点及其子节点转化为map. * @param node 树节点 * @param map 用来保存结果的map */ private void toMap(BeanTreeNode node, Map&lt;String, List&lt;Object&gt;&gt; map) &#123; String key = node.getNodeType(); Object bean = node.getBean(); if (map.containsKey(key)) &#123; map.get(key).add(bean); &#125; else &#123; List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); list.add(bean); map.put(key, list); &#125; for (BeanTreeNode tempNode : node.getChildNodes()) &#123; toMap(tempNode, map); &#125; &#125;&#125; 测试树形工具使用上面的xml进行测试，这里就不再做xml映射，假设存在上面xml所示的所有实体，“school-one”和“school-two”以及5个student，看看能否构造出想要的结构，测试类代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class SchoolInf &#123; private String msg; public SchoolInf(String msg) &#123; this.msg = msg; &#125;&#125;class Student &#123; private String name; public Student(String name) &#123; this.name = name; &#125;&#125;class School &#123; private String name; public School(String name) &#123; this.name = name; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; SchoolInf schoolInf = new SchoolInf("2017-10-1XX省学校信息总汇"); School school_one = new School("school-one"); School school_two = new School("school-two"); Student Jack = new Student("Jack"); Student Rose = new Student("Rose"); Student Jon = new Student("Jon"); Student Bob = new Student("Bob"); Student Alisa = new Student("Alisa"); BeanTree tree = new BeanTree(); BeanTreeNode root = tree.addNode(null, schoolInf, "root"); BeanTreeNode school_node1 = tree.addNode(root, school_one, "school"); BeanTreeNode school_node2 = tree.addNode(root, school_two, "school"); tree.addNode(school_node1, Jack, "root"); tree.addNode(school_node1, Rose, "root"); tree.addNode(school_node1, Jon, "root"); tree.addNode(school_node2, Bob, "root"); tree.addNode(school_node2, Alisa, "root"); System.out.println("end"); &#125;&#125; 我们通过调试观察树结构变量“tree”的值如下： 可以看出来能够构造出正确的结构，BeanTree中其他的一些方法这里就不在一一测试了。 更新记录 2018/1/10，在BeanTree中添加更多的操作方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java项目间通过文件调用方法工具（frequest）]]></title>
    <url>%2F2017%2F09%2F19%2FJava%E9%A1%B9%E7%9B%AE%E9%97%B4%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一.简介frequest：这是一个用JAVA编写的，可以通过文件进行方法调用请求传输的工具。 项目gitgub地址：https://github.com/BrightLoong/frequest 二.背景之前在项目中遇到一下的需求，如图所示: 甲处要访问部署在乙处的服务serverB(因为数据库在乙处)，不过因为一些限制原因导致甲乙两地的网络不通。但是甲乙两地之间有一个文件传输的系统仅仅可以进行文件的传输交换。 基于以上的条件，考虑在甲地也搭建一个同样的服务serverA（A和B相同，并都加入对请求的处理），。但是过滤它对service层的调用，将方法调用放入文件中（也就是请求文件中），然后将文件发送到乙地对应目录（文件发送的功能并不由这两个系统负责）。serverB将解析文件的请求，调用对应方法，并将结果也存到文件中发送到甲的服务器serveA处，实现请求的响应。 这里把拦截本地方法调用，生请求文件，等待远端返回结果和远端响应文件请求并将结果生成问文件的功能抽取出来，并对这部分功能进行了提炼重构，修改了一些问题，形成了工具frquest(file-request)。 三.具体思路 甲：本地服务，需要点去远端服务乙 乙：远端服务，可自己访问自己，亦可以接收甲的请求 甲处发起请求，调用了方法，使用aspectj对方法调用进行拦截 对拦截到的方法进行解析，记录下调用方法名，参数，类，接口等信息，并将信息放入传输bean生成json字符串，写入到文件 把生成的请求文件发送到指定目录，并等待远端返回结果 …… 乙远端扫描到请求文件，开始远端方法调用 对文件进行解析，反过来转为json字符串，再转为传输Bean，从中获取方法名，参数等信息，进行一定的处理。使用反射（invok）调用方法，把得到的结果放入传输Bean中，转为json字符串放入结果文件，发送到指定目录 …… 甲检测到结果文件，转为json字符串，再转为传输Bean，获取结果信息。 四. 使用可在java项目中使用。 1. 引用 直接下载jar包，下载地址http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22frequest%22 使用maven的方式引用 12345&lt;dependency&gt; &lt;groupId&gt;io.github.brightloong&lt;/groupId&gt; &lt;artifactId&gt;frequest&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 注：如果是java项目需要继承aspectj环境，如果是集成了spring的web项目需要开启aspectj支持 2. 配置发送接收文件的目录请求端的发送目录是指拦截请求生成的请求文件，接收目录是指发送请求后等待接收的结果文件的目录。 远端的发送目录是值生成的结果文件的发送目录，接收目录是指扫描请求端的请求文件的目录。 项目中使用了xml配置的方式，格式如下。 注：本工具不负责文件的传输，所以如果想用该工具在本机做测试，可以把远端和请求端的send-path和receive-path交替配置 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configs&gt; &lt;config&gt; &lt;send-path&gt;d:\send&lt;/send-path&gt; &lt;receive-path&gt;d:\receive&lt;/receive-path&gt; &lt;/config&gt; &lt;!--远端可以配置多个config，可能会有多个请求端需要同一个远端响应,请求端配置多个也默认只取第一个--&gt; &lt;config&gt; &lt;send-path&gt;d:\send&lt;/send-path&gt; &lt;receive-path&gt;d:\receive&lt;/receive-path&gt; &lt;/config&gt;&lt;/configs&gt; 3. 请求端（被拦截端）配置 同样首先需要配置收发文件目录（也就是上面说的xml） 如果是简单的java项目可使用下面的方式启动。 继承ServiceProxyInterceptor并且实现serviceAroundImpl()方法 在实现方法类调用父类的serviceAround() 标注上@Around注解 在Around里面加入切入点，PointConstants.POINT_SERVICE是在工具中定义的一个切入点，也就是对具有自定义注解 @ServiceProxy的方法进行拦截，也可以定义自己的切入点。 启动frequest功能，如下mian()方法中前两行代码所示。 如下，如果要对say()方法进行拦截，则加上 @ServiceProxy注解(前提是你使用了定义的切入点PointConstants.POINT_SERVICE，并且要保证请求端和远端拥有相同的方法，包括方法所在的类和包) 1234567891011121314151617181920212223@Aspectpublic class Test extends ServiceProxyInterceptor&#123; @Override @Around(PointConstants.POINT_SERVICE) public Object serviceAroundImpl(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; return super.serviceAround(proceedingJoinPoint); &#125; @ServiceProxy public String say(String msg) &#123; System.out.println(msg); return msg; &#125; public static void main(String[] args) &#123; //setIsRemote(false),设置为请求端，并设置xml的目录。 NormalConfig.getInstance().setXmlConfigPath("com/test/xml/config.xml").setIsRemote(false); //开启frequest功能 StartEngine.start(); Test test = new Test(); System.out.println(test.say("hello")); &#125;&#125; 4. 远端（相应文件请求端）配置 同样首先需要配置收发文件目录（也就是上面说的xml） 如果是简单的java项目可使用下面的方式启动。如果是web项目，同样也是调用mian()方法中的两行代码，保证其能在合适的地方进行调用，启动功能。 12345678public class Start &#123; public static void main(String[] args) &#123; //setIsRemote(true),设置为远端，并设置xml的目录。 NormalConfig.getInstance().setIsRemote(true).setXmlConfigPath("com/test/xml/config.xml"); //开启frequest功能 StartEngine.start(); &#125;&#125; ​ ​ 5. 其他配置下面的配置具有默认值，所以不进行配置也是可以的。 sleepTime：休眠时间，单位ms，扫描文件变动的间隔时间和等待远端返回结果的每次等待时间，默认是100ms。 waitCount：请求端等待远端返回结果的次数，每次间隔时间为sleepTime，所以总共等待时间为waitCount*sleepTime(ms)。默认等待次数是300次 12//设置休眠时间sleepTime,设置等待结果次数300次 NormalConfig.getInstance().setSleepTime(100).setWaitCount(300); 五. LICENSE遵循Apache License 2.0]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>frequest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组->JSON字符串->数组过程中的问题]]></title>
    <url>%2F2017%2F09%2F03%2F%E6%95%B0%E7%BB%84-JSON%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%95%B0%E7%BB%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[之前在使用 alibaba的fastjson做数组的相关转换操作的时候遇到一些问题，这里把遇到的问题以及如何解决的记录如下。 一. 转换过程中的问题话不多说，先上代码。 12345678910111213public class JsonTest &#123; public static void main(String[] args) &#123; //创建一个String数组 String[][] stringArray = new String[][]&#123;&#123;"1","2","3"&#125;,&#123;"4","5","6"&#125;&#125;; //使用fastjson转为json字符串 String jsonString = JSON.toJSONString(stringArray); System.out.println(jsonString); //解析json字符串后输出class发现是jsonArray的。 Object array = JSON.parse(jsonString); System.out.println(array.getClass()); &#125;&#125; 输出结果是： 123Before class:class [[Ljava.lang.String;[["1","2","3"],["4","5","6"]]After class:class com.alibaba.fastjson.JSONArray 遇到的问题如上，把一个数组转为json字符串后，再使用用JSON.parse()转换回来，获取到的class类型却是JSONArray的。 当然你也可以用很简单的办法把他给转换成需要的String二维数组。不过我的需求是： 只知道是个数组，知道到数组的原始Class类型(如果是String[][]知道是String.class) 不知道是几维数组，也不知道最开始传入的数组的长度 在拿到从Json字符串转换回来的object的时候，必须要使用原始类型(比如是String[][],那么转换回来的object，使用object.getClass()应该得到[[Ljava.lang.String)，否则无法使用。 为了解决上述问题，在网上查阅各种资料无果，最后突然想到查询数组的反射，找到了java.lang.reflect.Array这个包，下面对这个包里面的一些使用做一个简单的介绍。 二. 关于java.lang.reflect.Array同样先上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class ArrayTest &#123; /** * 创建一维数组. * @param cls 数组基本类型Class * @param length 创建数组长度 * @return 创建的数组 */ public static Object creatOneDimArray(Class cls, int length) &#123; return Array.newInstance(cls, length); &#125; /** * 创建多维数组. * @param cls 数组基本类型Class * @param dims 维度信息 * @return 创建的数组 */ public static Object creatMultiDimsArray(Class cls, int[] dims) &#123; return Array.newInstance(cls, dims); &#125; /** * 获取数组的长度和class信息. * @param array 使用Array.newInstance()创建的array * @return 长度和class信息 */ public static String getArrayInfo(Object array) &#123; Class cls = array.getClass(); //只会返回第一维度的长度，比如String[1][2][3]返回1，String[3][4]返回3 int length = Array.getLength(array); return "CLASS:" + cls + "-----" + "LENGTH:" + length; &#125; public static void main(String[] args) &#123; //创建长度为10的一维String数组 Object oneArray = creatOneDimArray(String.class, 10); System.out.println(getArrayInfo(oneArray)); //创建一个[2,3,4]的二维String数组 int[] dims = new int[]&#123;2,3,4&#125;; Object threeArray = creatMultiDimsArray(String.class,dims); System.out.println(getArrayInfo(threeArray)); //************************** //* 数组赋值操作 * //************************** //---------1.强制转换赋值 ((String[])oneArray)[1] = "hello"; ((String[])oneArray)[9] = " world"; System.out.println(((String[])oneArray)[1] + ((String[])oneArray)[9]); ((String[][][])threeArray)[1][2][3] = "hello"; ((String[][][])threeArray)[0][1][3] = " java"; System.out.println(((String[][][])threeArray)[1][2][3] + ((String[][][])threeArray)[0][1][3]); //--------2.使用Array.set()进行赋值操作 //使用Array.get()可以获取到下一维的值，比如三维的获取到二维 //获取三维中index=1的二维数组，Strign[1][][]。 Object two = Array.get(threeArray,1); //从输出可以看到获取到的是一个二维数组 System.out.println("CLASS:" + two.getClass()); //对String[1][0][]赋值 Array.set(two,0,new String[]&#123;"this"," is"," a"," test"&#125;); System.out.println(((String[][][])threeArray)[1][0][0] + ((String[][][])threeArray)[1][0][1] + ((String[][][])threeArray)[1][0][2] + ((String[][][])threeArray)[1][0][3]); //再获取一维String[1][1][] Object one = Array.get(two,1); System.out.println("CLASS:" + one.getClass()); Array.set(one,0,"my"); Array.set(one,1," name"); Array.set(one,2," is"); Array.set(one,3," brightloong"); System.out.println(((String[][][])threeArray)[1][1][0] + ((String[][][])threeArray)[1][1][1] + ((String[][][])threeArray)[1][1][2] + ((String[][][])threeArray)[1][1][3]); &#125;&#125; 输出结果是： 12345678CLASS:class [Ljava.lang.String;-----LENGTH:10CLASS:class [[[Ljava.lang.String;-----LENGTH:2hello worldhello javaCLASS:class [[Ljava.lang.String;this is a testCLASS:class [Ljava.lang.String;my name is brightloong 这里已经在上述代码中做了大部分的注释，这里也不在详细介绍，主要说一下几个方法的作用。 Array.newInstance(Class&lt;?&gt; componentType, int length)和Array.newInstance(Class&lt;?&gt; componentType, int... dimensions)第一个用于创建传入类型的长度为length的一维数组，第二个可以用于创建传入类型的多维数组，维度和长度由传入的第二个参数决定。 Array.get(Object array, int index)用于获取传入的数组array的index下的内容。 Array.set(Object array, int index, Object value)用于对传入的数组array的index进行赋值，赋值为value，具体使用见上述的代码。 三. 如何解决转换问题在具备了以上的了解后，再来解决所遇到的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class JsonArrayToArray &#123; public static void main(String[] args) &#123; //创建一个String数组 String[][] stringArray = new String[][]&#123;&#123;"1","2","3"&#125;,&#123;"4","5","6"&#125;&#125;; //使用fastjson转为json字符串 String jsonString = JSON.toJSONString(stringArray); System.out.println(jsonString); //解析json字符串后输出class发现是jsonArray的。 Object array = JSON.parse(jsonString); System.out.println(array.getClass()); Object realArray = null; try &#123; realArray = getArrayInstanceByClassAndArg(String.class, array); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; parseJsonArray(array, realArray); System.out.println(realArray.getClass()); System.out.println(realArray.getClass().equals(String[][].class)); &#125; /** * 解析jsonArray还原为最开始的数组 * @param o 解析后的类型是jsonArray的参数 * @param array 实际要组装的数组 */ private static void parseJsonArray(Object o, Object array) &#123; parseJsonArray(o, array, null, 0); &#125; /** * 利用递归调用，解析jsonArray还原为最开始的数组 * @param o 解析后的类型是jsonArray的参数 * @param array 实际要组装的数组 * @param lastArray 上一个array * @param index index */ private static void parseJsonArray(Object o, Object array, Object lastArray, int index) &#123; JSONArray tempArray; //如果class不是JSONArray，使用Array.set()赋值 if (!o.getClass().equals(JSONArray.class)) &#123; Array.set(lastArray,index , o); return; &#125; //如果是JSONArray,继续继续循环递归调用 tempArray = (JSONArray)o; for (int i = 0; i &lt; tempArray.size(); i++) &#123; Object arrayTemp = Array.get(array, i); parseJsonArray(tempArray.get(i), arrayTemp, array, i); &#125; &#125; /** * 根据class和传入的解析后的类型是jsonArray的参数，获取对应维度和大小的数组 * @param cls Class * @param argValue 解析后的类型是jsonArray的参数 * @return 返回数组 * @throws ClassNotFoundException 异常 */ private static Object getArrayInstanceByClassAndArg(Class cls, Object argValue) throws ClassNotFoundException &#123; Object temp = argValue; JSONArray tempArray; List&lt;Integer&gt; dimsInf = new ArrayList&lt;Integer&gt;(); //获取jsonArray对应的数组维度和长度 while (temp.getClass().equals(JSONArray.class)) &#123; tempArray = (JSONArray)temp; dimsInf.add(tempArray.size()); temp = tempArray.get(0); &#125; int[] dims = new int[dimsInf.size()]; for (int i = 0; i &lt; dimsInf.size(); i++) &#123; dims[i] = dimsInf.get(i); &#125; //返回对应的数组 return Array.newInstance(cls, dims); &#125;&#125; 输出结果是： 1234[["1","2","3"],["4","5","6"]]class com.alibaba.fastjson.JSONArrayclass [[Ljava.lang.String;true 可以看到最后被将转换后的Class为JSONArray的结果在转换为最初的数组类型，String[][]，由最后realArray.getClass().equals(String[][].class)返回结果true也可以得到确实转换正确了。具体的解析方法可以看上面的parseJsonArray()方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JSONArray转数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Commons FileUpload]]></title>
    <url>%2F2017%2F07%2F24%2FApache-Commons-FileUpload%2F</url>
    <content type="text"><![CDATA[Apache Commons FileUpload是用于解析上传文件的包。这里将其一些简单的特性和使用进行一个大概的介绍。 一.简介用于解析上传的文件，”Form-based File Upload in HTML”。也就是说,如果使用POST方法提交HTTP请求,并且使用内容类型“multipart / form-data”,则FileUpload可以解析该请求。 二.简单使用1.满足的条件 form表单使用POST请求,并且form表单的内容格式要定义成multipart/form-data格式 form表单内，要添加空间&lt;input type=&quot;file&quot; name=&quot;&quot;&gt;或者其他的比如：Uploadify插件 123456&lt;form method="POST" enctype="multipart/form-data" action="fup.cgi"&gt; File to upload: &lt;input type="file" name="upfile"&gt;&lt;br/&gt; Notes about the file: &lt;input type="text" name="note"&gt;&lt;br/&gt; &lt;br/&gt; &lt;input type="submit" value="Press"&gt; to upload the file!&lt;/form&gt; 2.具体使用 使用前判断是否有上传文件的请求 12// Check that we have a file upload requestboolean isMultipart = ServletFileUpload.isMultipartContent(request); 简单的例子 12345678910111213// Create a factory for disk-based file itemsDiskFileItemFactory factory = new DiskFileItemFactory();// Configure a repository (to ensure a secure temp location is used)，默认会放在System.getProperty("java.io.tmpdir")ServletContext servletContext = this.getServletConfig().getServletContext();File repository = (File) servletContext.getAttribute("javax.servlet.context.tempdir");factory.setRepository(repository);// Create a new file upload handlerServletFileUpload upload = new ServletFileUpload(factory);// Parse the requestList&lt;FileItem&gt; items = upload.parseRequest(request); 加入一些控制的例子 12345678910111213141516// Create a factory for disk-based file itemsDiskFileItemFactory factory = new DiskFileItemFactory();// Set factory constraints//默认为10k，小于这个值的会放在内容中，否则放在设置的disk路径下factory.setSizeThreshold(yourMaxMemorySize);factory.setRepository(yourTempDirectory);// Create a new file upload handlerServletFileUpload upload = new ServletFileUpload(factory);// Set overall request size constraint，最大上传文件upload.setSizeMax(yourMaxRequestSize);// Parse the requestList&lt;FileItem&gt; items = upload.parseRequest(request); 也可以一并配置多个属性 12// Create a factory for disk-based file itemsDiskFileItemFactory factory = new DiskFileItemFactory(yourMaxMemorySize, yourTempDirectory); 获取上传的文件信息 123456789// Process a file uploadif (!item.isFormField()) &#123; String fieldName = item.getFieldName(); String fileName = item.getName(); String contentType = item.getContentType(); boolean isInMemory = item.isInMemory(); long sizeInBytes = item.getSize(); ...&#125; 保存文件前获取文件的一些方式 123456789// Process a file uploadif (writeToFile) &#123; File uploadedFile = new File(...); item.write(uploadedFile);&#125; else &#123; InputStream uploadedStream = item.getInputStream(); ... uploadedStream.close();&#125; OR 123// Process a file upload in memorybyte[] data = item.get();... 三.清理文件仅仅适用于DiskFileItem,也就是说在上传前，文件被写入了临时文件，如果不再使用这些临时文件，则需要删除这些临时文件。DiskFileItemFactory有一个属性FileCleaningTracker，设置这个属性可以用来追踪删除临时文件。当这个临时文件不再被使用时将会被立即删除，更精确的说是这个文件对象被垃圾收集器回收时，FileCleaningTracker将启动收割者线程(reaper thread)自动删除这个临时文件。 为了确保这个后台线程在它不再被需要时被停止，在 servlet 环境里，我们通过一个名叫 FileCleanerCleanup 的 servlet 上下文监听器，在web应用关闭时调用FileCleaningTracker.exitWhenFinished()来终止收割机线程。在servlet环境中，使用 FileCleanerCleanup,FileCleanerCleanup提供了FileCleaningTracker的一个实例，要让FileCleanerCleanup监听器工作，你需要在 web.xml 增加如下代码：。 123456789&lt;web-app&gt; ... &lt;listener&gt; &lt;listener-class&gt; org.apache.commons.fileupload.servlet.FileCleanerCleanup &lt;/listener-class&gt; &lt;/listener&gt; ...&lt;/web-app&gt; 在使用FileCleanerCleanup,应该像下面这样创建DiskFileItemFactory1234567891011public static DiskFileItemFactory newDiskFileItemFactory(ServletContext context, File repository) &#123; //FileCleaningTracker类，这个类用于跟踪要删除的文件 FileCleaningTracker fileCleaningTracker = FileCleanerCleanup.getFileCleaningTracker(context); DiskFileItemFactory factory = new DiskFileItemFactory(DiskFileItemFactory.DEFAULT_SIZE_THRESHOLD, repository); factory.setFileCleaningTracker(fileCleaningTracker); return factory;&#125; 四.上传进度下面是一个创建进度监听的一个例子12345678910111213//Create a progress listenerProgressListener progressListener = new ProgressListener()&#123; public void update(long pBytesRead, long pContentLength, int pItems) &#123; System.out.println("We are currently reading item " + pItems); if (pContentLength == -1) &#123; System.out.println("So far, " + pBytesRead + " bytes have been read."); &#125; else &#123; System.out.println("So far, " + pBytesRead + " of " + pContentLength + " bytes have been read."); &#125; &#125;&#125;;upload.setProgressListener(progressListener); 但是这样会存在问题，有可能会被频繁的调用而造成性能问题。123456789101112131415161718//Create a progress listenerProgressListener progressListener = new ProgressListener()&#123; private long megaBytes = -1; public void update(long pBytesRead, long pContentLength, int pItems) &#123; long mBytes = pBytesRead / 1000000; if (megaBytes == mBytes) &#123; return; &#125; megaBytes = mBytes; System.out.println("We are currently reading item " + pItems); if (pContentLength == -1) &#123; System.out.println("So far, " + pBytesRead + " bytes have been read."); &#125; else &#123; System.out.println("So far, " + pBytesRead + " of " + pContentLength + " bytes have been read."); &#125; &#125;&#125;; 如果想在页面展示，可以自己实现一个ProgressListener接口，将进度的相关信息放在session中。通过ajax之类的进行调用。具体可以参照博客– Common-FileUpload带进度条上传]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>apache commons</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现一个简单的缓存]]></title>
    <url>%2F2017%2F04%2F17%2FJAVA%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;缓存是在web开发中经常用到的，将程序经常使用到或调用到的对象存在内存中，或者是耗时较长但又不具有实时性的查询数据放入内存中，在一定程度上可以提高性能和效率。下面我实现了一个简单的缓存，步骤如下。 创建缓存对象EntityCache.java123456789101112131415161718192021222324252627282930313233343536373839404142public class EntityCache &#123; /** * 保存的数据 */ private Object datas; /** * 设置数据失效时间,为0表示永不失效 */ private long timeOut; /** * 最后刷新时间 */ private long lastRefeshTime; public EntityCache(Object datas, long timeOut, long lastRefeshTime) &#123; this.datas = datas; this.timeOut = timeOut; this.lastRefeshTime = lastRefeshTime; &#125; public Object getDatas() &#123; return datas; &#125; public void setDatas(Object datas) &#123; this.datas = datas; &#125; public long getTimeOut() &#123; return timeOut; &#125; public void setTimeOut(long timeOut) &#123; this.timeOut = timeOut; &#125; public long getLastRefeshTime() &#123; return lastRefeshTime; &#125; public void setLastRefeshTime(long lastRefeshTime) &#123; this.lastRefeshTime = lastRefeshTime; &#125; &#125; 定义缓存操作接口，ICacheManager.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public interface ICacheManager &#123; /** * 存入缓存 * @param key * @param cache */ void putCache(String key, EntityCache cache); /** * 存入缓存 * @param key * @param cache */ void putCache(String key, Object datas, long timeOut); /** * 获取对应缓存 * @param key * @return */ EntityCache getCacheByKey(String key); /** * 获取对应缓存 * @param key * @return */ Object getCacheDataByKey(String key); /** * 获取所有缓存 * @param key * @return */ Map&lt;String, EntityCache&gt; getCacheAll(); /** * 判断是否在缓存中 * @param key * @return */ boolean isContains(String key); /** * 清除所有缓存 */ void clearAll(); /** * 清除对应缓存 * @param key */ void clearByKey(String key); /** * 缓存是否超时失效 * @param key * @return */ boolean isTimeOut(String key); /** * 获取所有key * @return */ Set&lt;String&gt; getAllKeys();&#125; 实现接口ICacheManager，CacheManagerImpl.java&emsp;&emsp;这里我使用了ConcurrentHashMap来保存缓存，本来以为这样就是线程安全的，其实不然，在后面的测试中会发现它并不是线程安全的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class CacheManagerImpl implements ICacheManager &#123; private static Map&lt;String, EntityCache&gt; caches = new ConcurrentHashMap&lt;String, EntityCache&gt;(); /** * 存入缓存 * @param key * @param cache */ public void putCache(String key, EntityCache cache) &#123; caches.put(key, cache); &#125; /** * 存入缓存 * @param key * @param cache */ public void putCache(String key, Object datas, long timeOut) &#123; timeOut = timeOut &gt; 0 ? timeOut : 0L; putCache(key, new EntityCache(datas, timeOut, System.currentTimeMillis())); &#125; /** * 获取对应缓存 * @param key * @return */ public EntityCache getCacheByKey(String key) &#123; if (this.isContains(key)) &#123; return caches.get(key); &#125; return null; &#125; /** * 获取对应缓存 * @param key * @return */ public Object getCacheDataByKey(String key) &#123; if (this.isContains(key)) &#123; return caches.get(key).getDatas(); &#125; return null; &#125; /** * 获取所有缓存 * @param key * @return */ public Map&lt;String, EntityCache&gt; getCacheAll() &#123; return caches; &#125; /** * 判断是否在缓存中 * @param key * @return */ public boolean isContains(String key) &#123; return caches.containsKey(key); &#125; /** * 清除所有缓存 */ public void clearAll() &#123; caches.clear(); &#125; /** * 清除对应缓存 * @param key */ public void clearByKey(String key) &#123; if (this.isContains(key)) &#123; caches.remove(key); &#125; &#125; /** * 缓存是否超时失效 * @param key * @return */ public boolean isTimeOut(String key) &#123; if (!caches.containsKey(key)) &#123; return true; &#125; EntityCache cache = caches.get(key); long timeOut = cache.getTimeOut(); long lastRefreshTime = cache.getLastRefeshTime(); if (timeOut == 0 || System.currentTimeMillis() - lastRefreshTime &gt;= timeOut) &#123; return true; &#125; return false; &#125; /** * 获取所有key * @return */ public Set&lt;String&gt; getAllKeys() &#123; return caches.keySet(); &#125;&#125; CacheListener.java,监听失效数据并移除。1234567891011121314151617181920212223public class CacheListener&#123; Logger logger = Logger.getLogger("cacheLog"); private CacheManagerImpl cacheManagerImpl; public CacheListener(CacheManagerImpl cacheManagerImpl) &#123; this.cacheManagerImpl = cacheManagerImpl; &#125; public void startListen() &#123; new Thread()&#123; public void run() &#123; while (true) &#123; for(String key : cacheManagerImpl.getAllKeys()) &#123; if (cacheManagerImpl.isTimeOut(key)) &#123; cacheManagerImpl.clearByKey(key); logger.info(key + "缓存被清除"); &#125; &#125; &#125; &#125; &#125;.start(); &#125;&#125; 测试类TestCache.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TestCache &#123; Logger logger = Logger.getLogger("cacheLog"); /** * 测试缓存和缓存失效 */ @Test public void testCacheManager() &#123; CacheManagerImpl cacheManagerImpl = new CacheManagerImpl(); cacheManagerImpl.putCache("test", "test", 10 * 1000L); cacheManagerImpl.putCache("myTest", "myTest", 15 * 1000L); CacheListener cacheListener = new CacheListener(cacheManagerImpl); cacheListener.startListen(); logger.info("test:" + cacheManagerImpl.getCacheByKey("test").getDatas()); logger.info("myTest:" + cacheManagerImpl.getCacheByKey("myTest").getDatas()); try &#123; TimeUnit.SECONDS.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; logger.info("test:" + cacheManagerImpl.getCacheByKey("test")); logger.info("myTest:" + cacheManagerImpl.getCacheByKey("myTest")); &#125; /** * 测试线程安全 */ @Test public void testThredSafe() &#123; final String key = "thread"; final CacheManagerImpl cacheManagerImpl = new CacheManagerImpl(); ExecutorService exec = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 100; i++) &#123; exec.execute(new Runnable() &#123; public void run() &#123; if (!cacheManagerImpl.isContains(key)) &#123; cacheManagerImpl.putCache(key, 1, 0); &#125; else &#123; //因为+1和赋值操作不是原子性的，所以把它用synchronize块包起来 synchronized (cacheManagerImpl) &#123; int value = (Integer) cacheManagerImpl.getCacheDataByKey(key) + 1; cacheManagerImpl.putCache(key,value , 0); &#125; &#125; &#125; &#125;); &#125; exec.shutdown(); try &#123; exec.awaitTermination(1, TimeUnit.DAYS); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; logger.info(cacheManagerImpl.getCacheDataByKey(key).toString()); &#125;&#125; testCacheManager()输出结果如下：1234567891011122017-4-17 10:33:51 io.github.brightloong.cache.TestCache testCacheManager信息: test:test2017-4-17 10:33:51 io.github.brightloong.cache.TestCache testCacheManager信息: myTest:myTest2017-4-17 10:34:01 io.github.brightloong.cache.CacheListener$1 run信息: test缓存被清除2017-4-17 10:34:06 io.github.brightloong.cache.CacheListener$1 run信息: myTest缓存被清除2017-4-17 10:34:11 io.github.brightloong.cache.TestCache testCacheManager信息: test:null2017-4-17 10:34:11 io.github.brightloong.cache.TestCache testCacheManager信息: myTest:null testThredSafe()输出结果如下（选出了各种结果中的一个举例）：122017-4-17 10:35:36 io.github.brightloong.cache.TestCache testThredSafe信息: 96 可以看到并不是预期的结果100，为什么呢？ConcurrentHashMap只能保证单次操作的原子性，但是当复合使用的时候，没办法保证复合操作的原子性，以下代码：123if (!cacheManagerImpl.isContains(key)) &#123; cacheManagerImpl.putCache(key, 1, 0); &#125; 多线程的时候回重复更新value，设置为1，所以出现结果不是预期的100。所以办法就是在CacheManagerImpl.java中都加上synchronized，但是这样一来相当于操作都是串行，使用ConcurrentHashMap也没有什么意义，不过只是简单的缓存还是可以的。或者对测试方法中的run里面加上synchronized块也行，都是大同小异。更高效的方法我暂时也想不出来，希望大家能多多指教。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java静态代理&动态代理笔记]]></title>
    <url>%2F2017%2F03%2F17%2FJava%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在学习Java反射的一些知识，看到了一些有关代理的例子，好记性不如烂笔头，所以这里将它记录下来。接下来话不多说，直接进入主题。 代理：为其他对象提供一个代理以控制对某个对象的访问。 静态代理 接口 123public interface IDoSomething &#123; public int doSometing(int num);&#125; 被代理类的实现 12345678public class Sing implements IDoSomething &#123; @Override public int doSometing(int num) &#123; System.out.println("Sing a song"); return num; &#125;&#125; 代理类的实现 12345678910111213 public class SingProxy implements IDoSomething&#123; private IDoSomething sing = new Sing(); @Override public int doSometing(int num) &#123; System.out.println("Befor singing "); int result = sing.doSometing(num); System.out.println("After singing"); return result; &#125;&#125; 测试类 12345678public class ProxyDemo &#123; public static int sing(IDoSomething sing, int num) &#123; return sing.doSometing(num); &#125; public static void main(String[] args) &#123; System.out.println(ProxyDemo.sing(new SingProxy(), 5)); &#125; &#125; 输出结果 1234Befor singing Sing a songAfter singing5 &emsp;&emsp;以上就是简单的静态代理，不在过多的介绍，下面是动态代理。 动态代理&emsp;&emsp;Java的动态代理可以动态的创建代理并动态的处理对所代理方法的调用。动态代理有两种实现方法，一种是使用JDK自带的，一种是使用Cglib实现。 实现JDK自带的动态代理&emsp;&emsp;实现JDK自带的动态代理，关键是实现InvocationHandler，同时它要求被代理对象必须有接口。下面是实现的代码，我加上了必要的注释。 接口 123public interface IProxyClass &#123; public int doSomething(int i);&#125; 被代理类的实现 1234567public class ProxyClassImpl implements IProxyClass &#123; @Override public int doSomething(int num) &#123; System.out.println("方法执行中....."); return num; &#125;&#125; 实现InvocationHandler接口 &emsp;&emsp;这里我实现了InvocationHandler接口，并手动生成了代理类，保存到了电脑F盘上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class DynamicProxyHandler implements InvocationHandler &#123; private Object proxied; /** * @param proxied 被代理对象 */ public DynamicProxyHandler(Object proxied) &#123; this.proxied = proxied; &#125; /** * 返回代理对象 * @return */ public Object newProxyInstance() &#123; return Proxy.newProxyInstance(proxied.getClass().getClassLoader(), proxied.getClass().getInterfaces(), this); &#125; /** * * @param proxy 代理对象 * @param method 代理方法 * @param args 方法参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //将代理对象生成字节码到F盘上，方便反编译出java文件查看，实际动态代理是不需要自己生成的 addClassToDisk(proxy.getClass().getName(), ProxyClassImpl.class,"F:/$Proxy0.class"); System.out.println("method:"+method.getName()); System.out.println("args:"+args[0].getClass().getName()); System.out.println("Before invoke method..."); Object object=method.invoke(proxied, args); System.out.println("After invoke method..."); return object; &#125; /** * 用于生产代理对象的字节码，并将其保存到硬盘上 * @param className * @param cl * @param path */ private void addClassToDisk(String className, Class&lt;?&gt; cl, String path) &#123; //用于生产代理对象的字节码 byte[] classFile = ProxyGenerator.generateProxyClass(className, cl.getInterfaces()); FileOutputStream out = null; try &#123; out = new FileOutputStream(path); //将代理对象的class字节码写到硬盘上 out.write(classFile); out.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 测试类 123456789public class SimpleProxyDemo &#123; public static void main(String[] args) throws SecurityException, NoSuchMethodException &#123; ProxyClassImpl c = new ProxyClassImpl(); DynamicProxyHandler proxyHandler = new DynamicProxyHandler(c); IProxyClass proxyClass = (IProxyClass)proxyHandler.newProxyInstance(); System.out.println(proxyClass.getClass().getName()); System.out.println(proxyClass.doSomething(5)); &#125;&#125; 输出结果 1234567com.sun.proxy.$Proxy0method:doSomethingargs:java.lang.IntegerBefore invoke method...方法执行中.....After invoke method...5 &emsp;&emsp;从结果我们可以看到(IProxyClass)proxyHandler.newProxyInstance();实际返回的是com.sun.proxy.$Proxy0，我们把生成的$Proxy0.class文件，使用jad.exe进行反编译，使用命令（要求文件和jad.exe在同一个目录下，或者你可以吧jad加到环境变量中去）： jad -p java $Proxy0.class 得到的$Proxy0.java如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public final class $Proxy0 extends Proxy implements IProxyClass&#123; public $Proxy0(InvocationHandler invocationhandler) &#123; super(invocationhandler); &#125; public final boolean equals(Object obj) &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[] &#123; obj &#125;)).booleanValue(); &#125; catch(Error _ex) &#123; &#125; catch(Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final void doSomething(int i) &#123; try &#123; super.h.invoke(this, m3, new Object[] &#123; Integer.valueOf(i) &#125;); return; &#125; catch(Error _ex) &#123; &#125; catch(Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final int hashCode() &#123; try &#123; return ((Integer)super.h.invoke(this, m0, null)).intValue(); &#125; catch(Error _ex) &#123; &#125; catch(Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final String toString() &#123; try &#123; return (String)super.h.invoke(this, m2, null); &#125; catch(Error _ex) &#123; &#125; catch(Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; private static Method m1; private static Method m3; private static Method m0; private static Method m2; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] &#123; Class.forName("java.lang.Object") &#125;); m3 = Class.forName("io.github.brightloong.proxy.IProxyClass").getMethod("doSomething", new Class[] &#123; Integer.TYPE &#125;); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); &#125; catch(NoSuchMethodException nosuchmethodexception) &#123; throw new NoSuchMethodError(nosuchmethodexception.getMessage()); &#125; catch(ClassNotFoundException classnotfoundexception) &#123; throw new NoClassDefFoundError(classnotfoundexception.getMessage()); &#125; &#125;&#125; 可以看到实际调用的是25行的doSometing()方法。如果你想了解更加具体的JDK动态代理的实现原理可以访问Rejoy的博文JDK动态代理实现原理。 使用Cglib实现动态代理&emsp;&emsp;Cglib不是jdk自带的jar包，需要下载并加入到项目中。个人觉得Cglib比使用jdk自带的实现动态代理更为先进，毕竟它不再需要接口，而且它还有其他强大的功能，大家可以自行研究。 实现MethodInterceptor接口 12345678910111213141516171819202122232425262728293031public class CglibProxy implements MethodInterceptor&#123; private Enhancer enhancer = new Enhancer(); @Override /** * * @param o 是被代理对象 * @param method 调用方法的Method对象 * @param args 方法参数 * @param methodProxy * @return cglib生成用来代替Method对象的一个对象，使用MethodProxy比调用JDK自身的Method直接执行方法效率会有提升 * @throws Throwable */ public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;before &quot; + methodProxy.getSuperName()); System.out.println(method.getName()); Object o1 = methodProxy.invokeSuper(o, args); //Object o2 = method.invoke(o, args); 使用这种方式会发生死循环，因为方法会被拦截 System.out.println(&quot;after &quot; + methodProxy.getSuperName()); return o1; &#125; public Object newProxyInstance(Class&lt;?&gt; c) &#123; //设置产生的代理对象的父类。 enhancer.setSuperclass(c); //设置CallBack接口的实例 enhancer.setCallback(this); //使用默认无参数的构造函数创建目标对象 return enhancer.create(); &#125;&#125; 被代理对象和测试类 12345678910111213public class CglibDemo &#123; public static void main(String[] args) &#123; CglibProxy cglibProxy = new CglibProxy(); Do o = (Do)cglibProxy.newProxyInstance(Do.class); System.out.println(o.doSomething(5)); &#125;&#125;class Do&#123; public int doSomething(int num)&#123; System.out.println("方法执行中。。。。。。"); return num; &#125;&#125; 输出结果 12345before CGLIB$doSomething$0doSomething方法执行中。。。。。。after CGLIB$doSomething$05 本篇笔记参考于：http://www.cnblogs.com/shijiaqi1066/p/3429691.htmlhttp://rejoy.iteye.com/blog/1627405]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>静态代理</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web之限制用户多处登录]]></title>
    <url>%2F2017%2F03%2F08%2FJava-Web%E4%B9%8B%E9%99%90%E5%88%B6%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%A4%9A%E5%A4%84%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在项目中遇到一个需求，要求限制单个用户在多个终端登录（比如用户在A处登录，然后又在B处登录，此时A处就应该被挤下线）。最开始我是想使用spring的security直接通过配置实现，简单又方便。不过很可惜的是，我所做的项目使用的是公司封装的框架，依然在使用sprign2.X。好吧，既然这个方法行不通，那我自己老老实实写代码实现吧，想想网上实现的方法应该很多吧，度娘、谷歌走一波，果断很多，不过过去过来感觉都是同一个。还有就是什么使用application啊，session什么的。最后，我还是自己动手，丰衣足食吧。首先我说一下自己的思路： 用一个全局Map在登录的时候用来保存sessionId，Map的key为登录名，value为sessionID，因为是后来的挤掉前面的，所以不用判断，直接覆盖Map中的值就OK。实现一个HttpSessionListener，在session销毁(比如session过期)的时候清除Map中对应的值。实现一个Filter，用于拦截请求，判断改用当前的sessionId是否在Map中，如果不在执行退出操作。 用来保存登入用户SessionID的类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class LoginUserMap &#123; private static Map&lt;String, String&gt; loginUsers = new ConcurrentHashMap&lt;String, String&gt;(); /** * 将用户和sessionId存入map * @param key * @param value */ public static void setLoginUsers(String loginId, String sessionId) &#123; loginUsers.put(loginId, sessionId); &#125; /** * 获取loginUsers * @return */ public static Map&lt;String, String&gt; getLoginUsers() &#123; return loginUsers; &#125; /** * 根据sessionId移除map中的值 * @param sessionId */ public static void removeUser(String sessionId) &#123; for (Map.Entry&lt;String, String&gt; entry : loginUsers.entrySet()) &#123; if (sessionId.equals(entry.getValue())) &#123; loginUsers.remove(entry.getKey()); break; &#125; &#125; &#125; /** * 判断用户是否在loginusers中 * @param loginId * @param sessionId * @return */ public static boolean isInLoginUsers(String loginId, String sessionId) &#123; return (loginUsers.containsKey(loginId) &amp;&amp; sessionId.equals(loginUsers.get(loginId))); &#125; &#125; 在登录方法中保存sessionID&emsp;&emsp;这里我就不给出具体的实现了，毕竟不同的项目是不同的，我写个大概的步骤，帮助理解：12345678910//登录方法所在的地方public void login(ttpServletRequest request) &#123; try &#123; ......//一系列登录的方法 HttpSession session = request.getSession(); LoginUserMap.setLoginUsers(username, session.getId());//保存sessionId到map中 &#125; catch (LoginException ex) &#123; throw ex; &#125;&#125; 实现HttpSessionListener12345678910111213141516171819202122232425public class SessionListener implements HttpSessionListener &#123; private Log log = LogFactory.getLog(SessionListener.class); /** * 创建session时候的动作 * @param event */ @Override public void sessionCreated(HttpSessionEvent event) &#123; &#125; /** * 销毁session时候的动作 * @param event */ @Override public void sessionDestroyed(HttpSessionEvent event) &#123; HttpSession session = event.getSession(); String sessionId = session.getId(); //移除loginUsers中已经被销毁的session LoginUserMap.removeUser(sessionId); log.info(sessionId + "被销毁！"); &#125;&#125; xml配置如下： 123&lt;listener&gt; &lt;listener-class&gt;io.github.brightloong.loginlimite.SessionListener&lt;/listener-class&gt;&lt;/listener&gt; Filter实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class LoginLimitFilter implements Filter&#123; private Log log = LogFactory.getLog(LoginLimitFilter.class); /** * 销毁时的方法 */ @Override public void destroy() &#123; &#125; /** * 过滤请求 * @param request * @param response * @param filterChain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest servletRequest = (HttpServletRequest) request; HttpServletResponse servletResponse = (HttpServletResponse) response; HttpSession session = servletRequest.getSession(); //获取项目路径 String path = servletRequest.getContextPath(); String basePath = servletRequest.getScheme()+"://"+servletRequest.getServerName()+":"+servletRequest.getServerPort()+path; try &#123; //获取用户信息，如果没获取到会抛出错误,我的是这样,代表用户还没有登录 IUser user = UserUtils.getCurrUserInfo(); String loginId = user.getLoginId(); //判断当前用户的sessionId是否在loginUsers中，如果没有执行if后的操作 if(!LoginUserMap.isInLoginUsers(loginId, session.getId())) &#123; //当前用户logout logout();//自己的logout方法 //调到登录页面，并表明退出方式为挤下线 servletResponse.sendRedirect(basePath + "?logoutway=edge"); &#125; &#125; catch (Exception e) &#123; log.debug("获取当前用户信息失败，用户未登陆！", e); &#125; finally &#123; filterChain.doFilter(request, response); &#125; &#125; /** * 初始化方法 * @param arg0 * @throws ServletException */ @Override public void init(FilterConfig arg0) throws ServletException &#123; &#125;&#125; xml配置如下：12345678&lt;filter&gt; &lt;filter-name&gt;LoginLimitFilter&lt;/filter-name&gt; &lt;filter-class&gt;io.github.brightloong.loginlimite.LoginLimitFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;LoginLimitFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 显示提示信息&emsp;&emsp;当用户点击的时候就会触发filter去监测，如果监测到已经登录，就会转到登录页面，这个时候要判断是否是被挤下来的，我这使用了layer提示框。123456789101112131415161718192021222324window.onload = function()&#123; if(window.parent != window)&#123; window.parent.location.href=window.location.href; &#125; else &#123; if(GetQueryString('logoutway')) &#123; //alert('该用户已在其他地方登录，你已下线'); layer.alert('该账号已在其他地方登录，您已被迫下线，如非本人操作请重新登录并及时修改密码', &#123; skin: 'layui-layer-lan', //样式类名 title: '提示' ,closeBtn: 0 &#125;, function()&#123; var url = window.location.href; window.location.href = url.substr(0,url.indexOf('?logoutway=edge')); &#125;); &#125; &#125;&#125;function GetQueryString(name)&#123; var reg = new RegExp("(^|&amp;)"+ name +"=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if(r!=null)return unescape(r[2]); return null;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>用户登录限制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合&单元测试集成备忘]]></title>
    <url>%2F2017%2F03%2F06%2FSSM%E6%95%B4%E5%90%88-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9B%86%E6%88%90%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;SSM框架，既是Sping + Spring MVC + Mybatis，本篇博文主要是作为本人的备忘，记录如何整合SSM框架，以及如何集成单元测试，关于每一个配置的作用大都加上了注释，至于如何搭建项目这里不在赘述（我使用的是web项目），可以自己查找相关资料。我使用的Spring版本是4.1.3.RELEASE，Mybatis版本是3.3.0，使用Maven进行构建。 注意：首先申明如下的配置是根据我的目录结构来配置的，我的目录结构如下所示： 使用Maven添加相关jar包。&emsp;&emsp;关于pom.xml的配置如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ssm_test&lt;/groupId&gt; &lt;artifactId&gt;ssm_test&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;ssm_test&lt;/name&gt; &lt;description /&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!--配置依赖包 --&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 1.日志，slf4j规范 日志实现：log4j,logback,commin-logging 使用：slf4j + logback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2.数据库相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3.dao mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis自身实现的整合spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4.servelet web 相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 5.spring的依赖 --&gt; &lt;!-- 1)spring核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring aop 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2)spring dao层依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3)spring web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4)spring test依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;warSourceDirectory&gt;$&#123;basedir&#125;/WebRoot&lt;/warSourceDirectory&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; SSM整合配置&emsp;&emsp;为了使配置层次清楚，结构清晰，我把配置按照web、service和dao分别分为spring-web.xml、spring-service.xml和spirng-dao.xml，下面依次介绍这几个配置文件。 spring-web.xm配置&emsp;&emsp;该配置中主要是一些资源映射的相关配置。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 配置springMVC --&gt; &lt;!-- 1.开启springMVC注解模式 --&gt; &lt;!-- 简化配置： 1)自动注册defaultAnnotationHandlerMapping,AnnotationMethodHandlARadpter 2)提供一系列：数据绑定，数字和日期的format @NumberFoamat,@DataTiemFormat xml,json默认读写支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--2.servelt-mapping 映射路径:"/" 静态资源默认servlet配置 1.加入对静态资源的处理：js，gif，png 2.允许用/做整体映射--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3. 配置jsp显示viewResolver--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"&gt;&lt;/property&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的包 --&gt; &lt;context:component-scan base-package="com.chenlong.study.web"&gt;&lt;/context:component-scan&gt; &lt;!-- 获取properties --&gt; &lt;bean id="propertyConfigurer" class="com.chenlong.study.utils.PropertyUtil"&gt; &lt;property name="locations" &gt; &lt;list&gt; &lt;value&gt;classpath:*.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; &emsp;&emsp;在上述配置中最后关于获取properties的配置，我创建了一个PropertyUtil类用来获取properties文件，并读取里面的属性。PropertyUtil.java如下：1234567891011121314151617181920public class PropertyUtil extends PropertyPlaceholderConfigurer &#123; private static Map&lt;String,String&gt; propertyMap; @Override protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props) throws BeansException &#123; super.processProperties(beanFactoryToProcess, props); propertyMap = new HashMap&lt;String, String&gt;(); for (Object key : props.keySet()) &#123; String keyStr = key.toString(); String value = props.getProperty(keyStr); propertyMap.put(keyStr, value); &#125; &#125; //static method for accessing context properties public static Object getProperty(String name) &#123; return propertyMap.get(name); &#125;&#125; spring-service.xml配置&emsp;&emsp;配置自动扫描，用于自动注入；并配置注解事务。1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 扫描service包下的所有注解类型 --&gt; &lt;context:component-scan base-package="com.chenlong.study.service"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置事务管理器，dataSource在spring-dao.xml中配置 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明事务 默认使用注解来管理事务行为--&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 配置spring-dao.xml&emsp;&emsp;在配置sprign-dao.xml之前，先配置mybatis的全局文件mybatis-config.xml如下：123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true"&gt;&lt;/setting&gt; &lt;!-- 使用列命替换别名 --&gt; &lt;setting name="useColumnLabel" value="true"&gt;&lt;/setting&gt; &lt;!-- 开启驼峰命名转换 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"&gt;&lt;/setting&gt; &lt;/settings&gt;&lt;/configuration&gt; &emsp;&emsp;在jdbc.properties中配置数据库信息如下：1234jdbc.username=rootjdbc.password=jdbc.driverClass=com.mysql.jdbc.Driverjdbc.jdbcUrls=jdbc:mysql://localhost:3306/test?useUnicode\=true&amp;amp;characterEncoding\=UTF-8 &emsp;&emsp;然后配置spring-dao.xml如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置整合mybatis过程 --&gt; &lt;!-- 1.配置数据库相关参数 --&gt; &lt;!-- 引入属性文件 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt; &lt;!-- 2.配置数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrls&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;!-- 配置连接池私有属性 --&gt; &lt;property name="maxPoolSize" value="30"&gt;&lt;/property&gt; &lt;property name="minPoolSize" value="10"&gt;&lt;/property&gt; &lt;!-- 关闭连接后不自动提交 --&gt; &lt;property name="autoCommitOnClose" value="false"&gt;&lt;/property&gt; &lt;!--获取连接超时时间 --&gt; &lt;property name="checkoutTimeout" value="1000"&gt;&lt;/property&gt; &lt;!-- 重试次数 --&gt; &lt;property name="acquireRetryAttempts" value="2"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 3.配置sqlsessionfactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 配置mybatis全局文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;!-- 扫描entity包使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.chenlong.study.entity"&gt;&lt;/property&gt; &lt;!-- 扫描mapper文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/chenlong/study/dao/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描dao接口包，动态实现dao接口，自动注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlsessionfactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;!-- 给出扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.chenlong.study.dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 配置web.xml&emsp;&emsp;在完成上述配置后，配置web.xml，配置springmvc和spring的servlet1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;sh_student&lt;/display-name&gt; &lt;!-- 配置springmvc dispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispacherservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispacherservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 单元测试集成&emsp;&emsp;在pom.xm文件中我们曾加入如下的jar包用来做单元测试。123456789101112&lt;!-- 4)spring test依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &emsp;&emsp;下面我给出一个测试示例:1234567891011121314151617//整合junit和spring，让junit在启动时候加载springIOC容器@RunWith(SpringJUnit4ClassRunner.class)//告诉junit spring的配置文件,需要用到的配置文件，如果是dao的话可以不用spring-service.xml@ContextConfiguration(&#123; "classpath:spring-dao.xml", "classpath:spring-service.xml" &#125;)public class SeckillServiceTest &#123; @Autowired private SeckillService seckillService; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Test public void testGetSeckillList() &#123; List&lt;Seckill&gt; seckills = seckillService.getSeckillList(); logger.info("list=&#123;&#125;", seckills); &#125;&#125; &emsp;&emsp;关于SSM框架的整合和单元测试的集成就到此结束。]]></content>
      <categories>
        <category>ssm&amp;ssh</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类的初始化顺序]]></title>
    <url>%2F2017%2F02%2F27%2F%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在看回顾Java基础的时候，发现看似很简单的类初始化的顺序却并不是那么简单（往往越是简单的东西反而越容易出错呢），所以我觉得还是把它写下来，作为自己的备忘录比较好。既然都记录了我觉得我还是记录得比较全面的较好，所以显得有点啰嗦。 普通类的初始化（不存在继承，内部类的时候）&emsp;&emsp;为了更详细的验证类的初始化顺序，首先我创建了一个被另一个类使用的类B.java1234567891011121314151617181920212223public class B &#123; private int varOneInB = initInt("varOneInB"); // 6 14 private static int staticVarOneInB = initInt("staticVarOneB"); // 4 private int varTwoInB = initInt("varTwoInB"); // 7 15 private static int staticvarTwoInB = initInt("staticvarTwoInB"); // 5 /** * 构造方法 */ public B() &#123; System.out.println("B constructor"); // 8 16 &#125; /** * 用于对int类型的变量赋值 * @param varName * @return */ private static int initInt(String varName) &#123; System.out.println(varName + " init"); return 2017; &#125;&#125; &emsp;&emsp;然后我创建了一个A类来验证初始化顺序，并且在该类中同时使用的static变量和static块等。123456789101112131415161718192021222324252627282930313233343536373839public class A &#123; private int varOneInA = initInt("varOneInA"); // 11 private static int staticVarOneInA = initInt("staticVarOneInA"); // 1 &#123; int varTwoInA = initInt("varTwoInA"); // 12 &#125; static &#123; int staticvarTwoInA = initInt("staticvarTwoInA"); // 2 &#125; private B b = new B(); // 13 private static B staticB = new B(); // 3 /** * 构造方法 */ public A() &#123; System.out.println("A constructor"); // 17 &#125; /** * 用于对int型变量赋值 * @param varName * @return */ private static int initInt(String varName) &#123; System.out.println(varName + " init"); return 2017; &#125; public void run() &#123; System.out.println("run be called");// 23 &#125; public static void main (String[] args) &#123; System.out.println("start running");// 9 A a = new A();// 10 a.run();// 18 &#125;&#125; 运行后结果为：123456789101112131415staticVarOneInA initstaticvarTwoInA initstaticVarOneB initstaticvarTwoInB initvarOneInB initvarTwoInB initB constructorstart runningvarOneInA initvarTwoInA initvarOneInB initvarTwoInB initB constructorA constructorrun be called &emsp;&emsp;对《Think in java》这本书里面的关于初始化顺序的总结进行归纳如下： 注意：即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。 即使没有显示地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类的对象时（构造器可以看出静态方法），或者类的静态方法/静态域被首次访问时，Java解释器必须查找类路径。 然后载入class，有关静态初始化的所有动作都会执行（所以静态初始化只在Class对象首次被加载的时候进行一次）。 当使用new创建对象的时候，首先将在堆上为对象分配足够的存储空间。 这块存储空间会被清零，这就自动将Dog对象中的所有基本类型数据都设置成了默认值（对数字来说就是0，对布尔类型和字符类型也相同），而引用就则被设置成了null。 执行出现于字段定义出的初始化动作。 执行构造器。 &emsp;&emsp;有了上面的知识点，再来看上面的结果。我用数字1 2 3做了标记，括号后的阿拉伯数字表示上面代码对应的地方。 在类A中执行main方法，由于main()是静态方法，必须加载A类，然后起静态域staticVarOneInA(1)，staticvarTwoInA(2)，staticB(3)被初始化。 在staticB被初始化的时候，导致B类被加载，因为是第一次加载，对静态域进行初始化，因此staticVarOneInB(4)，staticvarTwoInB(5)被初始化。 之后顺序初始化varOneInB(6)，varTwoInB(7)，执行构造器B(8)。 在A静态域初始化后，回到main()方法，打印出了“start running”(9),在new A()(10)的时候，分配a对象的空间，开始顺序初始化varOneInA(11)，varTwoInA(12)和b(13)，初始化b的时候因为不是第一次加载，所以staticVarOneInB，staticvarTwoInB不再被初始化，只是初始化了varOneInB(14)，varTwoInB(15)，然后执行构造B(16)。 初始化完成后，调用A的构造器(17)；最后通过a.run()调用run(18)方法，打印出“run be called”。 具有继承的类的初始化&emsp;&emsp;下面，我创建了一个Father类和一个继承Father类的Son类，来探究在有继承的时候类的初始化和加载，情况基本和上面类似，我就不再写太多的注释了。Father类如下：12345678910111213public class Father &#123; private int varInFather = initInt("varInFather"); private static int staticVarInFather = initInt("staticVarInFather"); public Father(String name) &#123; System.out.println("Father constructor" + " name:" + name); &#125; private static int initInt(String varName) &#123; System.out.println(varName + " init"); return 2017; &#125;&#125; Son.java如下：12345678910111213141516171819public class Son extends Father&#123; private int varInSon = initInt("varInSon"); private static int staticVarInSon = initInt("staticVarInSon"); public Son(String name) &#123; super(name); System.out.println("Son constructor" + " name:" + name); &#125; private static int initInt(String varName) &#123; System.out.println(varName + " init"); return 2017; &#125; public static void main(String[] args) &#123; System.out.println("start running"); Son son = new Son("Bob"); &#125;&#125; 输出结果如下；1234567staticVarInFather initstaticVarInSon initstart runningvarInFather initFather constructor name:BobvarInSon initSon constructor name:Bob &emsp;&emsp;同样的，我将《Think in java》中的关于继承的类加载和初始化归纳如下： 注意：即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。 （同上）即使没有显示地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类的对象时（构造器可以看出静态方法），或者类的静态方法/静态域被首次访问时，Java解释器必须查找类路径，在对它进行加载的过程中，编译器注意到它有一个基类（有extends得知），于是它继续加载，不管你时候打算产生一个该基类的对象。如果该基类还有其自身的基类，那么第二个基类就会被加载，如此类推。 接下来，根基类的static初始化会被执行，然后是下一个导出类，如此类推。 必要的类加载完成后，对象就可以被创建。同样的，首先对象中所有的基本类型都会被设为默认值，对象引用被设为null——通过将对象内存设为二进制零值而一举生成。 然后基类的构造器会被调用。基类构造器和导出类的构造器一样，以相同的顺序来经历相同的过程。 在基类构造器完成之后，实例变量按其次序被初始化。 最后，构造器的其余部分被执行。 &emsp;&emsp;在有了上述归纳后，我们来分析上面程序的结果。 在类Son中执行main方法，由于main()是静态方法，必须加载Son类，在加载的时候发现其有父类Father，进而加载Father类。 Father类被加载的时候，其静态变量staticVarInFather被初始化，之后Son类中的静态变量staticVarInSon被初始化。 回到main方法，打印出“start running” 在执行new Son(“Bob”)的时候，对基类也就是Father中的varInFather进行初始化，之后Father的构造器被调用。 之后导出类变量varInSon被初始化，调用导出类Son的构造器。 具有继承的静态内部类&emsp;&emsp;关于这个的讲解，我引用一道2015携程Java工程师笔试题。来自csdb博客fuck两点水的 2015携程JAVA工程师笔试题(基础却又没多少人做对的面向对象面试题)。题目如下：1234567891011121314151617181920212223242526public class Base&#123; private String baseName = &quot;base&quot;; public Base() &#123; callName(); &#125; public void callName() &#123; System. out. println(baseName); &#125; static class Sub extends Base &#123; private String baseName = &quot;sub&quot;; public void callName() &#123; System. out. println (baseName) ; &#125; &#125; public static void main(String[] args) &#123; Base b = new Sub(); &#125;&#125; &emsp;&emsp;当时看到这道题的时候，关于类的加载，初始化基本已经忘记，所以直接做错。该题的正确答案是：1null 为什么是null?首先我们从上面的内容可以了解到，类的初始化顺序是： 父类静态块 -&gt;子类静态块 -&gt;父类初始化语句 -&gt;父类构造函器 -&gt;子类初始化语句 子类构造器。 其实在掌握了我上面说的东西后，这道题的的答案为什么为null,已经是“柳暗花明又一村了”；所以我这里直接把fuck两点水博客上的内容摘抄过来 Base b = new Sub();在 main方法中声明父类变量b对子类的引用，JAVA类加载器将Base,Sub类加载到JVM;也就是完成了 Base 类和 Sub 类的初始化 JVM 为 Base,Sub 的的成员开辟内存空间且值均为null;在初始化Sub对象前，首先JAVA虚拟机就在堆区开辟内存并将子类 Sub 中的 baseName 和父类 Base 中的 baseName（已被隐藏）均赋为 null，就是子类继承父类的时候，同名的属性不会覆盖父类，只是会将父类的同名属性隐藏 调用父类的无参构造调用 Sub 的构造函数，因为子类没有重写构造函数，默认调用无参的构造函数，调用了 super() 。 callName 在子类中被重写，因此调用子类的 callName();调用了父类的构造函数，父类的构造函数中调用了 callName 方法，此时父类中的 baseName 的值为 base，可是子类重写了 callName 方法，且 调用父类 Base 中的 callName 是在子类 Sub 中调用的，因此当前的 this 指向的是子类，也就是说是实现子类的 callName 方法 调用子类的callName，打印baseName 实际上在new Sub()时，实际执行过程为：1234public Sub()&#123; super(); baseName = "sub"; &#125; 可见，在 baseName = “sub” 执行前，子类的 callName() 已经执行，所以子类的 baseName 为默认值状态 null 。&emsp;&emsp;上面的题，大家可以试着把子类中的baseName使用static进行修饰，看看会得到什么结果，加深自己的理解。&emsp;&emsp;关于类的加载和初始化的备忘录就到此结束了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>类初始化顺序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客(三)——百度分享集成]]></title>
    <url>%2F2017%2F02%2F26%2FHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在上一篇博客Hexo+Github搭建个人博客(二)——配置&amp;主题中我还留下了一个有关百度分享的东西没有说明。我之前也说这是我在搭建博客中遇到的最大的坑（没有之一）。在这篇博客中叫我将说一说我遇到了什么坑，以及怎么从坑里面爬出来的。当然怎么解决百度分享在https中的使用的具体方法并不是我搞出来的，首先要感谢hrwhisper在他的博文百度分享不支持https的解决方案中提出的解决方案。但是我在使用的过程中并不是很顺利的解决了我的问题（可能由于我使用的是Next)的主题），在使用其方案过程中还有不少坑需要注意的，下面我将一一说明。 注意：以下问题可能你没有遇到，我是在使用Next主题)中遇到的。 做好基本的配置&emsp;&emsp;请大家参照我的上一篇博文Hexo+Github搭建个人博客(二)——配置&amp;主题中有关百度分享集成的部分，先做好基本配置。 1. 在站点配置文件中，添加字段baidushare，值为 true&emsp;&emsp;关于什么是站点配置文件，我相信大家应该清楚了，如果不知道的话请看我的上一篇博文中有所提及。1baidushare: true #百度分享功能 2. 在主题配置文件中，找到baidushare字段，设置其展现方式12baidushare: type: button #百度分享展示的方式button|slide &emsp;&emsp;做好上面两步后，在你的百度分享还没有出现的情况下，打开浏览器的F12,发现提示https访问http资源的问题。之后介绍怎么解决百度分享在https下的使用。 百度分享在https中的使用&emsp;&emsp;百度分享不能使用的主要原因是它会去请求http中的资源，一个share.js，既然这样，我们能想到的就是把这个资源放到非http上，或者干脆直接放到我们自己的目录下面。&emsp;&emsp;大家可以按照方案提供者hrwhisper依照他的博文百度分享不支持https的解决方案去做，在遇到问题的时候回到我的博文，或者可以直接按照我说的做。 下载资源文件，并放到自己blog的目录下。 &emsp;&emsp;Github地址：https://github.com/hrwhisper/baiduShare&emsp;&emsp;这里我要强调一下，在站点配置文件中，有一个source_dir字段，这个是你访问资源的根目录，比如我在sourc中放置了一个test.jpg的文件，那么访问它的路径就是/test.jpg1source_dir: source &emsp;&emsp;static 解压后丢到站点根目录，也就是source目录下面。然后将百度分享中的代码修改，我使用的是Next主题，这段代码在文件F:\myblog\themes\next\layout_partials\share\baidushare.swing中，如果你找不到可以在你的主题文件夹中搜索baidushare。123.src=&apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt;改为.src=&apos;/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; 这样之后重启服务，看看百度分享是不是出现了，如果出现了，恭喜你，成功了。如果没有，请你继续往下看。 在站点配置文件中设置skip_render字段&emsp;&emsp;在你发现百度分享还是没有出现的时候，打开F12，是不是发现share.js文件已经成功加载了，但是这个文件报错，你进入F:\myblog.deploy_git\static\api\js(我的就是这个目录，因为我把博客放在了F:\myblog下)，打开share.js文件，发现这个文件末尾并没有加载完，我我们下载下来的static\api\js\share.js是不一样的，为什么？&emsp;&emsp; 原来，hexo会把/source下的文件全部渲染 怎么解决这个问题，有两种办法：你可以设置站点配置文件下的skip_rende字段，让hexo在渲染的时候跳过static之下的所有文件。123456789skip_rende: static/**#单个文件夹下的全部文件：skip_render: test/*#单个文件夹下的指定类型文件：skip_render: test/*.md#单个文件夹下的全部文件以及子目录:skip_render: test/**#多个文件夹：#skip_render:# test1/*.html #注意前面的空格，代表是skip_render之下的# test2/** &emsp;&emsp;你也可以选择不设置这个属性，而是把static文件放在主题文件的source目录下，我的是（F:\myblog\themes\next\source）。做完这些操作后，你的百度分享应该已经出现在你的博客中了，just enjoy it。（ps：除了以上解决百度在https下使用的方法以外，还有一个方法就是使用CDN，具体方式请参考巧用七牛CDN的镜像功能使百度分享支持HTTPS。再多说一句关于JiaThis不能支持https的问题个人觉得也可以用以上的方式来解决，这个大家可以自行研究。）（ps plus：关于博客的搭建就暂时告一段落了。）]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
        <tag>百度分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客(二)——配置&主题]]></title>
    <url>%2F2017%2F02%2F25%2FHexo-Github%E5%BB%BA%E7%AB%99%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在上一篇博客Hexo+Github搭建个人博客(一)——开始搭建中介绍了如何安装git、hexo以及将文件推送到github上，相信看到这篇博客的时候你已经有了一个漂亮的博客。这篇博客主要介绍如何发布文章、在站点配置文件中配置一些个性化的信息，以及更换主题（我现在使用的是Next主题，所以关于主题配置以及之后的集成第三方工具等都是基于Next主题来说的），更换主题后如何集成第三方工具。 发布新的博客&emsp;&emsp;既然博客已经搭建好了，那么不发几篇博文有就没有意义了，使用下面的命令来新建一篇叫做”brightloong”的文章。 1hexo new &apos;brightloong&apos; &emsp;&emsp;命令执行之后，你会在你文件博客根目录的source/_post目录下找到你刚刚新建的md后缀的文件，比如我的是F:\myblog\source_posts\brightloong.md，hexo博客是使用markdown语法来书写的，如果不熟悉markdown语法可以快速的看一下markdown语法说明，或者是认识与入门Markdown,后者也有推荐一些不同平台下使用的编辑Markdown的工具，本人使用的是Cmd Markdown，它既支持在线的编辑，也可以下载下来使用。生成的md文件打开如下： 注意：在冒号后面一定要加上一个空格，否则在生成静态文件的时候会报错，并且也不能将其成功推送到github。 123456---title: brightloong #文章标题date: 2017-02-24 12:03:12 #创建时间tags: #文章标签，如果有多个标签可以使用[1,2,3]的形式，还有其他形式自己摸索吧---#这之后是正文 &emsp;&emsp;文章编写好之后，只用以下命令生成静态文件并推送到github上，执行完成后打开自己的博客页面，是不是发现刚刚编写的文章出现了；如果你想删除某一篇文章，那么在source/_post目录下找到对应的文章将其删除后，同样执行一下命令就OK了。 123hexo cleanhexo ghexo d 站点配置文件_config.yml&emsp;&emsp;站点配置文件_config.yml是在你博客保存目录的根目录下，注意将它与主题配置文件进行区分，比如我保存的博客目录为F:\myblog那么我站点配置文件为F:\myblog_config.yml，我使用的主题是Next主题，所以我的主题配置文件为F:\myblog\themes\next_config.yml。下面我先介绍下站点配置文件，我将一些主要的配置做了注释，如果你想了解更多的配置的含义和作用，请访问Hexo官方教程查看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: BrightLoong&apos;s Blog #博客的标题subtitle: #子标题description: Remember what should be remembered, and forget what should be forgotten.Alter what is changeable, and accept what is mutable. #博客描述，可以是一段你喜欢的话，也可以是你博客的描述，只要你开心就好。author: BrightLoong #作者language: zh-Hans #语言（我使用的是简体中文）timezone: #时区（默认使用电脑时间）##之下的保持默认就好，没有什么需要更改的# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; #and root as &apos;/child/&apos;url: https://brightloong.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: source #source目录public_dir: publictag_dir: tags #标签目录archive_dir: archives category_dir: categories #分类目录code_dir: downloads/codei18n_dir: :langskip_render: static/** #注意这个属性（跳过渲染），你暂时不用配置，我之后会讲到，这个也是我遇到的坑##之下的保持默认就好，没有什么需要更改的# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #你设置的主题，接下来我会说到这个# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/BrightLoong/BrightLoong.github.io.git branch: master 主题更换&emsp;&emsp;搭建自己的博客，最吸引人的莫过于那千变万化的主题了，大家可以在Hexo官网上看到无数漂亮、大方、简洁的主题。本人使用的是简洁的Next主题，你可以选择你喜欢的下载下来，将其解压放入themes目录中，比如我的目录是F:\myblog\themes，然后修改我在上面提到的站点配置文件中的theme属性，为你刚刚放入themes目录中文件的名字（最好是对解压文件修改一个名字，否则名字可能会比较长，我把我下载下来的主题改文了next）,做完这些之后并不代表你完成了，你还需要参考你所下载的主题所说的配置步骤进行相关的配置，由于不同的主题配置过程也尽不相同，大家根据自己下载的主题去配置，我在这里只说我使用的Next主题如何配置。 1theme: next 注意：从下面开始所说的都是Next主题的相关配置。 配置Next主题&emsp;&emsp;如果你使用的和我一样，也是Next的主题，那么你最好还是看官方提供Next使用文档，并且文档是中文版的,我也仅仅是讲一些容易被忽略的配置，以及我使用的配置，以及在使用过程中遇到的问题;至于如何更换头像，添加分类和标签页面、切换主题样式（Next主题包含3中样式）之类的，大家还是照着官方的做更好。 1. 配置网站图标&emsp;&emsp;如何让网站前能显示自己想要的图标，我当时也是找了很久，最后发现是在主题配置文件（我的是F:\myblog\themes\next_config.yml）的最前面，有一个favicon属性，我把一个名字叫favicon.ico的图片放到了F:\myblog\source下，然后配置如下：1favicon: /favicon.ico 2. 首页显示阅读全文按钮&emsp;&emsp;首页的文章是不是默认展开了，显示出了整篇文章，怎么才能显示出如下的阅读全文的按钮。在主题配置文件中找到auto_excerpt属性进行配置123auto_excerpt: enable: true #改写为true length: 150 #默认展示的高度 你也可以在自己的博文中添加&lt;!--more--&gt;来决定在首页展示到什么位置（我就喜欢用这种方式），这个标签后的内容就不会展示到首页啦。 3. 集成多说评论&emsp;&emsp;登录多说，登录后在首页选择“我要安装”。创建站点，填写表单。多说域名 这一栏填写的即是你的 duoshuo_shortname，如图：&emsp;&emsp;创建站点完成后在 站点配置文件(我的是F:\myblog_config.yml) 中新增 duoshuo_shortname 字段，值设置成上一步红框中的值。 注意：新增字段的时候一定不要让字段前面有空格，否则会被认为是子字段，无法正确解析 12#多说评论duoshuo_shortname: brightloong #设置为红框中的值 &emsp;&emsp;多说评论中可以开启热评文章，在站点配置文件中增加字段：1duoshuo_hotartical: true 开启后你可能会发现点击热评文章并不能跳转到对应的网页，进入多说后台查看，发现原来网址不正确，那简单，点击编辑修改成正确的网址就OK了。 4. 阅读次数统计&emsp;&emsp;次数统计又leancloud提供，请参考由由Doublemine 贡献提供的为Next主题添加阅读次数统计功能 5. 集成百度分享&emsp;&emsp;分享功能的集成是最坑的没有之一，我大概花了半天多的时间查找各种方法才将其解决，这里我先说官网的配置：编辑 站点配置文件，添加字段 baidushare，值为 true。1baidushare: true #百度分享功能 &emsp;&emsp;欢欢喜喜的打开自己的博客。咦！百度分享功能咋没有添加上啊。不急，听我慢道来。我在主题文件中发现一个文件F:\myblog\themes\next\layout_partials\share\baidushare.swing，内容如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123;% if theme.baidushare.type === &quot;button&quot; %&#125; &lt;div class=&quot;bdsharebuttonbox&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tsina&quot; data-cmd=&quot;tsina&quot; title=&quot;分享到新浪微博&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_douban&quot; data-cmd=&quot;douban&quot; title=&quot;分享到豆瓣网&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_sqq&quot; data-cmd=&quot;sqq&quot; title=&quot;分享到QQ好友&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_qzone&quot; data-cmd=&quot;qzone&quot; title=&quot;分享到QQ空间&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_weixin&quot; data-cmd=&quot;weixin&quot; title=&quot;分享到微信&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tieba&quot; data-cmd=&quot;tieba&quot; title=&quot;分享到百度贴吧&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_twi&quot; data-cmd=&quot;twi&quot; title=&quot;分享到Twitter&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_fbook&quot; data-cmd=&quot;fbook&quot; title=&quot;分享到Facebook&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_more&quot; data-cmd=&quot;more&quot;&gt;&lt;/a&gt; &lt;a class=&quot;bds_count&quot; data-cmd=&quot;count&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;2&quot;, &quot;bdMiniList&quot;: false, &quot;bdPic&quot;: &quot;&quot; &#125;, &quot;share&quot;: &#123; &quot;bdSize&quot;: &quot;16&quot;, &quot;bdStyle&quot;: &quot;0&quot; &#125;, &quot;image&quot;: &#123; &quot;viewList&quot;: [&quot;tsina&quot;, &quot;douban&quot;, &quot;sqq&quot;, &quot;qzone&quot;, &quot;weixin&quot;, &quot;twi&quot;, &quot;fbook&quot;], &quot;viewText&quot;: &quot;分享到：&quot;, &quot;viewSize&quot;: &quot;16&quot; &#125; &#125; &lt;/script&gt;&#123;% elseif theme.baidushare.type === &quot;slide&quot; %&#125; &lt;script&gt; window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;1&quot;, &quot;bdMiniList&quot;: false, &quot;bdPic&quot;: &quot;&quot; &#125;, &quot;image&quot;: &#123; &quot;viewList&quot;: [&quot;tsina&quot;, &quot;douban&quot;, &quot;sqq&quot;, &quot;qzone&quot;, &quot;weixin&quot;, &quot;twi&quot;, &quot;fbook&quot;], &quot;viewText&quot;: &quot;分享到：&quot;, &quot;viewSize&quot;: &quot;16&quot; &#125;, &quot;slide&quot;: &#123; &quot;bdImg&quot;: &quot;5&quot;, &quot;bdPos&quot;: &quot;left&quot;, &quot;bdTop&quot;: &quot;100&quot; &#125; &#125; &lt;/script&gt;&#123;% endif %&#125;&lt;script&gt; with(document)0[(getElementsByTagName(&apos;head&apos;)[0]||body).appendChild(createElement(&apos;script&apos;)).src=&apos;/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; &emsp;&emsp;注意到最开始的语句了吗if theme.baidushare.type === “button”，以及之后的else if theme.baidushare.type === “slide”什么意思，在theme下也就是主题配置文件中，baidushare字段下的type字段，我们打开主题配置文件(我的是F:\myblog\themes\next_config.yml)，这个配置是不是被注释掉了：12baidushare: type: button #百度分享展示的方式button|slide &emsp;&emsp;修改之后，再启动，发现还是没有（如果你是用的本地启动用local的方式访问可能会看到百度分享功能已经出现了），这个是后打开浏览器F12的调试功能，是不是发现控制台报错了，提示你从https中去访问http的资源是不行的。不知道大家有没有看到刚刚我们修改的主题配置文件中，在上面有一段注释： 123# Warning: Baidu Share does not support https.百度分享不支持httpsbaidushare: type: button 是的不支持https的方式，自己的域名是用https开头的（除非你自己购买了域名，如何购买更换域名请大家参考【Hexo+Github】域名和github绑定的问题）。并且，JiaThis等都不支持https，怎么办？我将在下一篇博客中单独介绍我在搭建博客中遇到的最大的坑，百度分享如何在https下使用。]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>建站</tag>
        <tag>hexo配置</tag>
        <tag>Next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客(一)——开始搭建]]></title>
    <url>%2F2017%2F02%2F24%2FHexo-Github%E5%BB%BA%E7%AB%99-%E4%B8%80-%E5%BC%80%E5%A7%8B%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前段时间本人利用业余时间，在网上查询各种资料，使用Hexo+Github的方式搭建起了我个人的博客——BrightLoong。相信网上已经有无数前辈写了类似的文章来记录如何搭建博客的过程和步骤，我也不哗众取宠或者班门弄斧了，把我在搭建博客中使用 资料做一个收集，同时也将我在搭建博客过程中遇到的坑列举出来，以及对应的解决方法，也是对搭建博客过程的一个记录，毕竟好记性不如烂笔头。那话不多说，接下来就是一个简单的介绍以及如何搭建的步骤(本文基本也是安照官方的步骤在介绍，我只是在有些地方记了下自己踩过的坑，强烈建议大家跟着Hexo官方文档操作)。 本文适用于Windows搭建 正文什么是Hexo&emsp;&emsp;在Hexo官网上如此描述：Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.（Hexo是一个快速，简单和强大的博客框架。你可以使用Markdown（或其他语言）写博客，之后Hexo能在几秒钟生成具有美观主题的静态文件。）如果你想了解更多关于Hexo的东西，请移步Hexo官网。&emsp;&emsp;Hexo是一款基于Node.js的静态博客框架，可以deploy到Github上，所以首先要在电脑上安装git和node.js,并在Github上注册自己的账号，由于这些东西不是本篇博客要涉及到的主要内容，你可以谷歌、百度，也可以参考我下面提供的链接。 Git安装&emsp;&emsp;你可以去官网下载Git，因为国外资源可能很慢，你也可以下载我在网盘上提供的Git镜像。具体如何使用，请参照廖雪峰老师关于Git的教程，如果你仅仅是想安装git那看看Git安装的那个章节 Node.js安装配置&emsp;&emsp;关于Node.js的安装以及配置，可以参照菜鸟教程上面关于Node.js安装配置的教程，上面也有下载的链接，本人就是参照上面安装的。具网上有些文章说，安装完成后最好重启电脑，以免之后无法使用hexo的相关命令，我倒是没有遇到，不过如果大家遇到这种问题就重启吧。 Hexo安装&emsp;&emsp;必须要在你安装了上述的Git以及Node.js之后才能进行Hexo的安装。 1. 用以下命令安装Hexo&emsp;&emsp;在任意地方点击右键，选择Git Bash Here $ npm install -g hexo-cli &emsp;&emsp;如果安装过程中遇到一下错误： ERROR Deployer not found : github &emsp;&emsp;运行 $ npm install hexo-deployer-git --save 2. 创建博客存放目录，并进行初始化，安装依赖包（最好不要使用带中文的路径，以免后面出现不必要的麻烦）&emsp;&emsp;打开一个目录，在这个地方点击右键选择Git Bash Here,执行以下命令 $ hexo init &lt;folder&gt; #创建目录并执行初始化 $ cd &lt;folder&gt; $ npm install #安装依赖包 &lt;folder&gt;改为你想要的目录。&emsp;&emsp;当然你也可以自己新建一个目录，比如我在F盘中创建了myblog目录，进入目录中点击右键选择Git Bash Here，直接执行以下命令 $ hexo init $ npm install &emsp;&emsp;不管你用哪种方式，执行完毕后你会发现以下目录结构 . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 3. 启动服务&emsp;&emsp;执行以下命令来启动服务 $hexo g #hexo generate，生成静态文件 $ hexo s #hexo server，启动本地服务器 &emsp;&emsp;如果启动过程中没有报错，此时你用浏览器访问http://localhost:4000/，是不是看到了一个Hello World的博客页面，hexo3.0使用的默认主题是landscape（之后我会讲如何更换主题，以及集成第三方的工具），而且此时的服务是本地启动的，别人并不能看到（继续我接下来的操作就好了）。&emsp;&emsp;这个时候如果在浏览器没看到漂亮的博客页面怎么办，别急，先确认你在启动过程中是不是报错了，如过有的话估计是上面的操作有误，如果没有并且发现页面一直在加载中，估计是端口被占用了，我就遇到了这个问题。怎么办?把4000端口给杀死，还有更简单的——在hexo s命令后面加上启动参数，修改默认端口：hexo s -p &lt;port&gt;，比如我用的 hexo s -p 8000，现在重新访问http://localhost:8000/记得把地址的8000改成你自己对应的端口号，是不是看到了美丽的界面。 4. 注册Github账号，并创建仓库。&emsp;&emsp;想要别人也访问到你的页面，跟着继续吧。首先在Github官网上注册一个账号，有账号的跳过注册，直接登录。登录后找到new repository按钮创建一个新的仓库。 &emsp;&emsp;然后填写repository name就行了，要注意的是：这个名字的格式必须为youname.github.io，并且必须和你的账户名相同，比如我的账户名是BrightLoong，我的地址就是brightloong.github.io（最开始我就是将name随意填写，虽然是这个格式但是根本访问不了，会报404的错误）。 5. 将本地文件推送到github&emsp;&emsp;最后，剩下的就是将本地文件推送到github上了，首先打开站点配置文件_config.yml，比如我的路径是：F:\myblog_bonfig.yml。找到最后的deploy属性，如果没有就自己添加，将配置修改为： deploy: type: git #推送方式 repository: https://github.com/BrightLoong/BrightLoong.github.io.git #你的推送地址 branch: master #你要推送的分支 这个地方要注意的是属性后面的冒号必须要有一个空格，否则会报错 &emsp;&emsp;配置好之后使用以下命令将服务部署到github上。 $ hexo clean $ hexo g $ hexo d &emsp;&emsp;使用hexo d命令，第一次会要求你输入用户名和密码，用户名和密码就是你注册github时候使用的用户名和密码。如果遇到以下错误： ERROR Deployer not found : github &emsp;&emsp;运行 $ npm install hexo-deployer-git --save &emsp;&emsp;再执行上面的命令。 $ npm install hexo-deployer-git --save &emsp;&emsp;如果你没有配置Github的SSH，那么可能需要配置一下，你可以用以下命令查看一下 ssh -T git@github.com &emsp;&emsp;如果成功会有以下提示（我的账户名叫BrightLoong） Hi BrightLoong! You&apos;ve successfully authenticated, but GitHub does not provide shell access. &emsp;&emsp;如果没有，可以参考博客git添加ssh-key查看config。 &emsp;&emsp;如果没有报错误，那么博客就已经搭建起来，并发布到Github上了，在浏览器输入youname.github.io就能看到自己的博客了，如果中途报错说未识别的用户名，那么如果你确定你填写是正确的，重复使用hexo d命令，我当时就遇到过这种情况，我估计是网络不好引起的。 结尾&emsp;&emsp;博客已经搭建起来了，是不是正如Hexo所说——fast, simple and powerful，这篇文章就说这么多。之后我介绍如何发布文章，更换主题，站点配置文件，以及如何集成第三方应用（多说评论、百度分享等）。希望对大家有帮助。 版权声明：本文为博主原创文章，转载请注明出处 BrightLoong’s Blog]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始Blog之旅]]></title>
    <url>%2F2017%2F02%2F17%2F%E5%BC%80%E5%A7%8Bblog%E4%B9%8B%E6%97%85%2F%E5%BC%80%E5%A7%8Bblog%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;终于在2017年，也是我大学毕业的第二个年头，抽业余时间，搭建起了属于自己的博客网，说实话，感觉有点迟。但是不管怎么样，至少是开始了，就如那一句话“最困难的是下定决心去做，剩下的只是坚持而已”，我下定决心去做了，并实现了第一步，但是或许最困难的其实是那后面的“坚持而已”。&emsp;&emsp;不知在何时何地何处，在何人的博客上曾看到过，大概的意思是有输入也要有输出，也就是说不仅要学习新东西，还要能够将学到的东西通过自己输出，反馈给大众；上升到哲学问题，在我看来就是中国的那一句“达则兼济天下”。“输出”我大概是还不太够资格，“达则兼济天下”我可能也做不到，既然如此我也就只好“穷则独善其身”，将自己的所感所想记录下来作为自己的回忆，将自己学习到的东西记录下来作为自己的备忘录，但是如果我自己的“独善其身”能够帮助到一些人，那也是极好的。&emsp;&emsp;这篇“开始Blog之旅”本就没什么中心思想，作为我的第一篇博客，文笔和内容肯定欠佳。既然如此，我干脆再多说一个话题。最近在大学的群里和同学朋友聊天，二十四、二十五岁的我们仿佛大多都处于一个迷茫的时期，大学毕业后，接收社会的冲撞与洗礼，工作快两年的我们却显得越来越迷茫，不知道自己想要什么，找不到自己要追求的目标，甚至更为甚者觉得生活失去了意义。想想自己，何尝不是也处于这个阶段，也许是因为一成不变的生活让我们感到无趣，也许是工作的压力让我们无法如往日一般无忧无虑，也许是发现自己曾经“面朝大海，春暖花开”的梦想被现实摧毁，又也许是那“采菊东篱下，悠然见南山”的意境已经当然无存。对于这种阶段我不知道怎么办，在思考良久后我给出我自己的回答——不管怎样，生活终将会继续，不是你和生活一同奔跑，就是你被生活推着向前，趁着离三十岁还有一段距离，趁着离“四十而立”还有一段路程，暂时不要把金钱看得太重太重（当然我并没有说没有金钱能生活下去，只是看得太过重要可能你就是被生活推着走了），多尝试不同的东西，可能在不断的尝试中你便能找到那个你能为之付出余生的事，年轻的我们还有试错的机会；找一个能陪你走一辈子的人，这样或许你会期待每一天下班之后回家；健康是最重要的，毕竟健康是“1”，其他是“1”后面的一串“0”,”1之不存0将焉附”；培养自己至少一个兴趣，哪怕这个兴趣就是打游戏，兴趣是你疲劳时候以及不堪工作压力时候放松的途径;最后一点：人生终究不圆满，至少不要让遗憾随处可见。&emsp;&emsp;感觉自己的话有点多了，那这一段就作为这篇没有中心思想的文章的结尾吧。希望这些文字能成为自己不断学习进步的动力，成为自己生活的回忆以及乐趣，也希望能做到自己博客上的那一句话：Remember what should be remembered, and forget what should be forgotten.Alter what is changeable, and accept what is mutable——记住该记住的，忘记该忘记的。改变能改变的，接受不能改变的，同时也对有拖延症的自己下一个决心，尽力做好后面的“坚持而已”。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2017/2/20]]></content>
      <categories>
        <category>随笔&amp;感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
</search>
