<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java,并发," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一. 线程池概述在介绍线程池之前，先说一下为什么在开发中要使用线程池，个人认为主要有一下的原因：  开发中使用线程的时候，大部分线程执行的时间很短，频繁的创建、启动、销毁线程带来不必要的资源消耗。 线程的创建、挂起、唤醒等操作都需要依靠CPU调度，大量的线程会频繁进行上下文切换，特别是任务执行时间短、任务数量多的情况，大量时间将花在上下文切换上，又耗时，又耗资源。 无法对任务做统一的管理、分配、">
<meta name="keywords" content="Java,并发">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadPoolExecutor源码解析">
<meta property="og:url" content="https://brightloong.github.io/2018/06/24/ThreadPoolExecutor源码解析/index.html">
<meta property="og:site_name" content="BrightLoong&#39;s Blog">
<meta property="og:description" content="一. 线程池概述在介绍线程池之前，先说一下为什么在开发中要使用线程池，个人认为主要有一下的原因：  开发中使用线程的时候，大部分线程执行的时间很短，频繁的创建、启动、销毁线程带来不必要的资源消耗。 线程的创建、挂起、唤醒等操作都需要依靠CPU调度，大量的线程会频繁进行上下文切换，特别是任务执行时间短、任务数量多的情况，大量时间将花在上下文切换上，又耗时，又耗资源。 无法对任务做统一的管理、分配、">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/49CCCAD75C1742BAA5DF85198E84252C?method=download&shareKey=b4940f6ca266a269a5a300c3648641f5">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB35d990d5903ec773b237da2baceb1daa?method=download&shareKey=2e314d49fcab405a644daccf6b32d350">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/ED50E646C3E448E28D5EE1A9588DBDF3?method=download&shareKey=7e335231a105f659ece6aa3f003d568c">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/4CF4088172D64FA6BCF98D5528A18BC1?method=download&shareKey=76b7ecc377a04238cb0c2089c33ba63b">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/FADE83494E474229A97DA761CE62DBFF?method=download&shareKey=0326192662e5e1b741e81dac31287883">
<meta property="og:updated_time" content="2018-06-27T12:37:43.279Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ThreadPoolExecutor源码解析">
<meta name="twitter:description" content="一. 线程池概述在介绍线程池之前，先说一下为什么在开发中要使用线程池，个人认为主要有一下的原因：  开发中使用线程的时候，大部分线程执行的时间很短，频繁的创建、启动、销毁线程带来不必要的资源消耗。 线程的创建、挂起、唤醒等操作都需要依靠CPU调度，大量的线程会频繁进行上下文切换，特别是任务执行时间短、任务数量多的情况，大量时间将花在上下文切换上，又耗时，又耗资源。 无法对任务做统一的管理、分配、">
<meta name="twitter:image" content="https://note.youdao.com/yws/api/personal/file/49CCCAD75C1742BAA5DF85198E84252C?method=download&shareKey=b4940f6ca266a269a5a300c3648641f5">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://brightloong.github.io/2018/06/24/ThreadPoolExecutor源码解析/"/>





  <title> ThreadPoolExecutor源码解析 | BrightLoong's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1c8a47024ddabbbadeed98a78b39934d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">BrightLoong's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://brightloong.github.io/2018/06/24/ThreadPoolExecutor源码解析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="BrightLoong">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="BrightLoong's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="BrightLoong's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ThreadPoolExecutor源码解析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-24T18:16:55+08:00">
                2018-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/06/24/ThreadPoolExecutor源码解析/" class="leancloud_visitors" data-flag-title="ThreadPoolExecutor源码解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://note.youdao.com/yws/api/personal/file/49CCCAD75C1742BAA5DF85198E84252C?method=download&amp;shareKey=b4940f6ca266a269a5a300c3648641f5" alt="ThreadPoolExecutor"></p>
<h2 id="一-线程池概述"><a href="#一-线程池概述" class="headerlink" title="一. 线程池概述"></a>一. 线程池概述</h2><p>在介绍线程池之前，先说一下为什么在开发中要使用线程池，个人认为主要有一下的原因：</p>
<ul>
<li>开发中使用线程的时候，大部分线程执行的时间很短，频繁的创建、启动、销毁线程带来不必要的资源消耗。</li>
<li>线程的创建、挂起、唤醒等操作都需要依靠CPU调度，大量的线程会频繁进行上下文切换，特别是任务执行时间短、任务数量多的情况，大量时间将花在上下文切换上，又耗时，又耗资源。</li>
<li>无法对任务做统一的管理、分配、和监控等。<a id="more"></a></li>
</ul>
<p>线程池主要通过ThreadPoolExecutor来实现，在ThreadPoolExecutor类注释上有下面一段话（下面是翻译过来的）：</p>
<p>线程池解决了两个不同的问题：由于减少了每个任务的调用开销，改进了执行大量异步任务的性能；并且它还提供了一种任务执行时限制和管理资源（包括线程）的方法。 同时每个ThreadPoolExecutor还维护一些基本统计信息，例如已完成任务的数量。</p>
<h2 id="二-线程池的构造方法参数解析"><a href="#二-线程池的构造方法参数解析" class="headerlink" title="二. 线程池的构造方法参数解析"></a>二. 线程池的构造方法参数解析</h2><h3 id="构造方法中各个参数的含义"><a href="#构造方法中各个参数的含义" class="headerlink" title="构造方法中各个参数的含义"></a>构造方法中各个参数的含义</h3><p>先上一张图，有个大概的印象。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB35d990d5903ec773b237da2baceb1daa?method=download&amp;shareKey=2e314d49fcab405a644daccf6b32d350" alt="threadPool"></p>
<ul>
<li>这里任务加入可以看做是放入了两个地方，一是线程池中，另一个是任务队列中。</li>
<li>放入线程池的又分为两个部分，一是corePoolSize，暂且叫做核心线程（下图红色部分），另一部分是非核心线程（下图橙色部分），核心线程+非核心线程 &lt;= maximumPoolSize。</li>
</ul>
<table>
<thead>
<tr>
<th>参 数</th>
<th>含 义</th>
</tr>
</thead>
<tbody>
<tr>
<td>corePoolSize</td>
<td>核心线程数，当向线程池中添加新任务的时候，如果此时线程数量小于corePoolSize，哪怕线程池中有空闲的线程，此时也会重新新建一个线程来处理这个任务请求。同时corePoolSize也是线程池中维持的线程数量，就算都是空闲线程的也会存在，除非设置了allowCoreThreadTimeOut。</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>线程池中最大的线程数量，当向线程池中添加新任务的时候如果此时线程数量大于corePoolSize，小于maximumPoolSize，并且队列已经满了，将会新建线程来处理这个任务请求。</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>非核心线程在空闲后存活的是时间。</td>
</tr>
<tr>
<td>unit</td>
<td>keepAliveTime的单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>任务队列，常用的有三种：SynchronousQueue、LinkedBlockingQueue、ArrayBlockingQueue</td>
</tr>
<tr>
<td>threadFactory</td>
<td>创建线程的工厂，默认使用DefaultThreadFactory</td>
</tr>
<tr>
<td>handler</td>
<td>被拒绝后的处理，拒绝处理策略。<br> a. CallerRunsPolicy，由调用execute方法提交任务的线程来执行这个任务<br>b. AbortPolicy，抛出异常RejectedExecutionException拒绝提交任务<br>c. DiscardPolicy，直接抛弃任务，不做任何处理<br> d. DiscardOldestPolicy，去除任务队列中的第一个任务，重新提交</td>
</tr>
</tbody>
</table>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认的ThreadFactory和拒绝处理策略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用默认的拒绝处理策略    </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的ThreadFactory</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入所有参数，并且对参数进行校验   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-工作原理"><a href="#三-工作原理" class="headerlink" title="三. 工作原理"></a>三. 工作原理</h2><p>其原理如下图所示：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/ED50E646C3E448E28D5EE1A9588DBDF3?method=download&amp;shareKey=7e335231a105f659ece6aa3f003d568c" alt="theory"></p>
<p>当一个新加一个任务的时候执行如下步骤：</p>
<ol>
<li>首先尝试新建核心线程启动任务</li>
<li>核心线程已经满了，尝试加入到队列中</li>
<li>队列已经满了，尝试新建非核心线程启动任务</li>
<li>非核心线程已满，执行拒绝策略</li>
</ol>
<p>同时，当线程池中的工作线程执行完一个Task后会从队列中take任务执行。</p>
<h2 id="四-UML类图"><a href="#四-UML类图" class="headerlink" title="四. UML类图"></a>四. UML类图</h2><p><img src="https://note.youdao.com/yws/api/personal/file/4CF4088172D64FA6BCF98D5528A18BC1?method=download&amp;shareKey=76b7ecc377a04238cb0c2089c33ba63b" alt="UML"></p>
<ul>
<li>AbstractExecutorService，提供了ExecutorService的默认实现。</li>
<li>ExecutorService，定义了管理终止任务的一些方法以及让任务返回Future的方法。</li>
<li>Executor，只定义了一个execute()方法，任务的提交执行。</li>
<li>AbortPolicy、DiscardOldestPolicy、DiscardPolicy、CallerRunsPolicy，ThreadPoolExecutor内部定义的拒绝策略类。</li>
<li>Worker，是实现线程池重要的内部类，其UML类图如下：</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/FADE83494E474229A97DA761CE62DBFF?method=download&amp;shareKey=0326192662e5e1b741e81dac31287883" alt="Worker"></p>
<p>Worker类主要是运行任务的以及维护线程的中断控制状态，以及其他状态的记录。Worker类继承AbstractQueuedSynchronizer以简化每个任务执行时候的锁的获取和释放。</p>
<h2 id="五-源码分析"><a href="#五-源码分析" class="headerlink" title="五. 源码分析"></a>五. 源码分析</h2><blockquote>
<p>注意区分Worker和Taks，Worker是指工作线程，也就是用来执行任务的线程，Task是线程执行的任务（添加到队列中的就是任务）。</p>
</blockquote>
<h3 id="ThreadPoolExecutor关键变量"><a href="#ThreadPoolExecutor关键变量" class="headerlink" title="ThreadPoolExecutor关键变量"></a>ThreadPoolExecutor关键变量</h3><p>ThreadPoolExecutor使用一个原子integer(AtomicInteger)变量ctl（32位），来表示线程池的控制状态，这个状态值实际上由两部分组成：</p>
<ol>
<li>workerCount：有效的线程数，最大(2^29)-1，为ctl的低29位</li>
<li>runState：线程池运行状态，保存在ctl高位3位。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ctl初始化的时候状态为RUNNING，workerCount为0</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//workerCount位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//workerCount容量，(2^29)-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runState 的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取runState</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="comment">//获取workerCount</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<p>说一下上面线程池的几种状态：</p>
<ul>
<li>RUNNING：可以接受新的任务，并且处理在队列中的任务。</li>
<li>SHUTDOWN：不再接受新的任务，但是会把队列中的任务处理完成。</li>
<li>STOP：不再接受新的任务，也不处理队列中的任务，并且正在处理的任务会被中断。</li>
<li>TIDYING：所有任务都终止了，线程要转换到TIDYING状态，需要运行terminated()钩子方法。</li>
<li>TERMINATED：terminated()执行完成，到达这个状态时候awaitTermination()方法返回。</li>
</ul>
<p>在ThreadPoolExecutor类注释中提到状态之间的转换情况：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：调用shutdown()，或者隐式调用finalize()。</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()。</li>
<li>SHUTDOWN -&gt; TIDYING：当线程池和队列都为空的时候。</li>
<li>STOP -&gt; TIDYING：线程池为空的时候。</li>
<li>TIDYING -&gt; TERMINATED：钩子方法terminated()执行完成。</li>
</ul>
<h3 id="execute-Runnable-command"><a href="#execute-Runnable-command" class="headerlink" title="execute(Runnable command)"></a>execute(Runnable command)</h3><p>execute(Runnable command)，提交任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果线程池状态为Running（其他状态拒绝添加新任务到队列）将任务添加到队列中。</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">//添加成功后进行recheck</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">//如果当前状态不是Running,从队列中移除任务。</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">//刚刚在队列中加入了任务，保证线程池中至少有一个工作线程可以处理任务。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>分为3步来执行：</p>
<ol>
<li>如果workerCount小于corePoolSize，将任务作为first Task新建线程来执行任务。</li>
<li>将任务添加到队列中，如果添加成功依然需要检查，在进入任务之前，如果线程池被关闭，那么将任务从队列中移除；如果当前线程池中没有工作线程，而刚刚在队列中加入了任务，要保证线程池中至少有一个工作线程可以处理任务。</li>
<li>如果不能将任务加入队列中，尝试新加一个线程来执行任务，但是并不定会成功，可能是线程池被shut down或者线程池达到了饱和（maximumPoolSize），如果失败了执行拒绝策略。</li>
</ol>
<h3 id="关于Worker的构造函数"><a href="#关于Worker的构造函数" class="headerlink" title="关于Worker的构造函数"></a>关于Worker的构造函数</h3><p>在介绍addWorker(Runnable firstTask, boolean core)之前我们来看看Worker的构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>Worker实现了Runnable，这里将其构造为Thread赋值给thread。第一步中的setState(-1)，这一步很有意思，将AQS中的同步状态设置为-1，到后面我们会看到，线程池使用AQS中的同步状态来判断该工作线程是否可以被中断。-1：初始化值，此时工作线程还没有启动，也没有中断的必要；0：表示接受中断，此时工作线程为空闲状态；1：表示此时工作线程正在执行任务。</p>
<h3 id="addWorker-Runnable-firstTask-boolean-core"><a href="#addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="addWorker(Runnable firstTask, boolean core)"></a>addWorker(Runnable firstTask, boolean core)</h3><p>检查根据当前线程池的工作状态和给定的界限限制（corePoolSize 和maximumPoolSize）是否可以添加新的工作线程。 如果添加了新的工作线程，workerCount会相应调整，并且如果可能的话将firstTask作为其第一个任务运行。 如果线程池停止（Stop）或关闭(ShutDown)，此方法返回false。如果线程工厂未能创建线程，它也会返回false。如果线程创建失败，无论是由于线程工厂返回null还是由于异常（通常是Thread.start（）中的OutOfMemoryError），都会进行回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Param</span> core：如果为true把corePoolSize作为解析，否则把maximumPoolSize作为界限。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将下面的判断拆开来看。</span></span><br><span class="line">            <span class="comment">//rs &gt;= SHUTDOWN，在这个前提下，需要满足：</span></span><br><span class="line">            <span class="comment">//! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())</span></span><br><span class="line">            <span class="comment">//上面的可以这样理解，只有在同时满足三个条件的情况下才会返回false，所以话句话说，只要有一个不满足，就会返回true</span></span><br><span class="line">            <span class="comment">//将上面的判断修改为 (rs != SHUTDOWN || firstTask != null ||  workQueue.isEmpty())</span></span><br><span class="line">            <span class="comment">//rs != SHUTDOWN：基于rs &gt;= SHUTDOWN的前提下，当rs != SHUTDOWN，不再创建新的线程。</span></span><br><span class="line">            <span class="comment">//firstTask != null：基于rs &gt;= SHUTDOWN的前提下，不再接受新的任务。</span></span><br><span class="line">            <span class="comment">//workQueue.isEmpty()：任务队列为空，不用再创建新的工作线程来处理任务。</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">//检查工作线程数是否超过了界限，超过了返回false</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//使用CAS修改workerCount,加1，成功跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                <span class="comment">//+1操作失败，其他任务添加修改了workerCount值，继续循环。</span></span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//工作线程是否启动</span></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//工作线程是否添加成功</span></span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//新加一个工作线程，Worker本身也实现了Runabble</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这路获取到的其实是使用Worker生成的Thread</span></span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//在获取到锁之后再次检查状态</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//添加到工作线程组中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            <span class="comment">//记录当前工作线程总数</span></span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//添加工作线程成功。</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    <span class="comment">//启动工作线程，其实执行的是Worker中的run()</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Worker中的run"><a href="#Worker中的run" class="headerlink" title="Worker中的run()"></a>Worker中的run()</h3><p>Worker的run()方法实际调用的是runWorker(this)，启动工作线程（注意这里不是直接启动的任务），在工作线程中执行任务。</p>
<p>工作线程在这循环，反复的从队列中获取任务并执行它们。</p>
<ol>
<li>启动了初始的任务，也就是最开始创建工作线程的时候的firstTask。否则，只要线程池还在运行中，使用getTask()从队列中获取任务来执行。如果改变了线程池的工作状态，或者工作参数，getTask()返回null，此时工作线程将退出。或者工作线程因为异常而退出，此时异常退出标记completedAbruptly为true，之后会通过processWorkerExit新建一个工作线程来替换它。</li>
<li>在运行所有任务之前，需要获取锁，来保证当任务在运行的时候不会被中断，除非线程池正在停止（Stop）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取任务</span></span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// 将AQS同步状态设置为0（初始值为-1），表示当前工作线程为闲置状态，可以被中断了。</span></span><br><span class="line">        <span class="comment">//异常退出标记。</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//getTask()从队列中获取任务</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">//再次检查工作线程状态</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行前的钩子方法</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//注意区分和start(),调用run()并不会另启线程，而是在当前线程中执行，所以任务其实是在工作线程中执行的。</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//执行后的钩子方法</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//工作线程退出后的操作。</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h3><p>从队列中获取Task，大概分为以下几个步骤。</p>
<ol>
<li>判断线程池以及队列的状态，如果线程池状态在STOP以上，此时线程池不处理队列中的任务；或者线程池处于SHUTDOWN但是队列为空（SHUTDOWN不再接受新的任务），workerCount减1，返回null,注意此时只是将变量减1，其实工作线程并没有终止真正的终止在 processWorkerExit(w, completedAbruptly);中。</li>
<li>如果通过了状态检查，判断是否要进行线程回收，如果需要workerCount数量减1，成功后返回null。</li>
<li>根据timed（timed表示需要进行超时闲置线程回收），选择是限时等待还是阻塞的方式从队列中获取任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果线程池已经关闭（STOP状态不再处理队列中的任务），或者队列为空，workerCount减1，返回空。</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// allowCoreThreadTimeOut，是否允许回收核心线程。</span></span><br><span class="line">            <span class="comment">// timed表示需要进行超时闲置线程回收。</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1. (wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)：如果工作线程数量大于maximumPoolSize，或者闲置线程超时。</span></span><br><span class="line">            <span class="comment">//2. (wc &gt; 1 || workQueue.isEmpty())：队列不为空时，至少需要保留一个工作线程来处理队列中的任务</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="comment">//workerCount数量减1，CAS操作，失败了会不断循环。</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//根据timed，选择是限时等待还是阻塞的方式从队列中获取任务。</span></span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                <span class="comment">//workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 一段时间拿不到返回null,表示超时。</span></span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>说到getTask()顺便介绍几种队列：</p>
<ul>
<li>SynchronousQueue：Executors.newCachedThreadPool()中使用的队列。与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue，每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。所以使用这个队列，任务会直接提交给线程处理，所以一般会把maximumPoolSize指定成Integer.MAX_VALUE。</li>
<li>ArrayBlockingQueue：有界队列，队列可以限定长度，当添加新任务的时候，如果当前工作线程数量小于corePoolSize，则新建线程执行任务，否则如队列，以为队列是有限的，如果队列已经满了就会新建非核心线程执行任务，如果非核心线程也饱和了就会被拒绝，执行拒绝策略。</li>
<li>LinkedBlockingQueue（不设置预定值）：无界队列，因为是无界队列，所以maximumPoolSize这个属性的设定失效，线程池中的工作线程数用于不会大于corePoolSize。</li>
</ul>
<h3 id="processWorkerExit-Worker-w-boolean-completedAbruptly"><a href="#processWorkerExit-Worker-w-boolean-completedAbruptly" class="headerlink" title="processWorkerExit(Worker w, boolean completedAbruptly)"></a>processWorkerExit(Worker w, boolean completedAbruptly)</h3><p>工作线程退出后的操作，在这里进行线程池的终止以及工作线程的回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是异常退出，workerCount数量减1</span></span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">            <span class="comment">//从工作线程组中移除工作线程</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//尝试终止线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            <span class="comment">//如果是异常退出,直接新加一个工作线程。</span></span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="comment">//如何设置了allowCoreThreadTimeOut，最小工作线程数为0，否则为corePoolSize</span></span><br><span class="line">                <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                <span class="comment">//如果最小工作线程数为0，而队列又不为空，说明至少要保留一个工作线程</span></span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果当前工作线程数还大于最小工作线程数，直接返回，不添加新的工作线程</span></span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate()"></a>tryTerminate()</h3><p>尝试终止线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="comment">//以下三种情况表示不需要终止线程池。</span></span><br><span class="line">           <span class="comment">//1. isRunning(c)：处于Running状态。</span></span><br><span class="line">           <span class="comment">//2. runStateAtLeast(c, TIDYING)：TIDYING或者TERMINATED，已经在关闭了，不用重复关闭。</span></span><br><span class="line">           <span class="comment">//3. (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())：线程池处于SHUTDOWN状态，但是队列中还有任务没处理完。</span></span><br><span class="line">           <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">               runStateAtLeast(c, TIDYING) ||</span><br><span class="line">               (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//如果还有工作线程，终止一个空闲的工作线程后退回，这个时候表示并不想终止线程池。</span></span><br><span class="line">           <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">               <span class="comment">//只终止一个工作线程</span></span><br><span class="line">               interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//下面的操作是在终止线程池，修改线程池状态。</span></span><br><span class="line">           <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">           mainLock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//设置为TIDYING状态，调用terminated()钩子方法</span></span><br><span class="line">               <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       terminated();</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">//终止操作完成，设置状态为TERMINATED</span></span><br><span class="line">                       ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                       <span class="comment">// 释放在termination条件上等待的所有线程</span></span><br><span class="line">                       termination.signalAll();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               mainLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// CAS操作失败后不断的循环。</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="interruptIdleWorkers-boolean-onlyOne"><a href="#interruptIdleWorkers-boolean-onlyOne" class="headerlink" title="interruptIdleWorkers(boolean onlyOne)"></a>interruptIdleWorkers(boolean onlyOne)</h3><p>中断闲置工作线程。重点是如何判断哪些是闲置的工作线程，并且可以被中断。满足 <code>!t.isInterrupted() &amp;&amp; w.tryLock()</code> :</p>
<ol>
<li>!t.isInterrupted()表示没有被中断。</li>
<li>w.tryLock()表示能获取到锁，获取到锁AQS的同步状态为0，表示工作线程闲置。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tru表示只中断一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                <span class="comment">//如果没有被中断，并且能成功获取到锁（获取到锁AQS的同步状态为0，表示工作线程闲置），那么就进行中断，不能获取到锁表示队列中有任务正在执行。</span></span><br><span class="line">                <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//进行中断操作。</span></span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果只中断一个，中断一个跳出。</span></span><br><span class="line">                <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h3><p>调用shutdown()，拒绝接受新的任务加入，会将正在执行的任务以及等待执行的任务执行完成，终止所有的闲置工作线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查是否有Shutdown权限</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">//设置线程池状态为SHUTDOWN</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">//关闭闲置的工作线程，最后调用的是interruptIdleWorkers(false)</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            <span class="comment">//钩子方法</span></span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h3><p>调用shutdownNow()会尝试停止所有执行的任务，也不会对队列中的等待任务进行处理，并返回等待执行的任务列表，它会终止所有的工作线程，与shutdown()不同，shutdown()只会终止所有的空闲工作线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查是否有Shutdown权限</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">//设置线程池状态为STOP</span></span><br><span class="line">            advanceRunState(STOP);</span><br><span class="line">            <span class="comment">//终止所有工作线程</span></span><br><span class="line">            interruptWorkers();</span><br><span class="line">            <span class="comment">//获取等待执行的任务列表</span></span><br><span class="line">            tasks = drainQueue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试终止线程池。</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="interruptWorkers-以及-interruptIfStarted"><a href="#interruptWorkers-以及-interruptIfStarted" class="headerlink" title="interruptWorkers() 以及 interruptIfStarted()"></a>interruptWorkers() 以及 interruptIfStarted()</h3><p>终止所有的工作线程。主要看看interruptIfStarted()中是如何判断哪些工作线程是可以被终止的，满足 <code>getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()</code> :</p>
<ol>
<li>getState() &gt;= 0 获取CAS同步状态，上面说到同步状态初始化为-1，-1表示不可以被中断（可以看做当前工作线程没有启动），0表示闲置工作线程，1表示正在执行任务的工作线程。</li>
<li>(t = thread) != null 这个不用说了，为空还终止个啥。</li>
<li>!t.isInterrupted()，没有终止，避免重复调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                w.interruptIfStarted();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="comment">//getState()用于判断线程是否启动，具体看上面的解释。</span></span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat_play.jpg" alt="BrightLoong WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/aliplay.jpg" alt="BrightLoong Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/并发/" rel="tag"># 并发</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/21/Java同步器——AQS学习/" rel="next" title="Java同步器——AQS学习">
                <i class="fa fa-chevron-left"></i> Java同步器——AQS学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];</script>

      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTcwMy82Mjcx"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="BrightLoong" />
          <p class="site-author-name" itemprop="name">BrightLoong</p>
          <p class="site-description motion-element" itemprop="description">Remember what should be remembered, and forget what should be forgotten.Alter what is changeable, and accept what is mutable.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/BrightLoong/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/c19e2c35c1ae" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:chenlong_cn@163.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope-o"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-线程池概述"><span class="nav-number">1.</span> <span class="nav-text">一. 线程池概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-线程池的构造方法参数解析"><span class="nav-number">2.</span> <span class="nav-text">二. 线程池的构造方法参数解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法中各个参数的含义"><span class="nav-number">2.1.</span> <span class="nav-text">构造方法中各个参数的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法"><span class="nav-number">2.2.</span> <span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-工作原理"><span class="nav-number">3.</span> <span class="nav-text">三. 工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-UML类图"><span class="nav-number">4.</span> <span class="nav-text">四. UML类图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-源码分析"><span class="nav-number">5.</span> <span class="nav-text">五. 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor关键变量"><span class="nav-number">5.1.</span> <span class="nav-text">ThreadPoolExecutor关键变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execute-Runnable-command"><span class="nav-number">5.2.</span> <span class="nav-text">execute(Runnable command)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于Worker的构造函数"><span class="nav-number">5.3.</span> <span class="nav-text">关于Worker的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addWorker-Runnable-firstTask-boolean-core"><span class="nav-number">5.4.</span> <span class="nav-text">addWorker(Runnable firstTask, boolean core)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Worker中的run"><span class="nav-number">5.5.</span> <span class="nav-text">Worker中的run()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getTask"><span class="nav-number">5.6.</span> <span class="nav-text">getTask()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#processWorkerExit-Worker-w-boolean-completedAbruptly"><span class="nav-number">5.7.</span> <span class="nav-text">processWorkerExit(Worker w, boolean completedAbruptly)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tryTerminate"><span class="nav-number">5.8.</span> <span class="nav-text">tryTerminate()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interruptIdleWorkers-boolean-onlyOne"><span class="nav-number">5.9.</span> <span class="nav-text">interruptIdleWorkers(boolean onlyOne)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shutdown"><span class="nav-number">5.10.</span> <span class="nav-text">shutdown()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shutdownNow"><span class="nav-number">5.11.</span> <span class="nav-text">shutdownNow()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interruptWorkers-以及-interruptIfStarted"><span class="nav-number">5.12.</span> <span class="nav-text">interruptWorkers() 以及 interruptIfStarted()</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BrightLoong</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("CjvbYwDMyYkFVzn7hH7lHRKj-gzGzoHsz", "7Tr1I9AEuHGOezPTyIy1x1g3");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
